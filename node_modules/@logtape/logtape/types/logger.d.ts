import type { ContextLocalStorage } from "./context.js";
import type { Filter } from "./filter.js";
import { type LogLevel } from "./level.js";
import type { LogRecord } from "./record.js";
import type { Sink } from "./sink.js";
/**
 * A logger interface.  It provides methods to log messages at different
 * severity levels.
 *
 * ```typescript
 * const logger = getLogger("category");
 * logger.debug `A debug message with ${value}.`;
 * logger.info `An info message with ${value}.`;
 * logger.warn `A warning message with ${value}.`;
 * logger.error `An error message with ${value}.`;
 * logger.fatal `A fatal error message with ${value}.`;
 * ```
 */
export interface Logger {
    /**
     * The category of the logger.  It is an array of strings.
     */
    readonly category: readonly string[];
    /**
     * The logger with the supercategory of the current logger.  If the current
     * logger is the root logger, this is `null`.
     */
    readonly parent: Logger | null;
    /**
     * Get a child logger with the given subcategory.
     *
     * ```typescript
     * const logger = getLogger("category");
     * const subLogger = logger.getChild("sub-category");
     * ```
     *
     * The above code is equivalent to:
     *
     * ```typescript
     * const logger = getLogger("category");
     * const subLogger = getLogger(["category", "sub-category"]);
     * ```
     *
     * @param subcategory The subcategory.
     * @returns The child logger.
     */
    getChild(subcategory: string | readonly [string] | readonly [string, ...string[]]): Logger;
    /**
     * Get a logger with contextual properties.  This is useful for
     * log multiple messages with the shared set of properties.
     *
     * ```typescript
     * const logger = getLogger("category");
     * const ctx = logger.with({ foo: 123, bar: "abc" });
     * ctx.info("A message with {foo} and {bar}.");
     * ctx.warn("Another message with {foo}, {bar}, and {baz}.", { baz: true });
     * ```
     *
     * The above code is equivalent to:
     *
     * ```typescript
     * const logger = getLogger("category");
     * logger.info("A message with {foo} and {bar}.", { foo: 123, bar: "abc" });
     * logger.warn(
     *   "Another message with {foo}, {bar}, and {baz}.",
     *   { foo: 123, bar: "abc", baz: true },
     * );
     * ```
     *
     * @param properties
     * @returns
     * @since 0.5.0
     */
    with(properties: Record<string, unknown>): Logger;
    /**
     * Log a debug message.  Use this as a template string prefix.
     *
     * ```typescript
     * logger.debug `A debug message with ${value}.`;
     * ```
     *
     * @param message The message template strings array.
     * @param values The message template values.
     */
    debug(message: TemplateStringsArray, ...values: readonly unknown[]): void;
    /**
     * Log a debug message with properties.
     *
     * ```typescript
     * logger.debug('A debug message with {value}.', { value });
     * ```
     *
     * If the properties are expensive to compute, you can pass a callback that
     * returns the properties:
     *
     * ```typescript
     * logger.debug(
     *   'A debug message with {value}.',
     *   () => ({ value: expensiveComputation() })
     * );
     * ```
     *
     * @param message The message template.  Placeholders to be replaced with
     *                `values` are indicated by keys in curly braces (e.g.,
     *                `{value}`).
     * @param properties The values to replace placeholders with.  For lazy
     *                   evaluation, this can be a callback that returns the
     *                   properties.
     */
    debug(message: string, properties?: Record<string, unknown> | (() => Record<string, unknown>)): void;
    /**
     * Lazily log a debug message.  Use this when the message values are expensive
     * to compute and should only be computed if the message is actually logged.
     *
     * ```typescript
     * logger.debug(l => l`A debug message with ${expensiveValue()}.`);
     * ```
     *
     * @param callback A callback that returns the message template prefix.
     * @throws {TypeError} If no log record was made inside the callback.
     */
    debug(callback: LogCallback): void;
    /**
     * Log an informational message.  Use this as a template string prefix.
     *
     * ```typescript
     * logger.info `An info message with ${value}.`;
     * ```
     *
     * @param message The message template strings array.
     * @param values The message template values.
     */
    info(message: TemplateStringsArray, ...values: readonly unknown[]): void;
    /**
     * Log an informational message with properties.
     *
     * ```typescript
     * logger.info('An info message with {value}.', { value });
     * ```
     *
     * If the properties are expensive to compute, you can pass a callback that
     * returns the properties:
     *
     * ```typescript
     * logger.info(
     *   'An info message with {value}.',
     *   () => ({ value: expensiveComputation() })
     * );
     * ```
     *
     * @param message The message template.  Placeholders to be replaced with
     *                `values` are indicated by keys in curly braces (e.g.,
     *                `{value}`).
     * @param properties The values to replace placeholders with.  For lazy
     *                   evaluation, this can be a callback that returns the
     *                   properties.
     */
    info(message: string, properties?: Record<string, unknown> | (() => Record<string, unknown>)): void;
    /**
     * Lazily log an informational message.  Use this when the message values are
     * expensive to compute and should only be computed if the message is actually
     * logged.
     *
     * ```typescript
     * logger.info(l => l`An info message with ${expensiveValue()}.`);
     * ```
     *
     * @param callback A callback that returns the message template prefix.
     * @throws {TypeError} If no log record was made inside the callback.
     */
    info(callback: LogCallback): void;
    /**
     * Log a warning message.  Use this as a template string prefix.
     *
     * ```typescript
     * logger.warn `A warning message with ${value}.`;
     * ```
     *
     * @param message The message template strings array.
     * @param values The message template values.
     */
    warn(message: TemplateStringsArray, ...values: readonly unknown[]): void;
    /**
     * Log a warning message with properties.
     *
     * ```typescript
     * logger.warn('A warning message with {value}.', { value });
     * ```
     *
     * If the properties are expensive to compute, you can pass a callback that
     * returns the properties:
     *
     * ```typescript
     * logger.warn(
     *   'A warning message with {value}.',
     *   () => ({ value: expensiveComputation() })
     * );
     * ```
     *
     * @param message The message template.  Placeholders to be replaced with
     *                `values` are indicated by keys in curly braces (e.g.,
     *                `{value}`).
     * @param properties The values to replace placeholders with.  For lazy
     *                   evaluation, this can be a callback that returns the
     *                   properties.
     */
    warn(message: string, properties?: Record<string, unknown> | (() => Record<string, unknown>)): void;
    /**
     * Lazily log a warning message.  Use this when the message values are
     * expensive to compute and should only be computed if the message is actually
     * logged.
     *
     * ```typescript
     * logger.warn(l => l`A warning message with ${expensiveValue()}.`);
     * ```
     *
     * @param callback A callback that returns the message template prefix.
     * @throws {TypeError} If no log record was made inside the callback.
     */
    warn(callback: LogCallback): void;
    /**
     * Log an error message.  Use this as a template string prefix.
     *
     * ```typescript
     * logger.error `An error message with ${value}.`;
     * ```
     *
     * @param message The message template strings array.
     * @param values The message template values.
     */
    error(message: TemplateStringsArray, ...values: readonly unknown[]): void;
    /**
     * Log an error message with properties.
     *
     * ```typescript
     * logger.warn('An error message with {value}.', { value });
     * ```
     *
     * If the properties are expensive to compute, you can pass a callback that
     * returns the properties:
     *
     * ```typescript
     * logger.error(
     *   'An error message with {value}.',
     *   () => ({ value: expensiveComputation() })
     * );
     * ```
     *
     * @param message The message template.  Placeholders to be replaced with
     *                `values` are indicated by keys in curly braces (e.g.,
     *                `{value}`).
     * @param properties The values to replace placeholders with.  For lazy
     *                   evaluation, this can be a callback that returns the
     *                   properties.
     */
    error(message: string, properties?: Record<string, unknown> | (() => Record<string, unknown>)): void;
    /**
     * Lazily log an error message.  Use this when the message values are
     * expensive to compute and should only be computed if the message is actually
     * logged.
     *
     * ```typescript
     * logger.error(l => l`An error message with ${expensiveValue()}.`);
     * ```
     *
     * @param callback A callback that returns the message template prefix.
     * @throws {TypeError} If no log record was made inside the callback.
     */
    error(callback: LogCallback): void;
    /**
     * Log a fatal error message.  Use this as a template string prefix.
     *
     * ```typescript
     * logger.fatal `A fatal error message with ${value}.`;
     * ```
     *
     * @param message The message template strings array.
     * @param values The message template values.
     */
    fatal(message: TemplateStringsArray, ...values: readonly unknown[]): void;
    /**
     * Log a fatal error message with properties.
     *
     * ```typescript
     * logger.warn('A fatal error message with {value}.', { value });
     * ```
     *
     * If the properties are expensive to compute, you can pass a callback that
     * returns the properties:
     *
     * ```typescript
     * logger.fatal(
     *   'A fatal error message with {value}.',
     *   () => ({ value: expensiveComputation() })
     * );
     * ```
     *
     * @param message The message template.  Placeholders to be replaced with
     *                `values` are indicated by keys in curly braces (e.g.,
     *                `{value}`).
     * @param properties The values to replace placeholders with.  For lazy
     *                   evaluation, this can be a callback that returns the
     *                   properties.
     */
    fatal(message: string, properties?: Record<string, unknown> | (() => Record<string, unknown>)): void;
    /**
     * Lazily log a fatal error message.  Use this when the message values are
     * expensive to compute and should only be computed if the message is actually
     * logged.
     *
     * ```typescript
     * logger.fatal(l => l`A fatal error message with ${expensiveValue()}.`);
     * ```
     *
     * @param callback A callback that returns the message template prefix.
     * @throws {TypeError} If no log record was made inside the callback.
     */
    fatal(callback: LogCallback): void;
}
/**
 * A logging callback function.  It is used to defer the computation of a
 * message template until it is actually logged.
 * @param prefix The message template prefix.
 * @returns The rendered message array.
 */
export type LogCallback = (prefix: LogTemplatePrefix) => unknown[];
/**
 * A logging template prefix function.  It is used to log a message in
 * a {@link LogCallback} function.
 * @param message The message template strings array.
 * @param values The message template values.
 * @returns The rendered message array.
 */
export type LogTemplatePrefix = (message: TemplateStringsArray, ...values: unknown[]) => unknown[];
/**
 * Get a logger with the given category.
 *
 * ```typescript
 * const logger = getLogger(["my-app"]);
 * ```
 *
 * @param category The category of the logger.  It can be a string or an array
 *                 of strings.  If it is a string, it is equivalent to an array
 *                 with a single element.
 * @returns The logger.
 */
export declare function getLogger(category?: string | readonly string[]): Logger;
/**
 * A logger implementation.  Do not use this directly; use {@link getLogger}
 * instead.  This class is exported for testing purposes.
 */
export declare class LoggerImpl implements Logger {
    readonly parent: LoggerImpl | null;
    readonly children: Record<string, LoggerImpl | WeakRef<LoggerImpl>>;
    readonly category: readonly string[];
    readonly sinks: Sink[];
    parentSinks: "inherit" | "override";
    readonly filters: Filter[];
    lowestLevel: LogLevel | null;
    contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;
    static getLogger(category?: string | readonly string[]): LoggerImpl;
    private constructor();
    getChild(subcategory: string | readonly [string] | readonly [string, ...(readonly string[])]): LoggerImpl;
    /**
     * Reset the logger.  This removes all sinks and filters from the logger.
     */
    reset(): void;
    /**
     * Reset the logger and all its descendants.  This removes all sinks and
     * filters from the logger and all its descendants.
     */
    resetDescendants(): void;
    with(properties: Record<string, unknown>): Logger;
    filter(record: LogRecord): boolean;
    getSinks(level: LogLevel): Iterable<Sink>;
    emit(record: LogRecord, bypassSinks?: Set<Sink>): void;
    log(level: LogLevel, rawMessage: string, properties: Record<string, unknown> | (() => Record<string, unknown>), bypassSinks?: Set<Sink>): void;
    logLazily(level: LogLevel, callback: LogCallback, properties?: Record<string, unknown>): void;
    logTemplate(level: LogLevel, messageTemplate: TemplateStringsArray, values: unknown[], properties?: Record<string, unknown>): void;
    debug(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    info(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    warn(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    error(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    fatal(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
}
/**
 * A logger implementation with contextual properties.  Do not use this
 * directly; use {@link Logger.with} instead.  This class is exported
 * for testing purposes.
 */
export declare class LoggerCtx implements Logger {
    logger: LoggerImpl;
    properties: Record<string, unknown>;
    constructor(logger: LoggerImpl, properties: Record<string, unknown>);
    get category(): readonly string[];
    get parent(): Logger | null;
    getChild(subcategory: string | readonly [string] | readonly [string, ...string[]]): Logger;
    with(properties: Record<string, unknown>): Logger;
    log(level: LogLevel, message: string, properties: Record<string, unknown> | (() => Record<string, unknown>), bypassSinks?: Set<Sink>): void;
    logLazily(level: LogLevel, callback: LogCallback): void;
    logTemplate(level: LogLevel, messageTemplate: TemplateStringsArray, values: unknown[]): void;
    debug(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    info(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    warn(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    error(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
    fatal(message: TemplateStringsArray | string | LogCallback, ...values: unknown[]): void;
}
/**
 * Parse a message template into a message template array and a values array.
 * @param template The message template.
 * @param properties The values to replace placeholders with.
 * @returns The message template array and the values array.
 */
export declare function parseMessageTemplate(template: string, properties: Record<string, unknown>): readonly unknown[];
/**
 * Render a message template with values.
 * @param template The message template.
 * @param values The message template values.
 * @returns The message template values interleaved between the substitution
 *          values.
 */
export declare function renderMessage(template: TemplateStringsArray, values: readonly unknown[]): unknown[];
//# sourceMappingURL=logger.d.ts.map