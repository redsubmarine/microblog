import type { ContextLocalStorage } from "./context.js";
import { type FilterLike } from "./filter.js";
import type { LogLevel } from "./level.js";
import { type Sink } from "./sink.js";
/**
 * A configuration for the loggers.
 */
export interface Config<TSinkId extends string, TFilterId extends string> {
    /**
     * The sinks to use.  The keys are the sink identifiers, and the values are
     * {@link Sink}s.
     */
    sinks: Record<TSinkId, Sink>;
    /**
     * The filters to use.  The keys are the filter identifiers, and the values
     * are either {@link Filter}s or {@link LogLevel}s.
     */
    filters?: Record<TFilterId, FilterLike>;
    /**
     * The loggers to configure.
     */
    loggers: LoggerConfig<TSinkId, TFilterId>[];
    /**
     * The context-local storage to use for implicit contexts.
     * @since 0.7.0
     */
    contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;
    /**
     * Whether to reset the configuration before applying this one.
     */
    reset?: boolean;
}
/**
 * A logger configuration.
 */
export interface LoggerConfig<TSinkId extends string, TFilterId extends string> {
    /**
     * The category of the logger.  If a string, it is equivalent to an array
     * with one element.
     */
    category: string | string[];
    /**
     * The sink identifiers to use.
     */
    sinks?: TSinkId[];
    /**
     * Whether to inherit the parent's sinks.  If `inherit`, the parent's sinks
     * are used along with the specified sinks.  If `override`, the parent's
     * sinks are not used, and only the specified sinks are used.
     *
     * The default is `inherit`.
     * @default `"inherit"
     * @since 0.6.0
     */
    parentSinks?: "inherit" | "override";
    /**
     * The filter identifiers to use.
     */
    filters?: TFilterId[];
    /**
     * The log level to filter by.  If `null`, the logger will reject all
     * records.
     * @deprecated Use `filters` instead for backward compatibility, or use
     *             `lowestLevel` for less-misleading behavior.
     */
    level?: LogLevel | null;
    /**
     * The lowest log level to accept.  If `null`, the logger will reject all
     * records.
     * @since 0.8.0
     */
    lowestLevel?: LogLevel | null;
}
/**
 * Configure the loggers with the specified configuration.
 *
 * Note that if the given sinks or filters are disposable, they will be
 * disposed when the configuration is reset, or when the process exits.
 *
 * @example
 * ```typescript
 * await configure({
 *   sinks: {
 *     console: getConsoleSink(),
 *   },
 *   filters: {
 *     slow: (log) =>
 *       "duration" in log.properties &&
 *       log.properties.duration as number > 1000,
 *   },
 *   loggers: [
 *     {
 *       category: "my-app",
 *       sinks: ["console"],
 *       level: "info",
 *     },
 *     {
 *       category: ["my-app", "sql"],
 *       filters: ["slow"],
 *       level: "debug",
 *     },
 *     {
 *       category: "logtape",
 *       sinks: ["console"],
 *       level: "error",
 *     },
 *   ],
 * });
 * ```
 *
 * @param config The configuration.
 */
export declare function configure<TSinkId extends string, TFilterId extends string>(config: Config<TSinkId, TFilterId>): Promise<void>;
/**
 * Get the current configuration, if any.  Otherwise, `null`.
 * @returns The current configuration, if any.  Otherwise, `null`.
 */
export declare function getConfig(): Config<string, string> | null;
/**
 * Reset the configuration.  Mostly for testing purposes.
 */
export declare function reset(): Promise<void>;
/**
 * Dispose of the disposables.
 */
export declare function dispose(): Promise<void>;
/**
 * A configuration error.
 */
export declare class ConfigError extends Error {
    /**
     * Constructs a new configuration error.
     * @param message The error message.
     */
    constructor(message: string);
}
//# sourceMappingURL=config.d.ts.map