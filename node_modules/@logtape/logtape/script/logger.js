"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerCtx = exports.LoggerImpl = void 0;
exports.getLogger = getLogger;
exports.parseMessageTemplate = parseMessageTemplate;
exports.renderMessage = renderMessage;
const dntShim = __importStar(require("./_dnt.shims.js"));
const level_js_1 = require("./level.js");
/**
 * Get a logger with the given category.
 *
 * ```typescript
 * const logger = getLogger(["my-app"]);
 * ```
 *
 * @param category The category of the logger.  It can be a string or an array
 *                 of strings.  If it is a string, it is equivalent to an array
 *                 with a single element.
 * @returns The logger.
 */
function getLogger(category = []) {
    return LoggerImpl.getLogger(category);
}
/**
 * The symbol for the global root logger.
 */
const globalRootLoggerSymbol = Symbol.for("logtape.rootLogger");
/**
 * A logger implementation.  Do not use this directly; use {@link getLogger}
 * instead.  This class is exported for testing purposes.
 */
class LoggerImpl {
    static getLogger(category = []) {
        let rootLogger = globalRootLoggerSymbol in dntShim.dntGlobalThis
            ? (dntShim.dntGlobalThis[globalRootLoggerSymbol] ??
                null)
            : null;
        if (rootLogger == null) {
            rootLogger = new LoggerImpl(null, []);
            dntShim.dntGlobalThis[globalRootLoggerSymbol] =
                rootLogger;
        }
        if (typeof category === "string")
            return rootLogger.getChild(category);
        if (category.length === 0)
            return rootLogger;
        return rootLogger.getChild(category);
    }
    constructor(parent, category) {
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sinks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parentSinks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "inherit"
        });
        Object.defineProperty(this, "filters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lowestLevel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "debug"
        });
        Object.defineProperty(this, "contextLocalStorage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.parent = parent;
        this.children = {};
        this.category = category;
        this.sinks = [];
        this.filters = [];
    }
    getChild(subcategory) {
        const name = typeof subcategory === "string" ? subcategory : subcategory[0];
        const childRef = this.children[name];
        let child = childRef instanceof LoggerImpl
            ? childRef
            : childRef?.deref();
        if (child == null) {
            child = new LoggerImpl(this, [...this.category, name]);
            this.children[name] = "WeakRef" in dntShim.dntGlobalThis
                ? new WeakRef(child)
                : child;
        }
        if (typeof subcategory === "string" || subcategory.length === 1) {
            return child;
        }
        return child.getChild(subcategory.slice(1));
    }
    /**
     * Reset the logger.  This removes all sinks and filters from the logger.
     */
    reset() {
        while (this.sinks.length > 0)
            this.sinks.shift();
        this.parentSinks = "inherit";
        while (this.filters.length > 0)
            this.filters.shift();
        this.lowestLevel = "debug";
    }
    /**
     * Reset the logger and all its descendants.  This removes all sinks and
     * filters from the logger and all its descendants.
     */
    resetDescendants() {
        for (const child of Object.values(this.children)) {
            const logger = child instanceof LoggerImpl ? child : child.deref();
            if (logger != null)
                logger.resetDescendants();
        }
        this.reset();
    }
    with(properties) {
        return new LoggerCtx(this, { ...properties });
    }
    filter(record) {
        for (const filter of this.filters) {
            if (!filter(record))
                return false;
        }
        if (this.filters.length < 1)
            return this.parent?.filter(record) ?? true;
        return true;
    }
    *getSinks(level) {
        if (this.lowestLevel === null || (0, level_js_1.compareLogLevel)(level, this.lowestLevel) < 0) {
            return;
        }
        if (this.parent != null && this.parentSinks === "inherit") {
            for (const sink of this.parent.getSinks(level))
                yield sink;
        }
        for (const sink of this.sinks)
            yield sink;
    }
    emit(record, bypassSinks) {
        if (this.lowestLevel === null ||
            (0, level_js_1.compareLogLevel)(record.level, this.lowestLevel) < 0 ||
            !this.filter(record)) {
            return;
        }
        for (const sink of this.getSinks(record.level)) {
            if (bypassSinks?.has(sink))
                continue;
            try {
                sink(record);
            }
            catch (error) {
                const bypassSinks2 = new Set(bypassSinks);
                bypassSinks2.add(sink);
                metaLogger.log("fatal", "Failed to emit a log record to sink {sink}: {error}", { sink, error, record }, bypassSinks2);
            }
        }
    }
    log(level, rawMessage, properties, bypassSinks) {
        const implicitContext = LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};
        let cachedProps = undefined;
        const record = typeof properties === "function"
            ? {
                category: this.category,
                level,
                timestamp: Date.now(),
                get message() {
                    return parseMessageTemplate(rawMessage, this.properties);
                },
                rawMessage,
                get properties() {
                    if (cachedProps == null) {
                        cachedProps = {
                            ...implicitContext,
                            ...properties(),
                        };
                    }
                    return cachedProps;
                },
            }
            : {
                category: this.category,
                level,
                timestamp: Date.now(),
                message: parseMessageTemplate(rawMessage, {
                    ...implicitContext,
                    ...properties,
                }),
                rawMessage,
                properties: { ...implicitContext, ...properties },
            };
        this.emit(record, bypassSinks);
    }
    logLazily(level, callback, properties = {}) {
        const implicitContext = LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};
        let rawMessage = undefined;
        let msg = undefined;
        function realizeMessage() {
            if (msg == null || rawMessage == null) {
                msg = callback((tpl, ...values) => {
                    rawMessage = tpl;
                    return renderMessage(tpl, values);
                });
                if (rawMessage == null)
                    throw new TypeError("No log record was made.");
            }
            return [msg, rawMessage];
        }
        this.emit({
            category: this.category,
            level,
            get message() {
                return realizeMessage()[0];
            },
            get rawMessage() {
                return realizeMessage()[1];
            },
            timestamp: Date.now(),
            properties: { ...implicitContext, ...properties },
        });
    }
    logTemplate(level, messageTemplate, values, properties = {}) {
        const implicitContext = LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};
        this.emit({
            category: this.category,
            level,
            message: renderMessage(messageTemplate, values),
            rawMessage: messageTemplate,
            timestamp: Date.now(),
            properties: { ...implicitContext, ...properties },
        });
    }
    debug(message, ...values) {
        if (typeof message === "string") {
            this.log("debug", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("debug", message);
        }
        else {
            this.logTemplate("debug", message, values);
        }
    }
    info(message, ...values) {
        if (typeof message === "string") {
            this.log("info", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("info", message);
        }
        else {
            this.logTemplate("info", message, values);
        }
    }
    warn(message, ...values) {
        if (typeof message === "string") {
            this.log("warning", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("warning", message);
        }
        else {
            this.logTemplate("warning", message, values);
        }
    }
    error(message, ...values) {
        if (typeof message === "string") {
            this.log("error", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("error", message);
        }
        else {
            this.logTemplate("error", message, values);
        }
    }
    fatal(message, ...values) {
        if (typeof message === "string") {
            this.log("fatal", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("fatal", message);
        }
        else {
            this.logTemplate("fatal", message, values);
        }
    }
}
exports.LoggerImpl = LoggerImpl;
/**
 * A logger implementation with contextual properties.  Do not use this
 * directly; use {@link Logger.with} instead.  This class is exported
 * for testing purposes.
 */
class LoggerCtx {
    constructor(logger, properties) {
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "properties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.logger = logger;
        this.properties = properties;
    }
    get category() {
        return this.logger.category;
    }
    get parent() {
        return this.logger.parent;
    }
    getChild(subcategory) {
        return this.logger.getChild(subcategory).with(this.properties);
    }
    with(properties) {
        return new LoggerCtx(this.logger, { ...this.properties, ...properties });
    }
    log(level, message, properties, bypassSinks) {
        this.logger.log(level, message, typeof properties === "function"
            ? () => ({
                ...this.properties,
                ...properties(),
            })
            : { ...this.properties, ...properties }, bypassSinks);
    }
    logLazily(level, callback) {
        this.logger.logLazily(level, callback, this.properties);
    }
    logTemplate(level, messageTemplate, values) {
        this.logger.logTemplate(level, messageTemplate, values, this.properties);
    }
    debug(message, ...values) {
        if (typeof message === "string") {
            this.log("debug", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("debug", message);
        }
        else {
            this.logTemplate("debug", message, values);
        }
    }
    info(message, ...values) {
        if (typeof message === "string") {
            this.log("info", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("info", message);
        }
        else {
            this.logTemplate("info", message, values);
        }
    }
    warn(message, ...values) {
        if (typeof message === "string") {
            this.log("warning", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("warning", message);
        }
        else {
            this.logTemplate("warning", message, values);
        }
    }
    error(message, ...values) {
        if (typeof message === "string") {
            this.log("error", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("error", message);
        }
        else {
            this.logTemplate("error", message, values);
        }
    }
    fatal(message, ...values) {
        if (typeof message === "string") {
            this.log("fatal", message, (values[0] ?? {}));
        }
        else if (typeof message === "function") {
            this.logLazily("fatal", message);
        }
        else {
            this.logTemplate("fatal", message, values);
        }
    }
}
exports.LoggerCtx = LoggerCtx;
/**
 * The meta logger.  It is a logger with the category `["logtape", "meta"]`.
 */
const metaLogger = LoggerImpl.getLogger(["logtape", "meta"]);
/**
 * Parse a message template into a message template array and a values array.
 * @param template The message template.
 * @param properties The values to replace placeholders with.
 * @returns The message template array and the values array.
 */
function parseMessageTemplate(template, properties) {
    const message = [];
    let part = "";
    for (let i = 0; i < template.length; i++) {
        const char = template.charAt(i);
        const nextChar = template.charAt(i + 1);
        if (char === "{" && nextChar === "{") {
            // Escaped { character
            part = part + char;
            i++;
        }
        else if (char === "}" && nextChar === "}") {
            // Escaped } character
            part = part + char;
            i++;
        }
        else if (char === "{") {
            // Start of a placeholder
            message.push(part);
            part = "";
        }
        else if (char === "}") {
            // End of a placeholder
            let prop;
            if (part.match(/^\s|\s$/)) {
                prop = part in properties ? properties[part] : properties[part.trim()];
            }
            else {
                prop = properties[part];
            }
            message.push(prop);
            part = "";
        }
        else {
            // Default case
            part = part + char;
        }
    }
    message.push(part);
    return message;
}
/**
 * Render a message template with values.
 * @param template The message template.
 * @param values The message template values.
 * @returns The message template values interleaved between the substitution
 *          values.
 */
function renderMessage(template, values) {
    const args = [];
    for (let i = 0; i < template.length; i++) {
        args.push(template[i]);
        if (i < values.length)
            args.push(values[i]);
    }
    return args;
}
