"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withFilter = withFilter;
exports.getStreamSink = getStreamSink;
exports.getConsoleSink = getConsoleSink;
exports.getFileSink = getFileSink;
exports.getRotatingFileSink = getRotatingFileSink;
const filter_js_1 = require("./filter.js");
const formatter_js_1 = require("./formatter.js");
/**
 * Turns a sink into a filtered sink.  The returned sink only logs records that
 * pass the filter.
 *
 * @example Filter a console sink to only log records with the info level
 * ```typescript
 * const sink = withFilter(getConsoleSink(), "info");
 * ```
 *
 * @param sink A sink to be filtered.
 * @param filter A filter to apply to the sink.  It can be either a filter
 *               function or a {@link LogLevel} string.
 * @returns A sink that only logs records that pass the filter.
 */
function withFilter(sink, filter) {
    const filterFunc = (0, filter_js_1.toFilter)(filter);
    return (record) => {
        if (filterFunc(record))
            sink(record);
    };
}
/**
 * A factory that returns a sink that writes to a {@link WritableStream}.
 *
 * Note that the `stream` is of Web Streams API, which is different from
 * Node.js streams.  You can convert a Node.js stream to a Web Streams API
 * stream using [`stream.Writable.toWeb()`] method.
 *
 * [`stream.Writable.toWeb()`]: https://nodejs.org/api/stream.html#streamwritabletowebstreamwritable
 *
 * @example Sink to the standard error in Deno
 * ```typescript
 * const stderrSink = getStreamSink(Deno.stderr.writable);
 * ```
 *
 * @example Sink to the standard error in Node.js
 * ```typescript
 * import stream from "node:stream";
 * const stderrSink = getStreamSink(stream.Writable.toWeb(process.stderr));
 * ```
 *
 * @param stream The stream to write to.
 * @param options The options for the sink.
 * @returns A sink that writes to the stream.
 */
function getStreamSink(stream, options = {}) {
    const formatter = options.formatter ?? formatter_js_1.defaultTextFormatter;
    const encoder = options.encoder ?? new TextEncoder();
    const writer = stream.getWriter();
    let lastPromise = Promise.resolve();
    const sink = (record) => {
        const bytes = encoder.encode(formatter(record));
        lastPromise = lastPromise
            .then(() => writer.ready)
            .then(() => writer.write(bytes));
    };
    sink[Symbol.asyncDispose] = async () => {
        await lastPromise;
        await writer.close();
    };
    return sink;
}
/**
 * A console sink factory that returns a sink that logs to the console.
 *
 * @param options The options for the sink.
 * @returns A sink that logs to the console.
 */
function getConsoleSink(options = {}) {
    const formatter = options.formatter ?? formatter_js_1.defaultConsoleFormatter;
    const console = options.console ?? globalThis.console;
    return (record) => {
        const args = formatter(record);
        if (typeof args === "string") {
            const msg = args.replace(/\r?\n$/, "");
            if (record.level === "debug")
                console.debug(msg);
            else if (record.level === "info")
                console.info(msg);
            else if (record.level === "warning")
                console.warn(msg);
            else if (record.level === "error" || record.level === "fatal") {
                console.error(msg);
            }
            else
                throw new TypeError(`Invalid log level: ${record.level}.`);
        }
        else {
            if (record.level === "debug")
                console.debug(...args);
            else if (record.level === "info")
                console.info(...args);
            else if (record.level === "warning")
                console.warn(...args);
            else if (record.level === "error" || record.level === "fatal") {
                console.error(...args);
            }
            else
                throw new TypeError(`Invalid log level: ${record.level}.`);
        }
    };
}
/**
 * Get a platform-independent file sink.
 *
 * @typeParam TFile The type of the file descriptor.
 * @param path A path to the file to write to.
 * @param options The options for the sink and the file driver.
 * @returns A sink that writes to the file.  The sink is also a disposable
 *          object that closes the file when disposed.
 */
function getFileSink(path, options) {
    const formatter = options.formatter ?? formatter_js_1.defaultTextFormatter;
    const encoder = options.encoder ?? new TextEncoder();
    const fd = options.openSync(path);
    const sink = (record) => {
        options.writeSync(fd, encoder.encode(formatter(record)));
        options.flushSync(fd);
    };
    sink[Symbol.dispose] = () => options.closeSync(fd);
    return sink;
}
/**
 * Get a platform-independent rotating file sink.
 *
 * This sink writes log records to a file, and rotates the file when it reaches
 * the `maxSize`.  The rotated files are named with the original file name
 * followed by a dot and a number, starting from 1.  The number is incremented
 * for each rotation, and the maximum number of files to keep is `maxFiles`.
 *
 * @param path A path to the file to write to.
 * @param options The options for the sink and the file driver.
 * @returns A sink that writes to the file.  The sink is also a disposable
 *          object that closes the file when disposed.
 */
function getRotatingFileSink(path, options) {
    const formatter = options.formatter ?? formatter_js_1.defaultTextFormatter;
    const encoder = options.encoder ?? new TextEncoder();
    const maxSize = options.maxSize ?? 1024 * 1024;
    const maxFiles = options.maxFiles ?? 5;
    let offset = 0;
    try {
        const stat = options.statSync(path);
        offset = stat.size;
    }
    catch {
        // Continue as the offset is already 0.
    }
    let fd = options.openSync(path);
    function shouldRollover(bytes) {
        return offset + bytes.length > maxSize;
    }
    function performRollover() {
        options.closeSync(fd);
        for (let i = maxFiles - 1; i > 0; i--) {
            const oldPath = `${path}.${i}`;
            const newPath = `${path}.${i + 1}`;
            try {
                options.renameSync(oldPath, newPath);
            }
            catch (_) {
                // Continue if the file does not exist.
            }
        }
        options.renameSync(path, `${path}.1`);
        offset = 0;
        fd = options.openSync(path);
    }
    const sink = (record) => {
        const bytes = encoder.encode(formatter(record));
        if (shouldRollover(bytes))
            performRollover();
        options.writeSync(fd, bytes);
        options.flushSync(fd);
        offset += bytes.length;
    };
    sink[Symbol.dispose] = () => options.closeSync(fd);
    return sink;
}
