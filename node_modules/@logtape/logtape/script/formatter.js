"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ansiColorFormatter = exports.defaultTextFormatter = void 0;
exports.getTextFormatter = getTextFormatter;
exports.getAnsiColorFormatter = getAnsiColorFormatter;
exports.defaultConsoleFormatter = defaultConsoleFormatter;
const nodeUtil_js_1 = __importDefault(require("./nodeUtil.js"));
/**
 * The severity level abbreviations.
 */
const levelAbbreviations = {
    "debug": "DBG",
    "info": "INF",
    "warning": "WRN",
    "error": "ERR",
    "fatal": "FTL",
};
/**
 * A platform-specific inspect function.  In Deno, this is {@link Deno.inspect},
 * and in Node.js/Bun it is `util.inspect()`.  If neither is available, it
 * falls back to {@link JSON.stringify}.
 *
 * @param value The value to inspect.
 * @param options The options for inspecting the value.
 *                If `colors` is `true`, the output will be ANSI-colored.
 * @returns The string representation of the value.
 */
const inspect = 
// @ts-ignore: Deno global
// dnt-shim-ignore
"Deno" in globalThis && "inspect" in globalThis.Deno &&
    // @ts-ignore: Deno global
    // dnt-shim-ignore
    typeof globalThis.Deno.inspect === "function"
    ? (v, opts) => 
    // @ts-ignore: Deno global
    // dnt-shim-ignore
    globalThis.Deno.inspect(v, {
        strAbbreviateSize: Infinity,
        iterableLimit: Infinity,
        ...opts,
    })
    // @ts-ignore: Node.js global
    // dnt-shim-ignore
    : nodeUtil_js_1.default != null && "inspect" in nodeUtil_js_1.default && typeof nodeUtil_js_1.default.inspect === "function"
        ? (v, opts) => 
        // @ts-ignore: Node.js global
        // dnt-shim-ignore
        nodeUtil_js_1.default.inspect(v, {
            maxArrayLength: Infinity,
            maxStringLength: Infinity,
            ...opts,
        })
        : (v) => JSON.stringify(v);
/**
 * Get a text formatter with the specified options.  Although it's flexible
 * enough to create a custom formatter, if you want more control, you can
 * create a custom formatter that satisfies the {@link TextFormatter} type
 * instead.
 *
 * For more information on the options, see {@link TextFormatterOptions}.
 *
 * By default, the formatter formats log records as follows:
 *
 * ```
 * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
 * ```
 * @param options The options for the text formatter.
 * @returns The text formatter.
 * @since 0.6.0
 */
function getTextFormatter(options = {}) {
    const timestampRenderer = options.timestamp == null || options.timestamp === "date-time-timezone"
        ? (ts) => new Date(ts).toISOString().replace("T", " ").replace("Z", " +00:00")
        : options.timestamp === "date-time-tz"
            ? (ts) => new Date(ts).toISOString().replace("T", " ").replace("Z", " +00")
            : options.timestamp === "date-time"
                ? (ts) => new Date(ts).toISOString().replace("T", " ").replace("Z", "")
                : options.timestamp === "time-timezone"
                    ? (ts) => new Date(ts).toISOString().replace(/.*T/, "").replace("Z", " +00:00")
                    : options.timestamp === "time-tz"
                        ? (ts) => new Date(ts).toISOString().replace(/.*T/, "").replace("Z", " +00")
                        : options.timestamp === "time"
                            ? (ts) => new Date(ts).toISOString().replace(/.*T/, "").replace("Z", "")
                            : options.timestamp === "date"
                                ? (ts) => new Date(ts).toISOString().replace(/T.*/, "")
                                : options.timestamp === "rfc3339"
                                    ? (ts) => new Date(ts).toISOString()
                                    : options.timestamp;
    const categorySeparator = options.category ?? "·";
    const valueRenderer = options.value ?? inspect;
    const levelRenderer = options.level == null || options.level === "ABBR"
        ? (level) => levelAbbreviations[level]
        : options.level === "abbr"
            ? (level) => levelAbbreviations[level].toLowerCase()
            : options.level === "FULL"
                ? (level) => level.toUpperCase()
                : options.level === "full"
                    ? (level) => level
                    : options.level === "L"
                        ? (level) => level.charAt(0).toUpperCase()
                        : options.level === "l"
                            ? (level) => level.charAt(0)
                            : options.level;
    const formatter = options.format ??
        (({ timestamp, level, category, message }) => `${timestamp} [${level}] ${category}: ${message}`);
    return (record) => {
        let message = "";
        for (let i = 0; i < record.message.length; i++) {
            if (i % 2 === 0)
                message += record.message[i];
            else
                message += valueRenderer(record.message[i]);
        }
        const timestamp = timestampRenderer(record.timestamp);
        const level = levelRenderer(record.level);
        const category = typeof categorySeparator === "function"
            ? categorySeparator(record.category)
            : record.category.join(categorySeparator);
        const values = {
            timestamp,
            level,
            category,
            message,
            record,
        };
        return `${formatter(values)}\n`;
    };
}
/**
 * The default text formatter.  This formatter formats log records as follows:
 *
 * ```
 * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
 * ```
 *
 * @param record The log record to format.
 * @returns The formatted log record.
 */
exports.defaultTextFormatter = getTextFormatter();
const RESET = "\x1b[0m";
const ansiColors = {
    black: "\x1b[30m",
    red: "\x1b[31m",
    green: "\x1b[32m",
    yellow: "\x1b[33m",
    blue: "\x1b[34m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m",
    white: "\x1b[37m",
};
const ansiStyles = {
    bold: "\x1b[1m",
    dim: "\x1b[2m",
    italic: "\x1b[3m",
    underline: "\x1b[4m",
    strikethrough: "\x1b[9m",
};
const defaultLevelColors = {
    debug: "blue",
    info: "green",
    warning: "yellow",
    error: "red",
    fatal: "magenta",
};
/**
 * Get an ANSI color formatter with the specified options.
 *
 * ![A preview of an ANSI color formatter.](https://i.imgur.com/I8LlBUf.png)
 * @param option The options for the ANSI color formatter.
 * @returns The ANSI color formatter.
 * @since 0.6.0
 */
function getAnsiColorFormatter(options = {}) {
    const format = options.format;
    const timestampStyle = typeof options.timestampStyle === "undefined"
        ? "dim"
        : options.timestampStyle;
    const timestampColor = options.timestampColor ?? null;
    const timestampPrefix = `${timestampStyle == null ? "" : ansiStyles[timestampStyle]}${timestampColor == null ? "" : ansiColors[timestampColor]}`;
    const timestampSuffix = timestampStyle == null && timestampColor == null
        ? ""
        : RESET;
    const levelStyle = typeof options.levelStyle === "undefined"
        ? "bold"
        : options.levelStyle;
    const levelColors = options.levelColors ?? defaultLevelColors;
    const categoryStyle = typeof options.categoryStyle === "undefined"
        ? "dim"
        : options.categoryStyle;
    const categoryColor = options.categoryColor ?? null;
    const categoryPrefix = `${categoryStyle == null ? "" : ansiStyles[categoryStyle]}${categoryColor == null ? "" : ansiColors[categoryColor]}`;
    const categorySuffix = categoryStyle == null && categoryColor == null
        ? ""
        : RESET;
    return getTextFormatter({
        timestamp: "date-time-tz",
        value(value) {
            return inspect(value, { colors: true });
        },
        ...options,
        format({ timestamp, level, category, message, record }) {
            const levelColor = levelColors[record.level];
            timestamp = `${timestampPrefix}${timestamp}${timestampSuffix}`;
            level = `${levelStyle == null ? "" : ansiStyles[levelStyle]}${levelColor == null ? "" : ansiColors[levelColor]}${level}${levelStyle == null && levelColor == null ? "" : RESET}`;
            return format == null
                ? `${timestamp} ${level} ${categoryPrefix}${category}:${categorySuffix} ${message}`
                : format({
                    timestamp,
                    level,
                    category: `${categoryPrefix}${category}${categorySuffix}`,
                    message,
                    record,
                });
        },
    });
}
/**
 * A text formatter that uses ANSI colors to format log records.
 *
 * ![A preview of ansiColorFormatter.](https://i.imgur.com/I8LlBUf.png)
 *
 * @param record The log record to format.
 * @returns The formatted log record.
 * @since 0.5.0
 */
exports.ansiColorFormatter = getAnsiColorFormatter();
/**
 * The styles for the log level in the console.
 */
const logLevelStyles = {
    "debug": "background-color: gray; color: white;",
    "info": "background-color: white; color: black;",
    "warning": "background-color: orange; color: black;",
    "error": "background-color: red; color: white;",
    "fatal": "background-color: maroon; color: white;",
};
/**
 * The default console formatter.
 *
 * @param record The log record to format.
 * @returns The formatted log record, as an array of arguments for
 *          {@link console.log}.
 */
function defaultConsoleFormatter(record) {
    let msg = "";
    const values = [];
    for (let i = 0; i < record.message.length; i++) {
        if (i % 2 === 0)
            msg += record.message[i];
        else {
            msg += "%o";
            values.push(record.message[i]);
        }
    }
    const date = new Date(record.timestamp);
    const time = `${date.getUTCHours().toString().padStart(2, "0")}:${date.getUTCMinutes().toString().padStart(2, "0")}:${date.getUTCSeconds().toString().padStart(2, "0")}.${date.getUTCMilliseconds().toString().padStart(3, "0")}`;
    return [
        `%c${time} %c${levelAbbreviations[record.level]}%c %c${record.category.join("\xb7")} %c${msg}`,
        "color: gray;",
        logLevelStyles[record.level],
        "background-color: default;",
        "color: gray;",
        "color: default;",
        ...values,
    ];
}
