import type { Span, Tracer } from "@opentelemetry/api";
import type { ActorAliasMapper, ActorDispatcher, ActorHandleMapper } from "../federation/callback.js";
import type { RequestContext } from "../federation/context.js";
/**
 * Parameters for {@link handleWebFinger}.
 */
export interface WebFingerHandlerParameters<TContextData> {
    /**
     * The request context.
     */
    context: RequestContext<TContextData>;
    /**
     * The canonical hostname of the server, if it's explicitly configured.
     * @since 1.5.0
     */
    host?: string;
    /**
     * The callback for dispatching the actor.
     */
    actorDispatcher?: ActorDispatcher<TContextData>;
    /**
     * The callback for mapping a WebFinger username to the corresponding actor's
     * internal identifier, or `null` if the username is not found.
     * @since 0.15.0
     */
    actorHandleMapper?: ActorHandleMapper<TContextData>;
    /**
     * The callback for mapping a WebFinger query to the corresponding actor's
     * internal identifier or username, or `null` if the query is not found.
     * @since 1.4.0
     */
    actorAliasMapper?: ActorAliasMapper<TContextData>;
    /**
     * The function to call when the actor is not found.
     */
    onNotFound(request: Request): Response | Promise<Response>;
    /**
     * The OpenTelemetry tracer.
     * @since 1.3.0
     */
    tracer?: Tracer;
    /**
     * The span for the request.
     * @since 1.3.0
     */
    span?: Span;
}
/**
 * Handles a WebFinger request.  You would not typically call this function
 * directly, but instead use {@link Federation.fetch} method.
 * @param request The WebFinger request to handle.
 * @param parameters The parameters for handling the request.
 * @returns The response to the request.
 */
export declare function handleWebFinger<TContextData>(request: Request, options: WebFingerHandlerParameters<TContextData>): Promise<Response>;
//# sourceMappingURL=handler.d.ts.map