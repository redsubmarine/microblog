import * as dntShim from "../_dnt.shims.js";
import type { TracerProvider } from "@opentelemetry/api";
import type { DocumentLoader } from "../runtime/docloader.js";
import type { Recipient } from "../vocab/actor.js";
import { Link, Object } from "../vocab/vocab.js";
import type { ActorDispatcher, AuthorizePredicate, CollectionCounter, CollectionCursor, CollectionDispatcher, InboxErrorHandler, ObjectAuthorizePredicate, ObjectDispatcher } from "./callback.js";
import type { Context, InboxContext, RequestContext } from "./context.js";
import { type InboxListenerSet } from "./inbox.js";
import type { KvKey, KvStore } from "./kv.js";
import type { MessageQueue } from "./mq.js";
export declare function acceptsJsonLd(request: Request): boolean;
export interface ActorHandlerParameters<TContextData> {
    identifier: string;
    context: RequestContext<TContextData>;
    actorDispatcher?: ActorDispatcher<TContextData>;
    authorizePredicate?: AuthorizePredicate<TContextData>;
    onUnauthorized(request: Request): Response | Promise<Response>;
    onNotFound(request: Request): Response | Promise<Response>;
    onNotAcceptable(request: Request): Response | Promise<Response>;
}
export declare function handleActor<TContextData>(request: Request, { identifier, context, actorDispatcher, authorizePredicate, onNotFound, onNotAcceptable, onUnauthorized, }: ActorHandlerParameters<TContextData>): Promise<Response>;
export interface ObjectHandlerParameters<TContextData> {
    values: Record<string, string>;
    context: RequestContext<TContextData>;
    objectDispatcher?: ObjectDispatcher<TContextData, Object, string>;
    authorizePredicate?: ObjectAuthorizePredicate<TContextData, string>;
    onUnauthorized(request: Request): Response | Promise<Response>;
    onNotFound(request: Request): Response | Promise<Response>;
    onNotAcceptable(request: Request): Response | Promise<Response>;
}
export declare function handleObject<TContextData>(request: Request, { values, context, objectDispatcher, authorizePredicate, onNotFound, onNotAcceptable, onUnauthorized, }: ObjectHandlerParameters<TContextData>): Promise<Response>;
/**
 * Callbacks for handling a collection.
 */
export interface CollectionCallbacks<TItem, TContext extends Context<TContextData>, TContextData, TFilter> {
    /**
     * A callback that dispatches a collection.
     */
    dispatcher: CollectionDispatcher<TItem, TContext, TContextData, TFilter>;
    /**
     * A callback that counts the number of items in a collection.
     */
    counter?: CollectionCounter<TContextData, TFilter>;
    /**
     * A callback that returns the first cursor for a collection.
     */
    firstCursor?: CollectionCursor<TContext, TContextData, TFilter>;
    /**
     * A callback that returns the last cursor for a collection.
     */
    lastCursor?: CollectionCursor<TContext, TContextData, TFilter>;
    /**
     * A callback that determines if a request is authorized to access the collection.
     */
    authorizePredicate?: AuthorizePredicate<TContextData>;
}
export interface CollectionHandlerParameters<TItem, TContext extends RequestContext<TContextData>, TContextData, TFilter> {
    name: string;
    identifier: string;
    uriGetter: (handle: string) => URL;
    filter?: TFilter;
    filterPredicate?: (item: TItem) => boolean;
    context: TContext;
    collectionCallbacks?: CollectionCallbacks<TItem, TContext, TContextData, TFilter>;
    tracerProvider?: TracerProvider;
    onUnauthorized(request: Request): Response | Promise<Response>;
    onNotFound(request: Request): Response | Promise<Response>;
    onNotAcceptable(request: Request): Response | Promise<Response>;
}
export declare function handleCollection<TItem extends URL | Object | Link | Recipient, TContext extends RequestContext<TContextData>, TContextData, TFilter>(request: Request, { name, identifier, uriGetter, filter, filterPredicate, context, collectionCallbacks, tracerProvider, onUnauthorized, onNotFound, onNotAcceptable, }: CollectionHandlerParameters<TItem, TContext, TContextData, TFilter>): Promise<Response>;
export interface InboxHandlerParameters<TContextData> {
    recipient: string | null;
    context: RequestContext<TContextData>;
    inboxContextFactory(recipient: string | null, activity: unknown, activityId: string | undefined, activityType: string): InboxContext<TContextData>;
    kv: KvStore;
    kvPrefixes: {
        activityIdempotence: KvKey;
        publicKey: KvKey;
    };
    queue?: MessageQueue;
    actorDispatcher?: ActorDispatcher<TContextData>;
    inboxListeners?: InboxListenerSet<TContextData>;
    inboxErrorHandler?: InboxErrorHandler<TContextData>;
    onNotFound(request: Request): Response | Promise<Response>;
    signatureTimeWindow: dntShim.Temporal.Duration | dntShim.Temporal.DurationLike | false;
    skipSignatureVerification: boolean;
    tracerProvider?: TracerProvider;
}
export declare function handleInbox<TContextData>(request: Request, options: InboxHandlerParameters<TContextData>): Promise<Response>;
/**
 * Options for the {@link respondWithObject} and
 * {@link respondWithObjectIfAcceptable} functions.
 * @since 0.3.0
 */
export interface RespondWithObjectOptions {
    /**
     * The document loader to use for compacting JSON-LD.
     * @since 0.8.0
     */
    contextLoader: DocumentLoader;
}
/**
 * Responds with the given object in JSON-LD format.
 *
 * @param object The object to respond with.
 * @param options Options.
 * @since 0.3.0
 */
export declare function respondWithObject(object: Object, options?: RespondWithObjectOptions): Promise<Response>;
/**
 * Responds with the given object in JSON-LD format if the request accepts
 * JSON-LD.
 *
 * @param object The object to respond with.
 * @param request The request to check for JSON-LD acceptability.
 * @param options Options.
 * @since 0.3.0
 */
export declare function respondWithObjectIfAcceptable(object: Object, request: Request, options?: RespondWithObjectOptions): Promise<Response | null>;
//# sourceMappingURL=handler.d.ts.map