/**
 * Additional options for enqueuing a message in a queue.
 *
 * @since 0.5.0
 */
import * as dntShim from "../_dnt.shims.js";
export interface MessageQueueEnqueueOptions {
    /**
     * The delay before the message is enqueued.  No delay by default.
     *
     * It must not be negative.
     */
    delay?: dntShim.Temporal.Duration;
}
/**
 * Additional options for listening to a message queue.
 *
 * @since 1.0.0
 */
export interface MessageQueueListenOptions {
    /**
     * The signal to abort listening to the message queue.
     */
    signal?: AbortSignal;
}
/**
 * An abstract interface for a message queue.
 *
 * @since 0.5.0
 */
export interface MessageQueue {
    /**
     * Enqueues a message in the queue.
     * @param message The message to enqueue.
     * @param options Additional options for enqueuing the message.
     */
    enqueue(message: any, options?: MessageQueueEnqueueOptions): Promise<void>;
    /**
     * Enqueues multiple messages in the queue.  This operation is optional,
     * and may not be supported by all implementations.  If not supported,
     * Fedify will invoke {@link enqueue} for each message.
     *
     * @param messages The messages to enqueue.
     * @param options Additional options for enqueuing the messages.
     */
    enqueueMany?: (messages: any[], options?: MessageQueueEnqueueOptions) => Promise<void>;
    /**
     * Listens for messages in the queue.
     * @param handler The handler for messages in the queue.
     * @param options Additional options for listening to the message queue.
     * @returns A promise that resolves when the listening is done.  It never
     *          rejects, and is resolved when the signal is aborted.  If no
     *          signal is provided, it never resolves.
     */
    listen(handler: (message: any) => Promise<void> | void, options?: MessageQueueListenOptions): Promise<void>;
}
/**
 * Additional options for {@link InProcessMessageQueue}.
 * @since 1.0.0
 */
export interface InProcessMessageQueueOptions {
    /**
     * The interval to poll for messages in the queue.  5 seconds by default.
     * @default `{ seconds: 5 }`
     */
    pollInterval?: dntShim.Temporal.Duration | dntShim.Temporal.DurationLike;
}
/**
 * A message queue that processes messages in the same process.
 * Do not use this in production as it does neither persist messages nor
 * distribute them across multiple processes.
 *
 * @since 0.5.0
 */
export declare class InProcessMessageQueue implements MessageQueue {
    #private;
    /**
     * Constructs a new {@link InProcessMessageQueue} with the given options.
     * @param options Additional options for the in-process message queue.
     */
    constructor(options?: InProcessMessageQueueOptions);
    enqueue(message: any, options?: MessageQueueEnqueueOptions): Promise<void>;
    enqueueMany(messages: any[], options?: MessageQueueEnqueueOptions): Promise<void>;
    listen(handler: (message: any) => Promise<void> | void, options?: MessageQueueListenOptions): Promise<void>;
}
/**
 * A message queue that processes messages in parallel.  It takes another
 * {@link MessageQueue}, and processes messages in parallel up to a certain
 * number of workers.
 *
 * Actually, it's rather a decorator than a queue itself.
 *
 * Note that the workers do not run in truly parallel, in the sense that they
 * are not running in separate threads or processes.  They are running in the
 * same process, but are scheduled to run in parallel.  Hence, this is useful
 * for I/O-bound tasks, but not for CPU-bound tasks, which is okay for Fedify's
 * workloads.
 *
 * @since 1.0.0
 */
export declare class ParallelMessageQueue implements MessageQueue {
    #private;
    readonly queue: MessageQueue;
    readonly workers: number;
    /**
     * Constructs a new {@link ParallelMessageQueue} with the given queue and
     * number of workers.
     * @param queue The message queue to use under the hood.  Note that
     *              {@link ParallelMessageQueue} cannot be nested.
     * @param workers The number of workers to process messages in parallel.
     * @throws {TypeError} If the given queue is an instance of
     *                     {@link ParallelMessageQueue}.
     */
    constructor(queue: MessageQueue, workers: number);
    enqueue(message: any, options?: MessageQueueEnqueueOptions): Promise<void>;
    enqueueMany(messages: any[], options?: MessageQueueEnqueueOptions): Promise<void>;
    listen(handler: (message: any) => Promise<void> | void, options?: MessageQueueListenOptions): Promise<void>;
}
//# sourceMappingURL=mq.d.ts.map