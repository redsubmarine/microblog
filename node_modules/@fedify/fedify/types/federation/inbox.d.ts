import { type Span, type TracerProvider } from "@opentelemetry/api";
import { Activity } from "../vocab/vocab.js";
import type { InboxErrorHandler, InboxListener } from "./callback.js";
import type { Context, InboxContext } from "./context.js";
import type { KvKey, KvStore } from "./kv.js";
import type { MessageQueue } from "./mq.js";
export declare class InboxListenerSet<TContextData> {
    #private;
    constructor();
    add<TActivity extends Activity>(type: new (...args: any[]) => TActivity, listener: InboxListener<TContextData, TActivity>): void;
    dispatchWithClass<TActivity extends Activity>(activity: TActivity): {
        class: new (...args: any[]) => Activity;
        listener: InboxListener<TContextData, TActivity>;
    } | null;
    dispatch<TActivity extends Activity>(activity: TActivity): InboxListener<TContextData, TActivity> | null;
}
export interface RouteActivityParameters<TContextData> {
    context: Context<TContextData>;
    json: unknown;
    activity: Activity;
    recipient: string | null;
    inboxListeners?: InboxListenerSet<TContextData>;
    inboxContextFactory(recipient: string | null, activity: unknown, activityId: string | undefined, activityType: string): InboxContext<TContextData>;
    inboxErrorHandler?: InboxErrorHandler<TContextData>;
    kv: KvStore;
    kvPrefixes: {
        activityIdempotence: KvKey;
    };
    queue?: MessageQueue;
    span: Span;
    tracerProvider?: TracerProvider;
}
export type RouteActivityResult = "alreadyProcessed" | "missingActor" | "enqueued" | "unsupportedActivity" | "error" | "success";
export declare function routeActivity<TContextData>({ context: ctx, json, activity, recipient, inboxListeners, inboxContextFactory, inboxErrorHandler, kv, kvPrefixes, queue, span, tracerProvider, }: RouteActivityParameters<TContextData>): Promise<RouteActivityResult>;
//# sourceMappingURL=inbox.d.ts.map