import * as dntShim from "../_dnt.shims.js";
import { getLogger, withContext } from "@logtape/logtape";
import { context, propagation, SpanKind, SpanStatusCode, trace, } from "@opentelemetry/api";
import { ATTR_HTTP_REQUEST_HEADER, ATTR_HTTP_REQUEST_METHOD, ATTR_HTTP_RESPONSE_HEADER, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_URL_FULL, } from "@opentelemetry/semantic-conventions";
import { getDefaultActivityTransformers } from "../compat/transformers.js";
import metadata from "../deno.js";
import { getNodeInfo } from "../nodeinfo/client.js";
import { handleNodeInfo, handleNodeInfoJrd } from "../nodeinfo/handler.js";
import { getAuthenticatedDocumentLoader, getDocumentLoader, kvCache, } from "../runtime/docloader.js";
import { verifyRequest } from "../sig/http.js";
import { exportJwk, importJwk, validateCryptoKey } from "../sig/key.js";
import { hasSignature, signJsonLd } from "../sig/ld.js";
import { getKeyOwner } from "../sig/owner.js";
import { signObject, verifyObject } from "../sig/proof.js";
import { lookupObject, traverseCollection, } from "../vocab/lookup.js";
import { getTypeId } from "../vocab/type.js";
import { Activity, CryptographicKey, Multikey, } from "../vocab/vocab.js";
import { handleWebFinger } from "../webfinger/handler.js";
import { buildCollectionSynchronizationHeader } from "./collection.js";
import { handleActor, handleCollection, handleInbox, handleObject, } from "./handler.js";
import { InboxListenerSet, routeActivity } from "./inbox.js";
import { KvKeyCache } from "./keycache.js";
import { createExponentialBackoffPolicy } from "./retry.js";
import { Router, RouterError } from "./router.js";
import { extractInboxes, sendActivity } from "./send.js";
/**
 * Create a new {@link Federation} instance.
 * @param parameters Parameters for initializing the instance.
 * @returns A new {@link Federation} instance.
 * @since 0.10.0
 */
export function createFederation(options) {
    return new FederationImpl(options);
}
export class FederationImpl {
    kv;
    kvPrefixes;
    inboxQueue;
    outboxQueue;
    fanoutQueue;
    inboxQueueStarted;
    outboxQueueStarted;
    fanoutQueueStarted;
    manuallyStartQueue;
    origin;
    router;
    nodeInfoDispatcher;
    actorCallbacks;
    objectCallbacks;
    objectTypeIds;
    inboxPath;
    inboxCallbacks;
    outboxCallbacks;
    followingCallbacks;
    followersCallbacks;
    likedCallbacks;
    featuredCallbacks;
    featuredTagsCallbacks;
    inboxListeners;
    inboxErrorHandler;
    sharedInboxKeyDispatcher;
    documentLoaderFactory;
    contextLoaderFactory;
    authenticatedDocumentLoaderFactory;
    allowPrivateAddress;
    userAgent;
    onOutboxError;
    signatureTimeWindow;
    skipSignatureVerification;
    outboxRetryPolicy;
    inboxRetryPolicy;
    activityTransformers;
    tracerProvider;
    constructor(options) {
        const logger = getLogger(["fedify", "federation"]);
        this.kv = options.kv;
        this.kvPrefixes = {
            ...{
                activityIdempotence: ["_fedify", "activityIdempotence"],
                remoteDocument: ["_fedify", "remoteDocument"],
                publicKey: ["_fedify", "publicKey"],
            },
            ...(options.kvPrefixes ?? {}),
        };
        if (options.queue == null) {
            this.inboxQueue = undefined;
            this.outboxQueue = undefined;
            this.fanoutQueue = undefined;
        }
        else if ("enqueue" in options.queue && "listen" in options.queue) {
            this.inboxQueue = options.queue;
            this.outboxQueue = options.queue;
            this.fanoutQueue = options.queue;
        }
        else {
            this.inboxQueue = options.queue.inbox;
            this.outboxQueue = options.queue.outbox;
            this.fanoutQueue = options.queue.fanout;
        }
        this.inboxQueueStarted = false;
        this.outboxQueueStarted = false;
        this.fanoutQueueStarted = false;
        this.manuallyStartQueue = options.manuallyStartQueue ?? false;
        if (options.origin != null) {
            if (typeof options.origin === "string") {
                if (!URL.canParse(options.origin) || !options.origin.match(/^https?:\/\//)) {
                    throw new TypeError(`Invalid origin: ${JSON.stringify(options.origin)}`);
                }
                const origin = new URL(options.origin);
                if (!origin.pathname.match(/^\/*$/) || origin.search !== "" ||
                    origin.hash !== "") {
                    throw new TypeError(`Invalid origin: ${JSON.stringify(options.origin)}`);
                }
                this.origin = { handleHost: origin.host, webOrigin: origin.origin };
            }
            else {
                const { handleHost, webOrigin } = options.origin;
                if (!URL.canParse(`https://${handleHost}/`) || handleHost.includes("/")) {
                    throw new TypeError(`Invalid origin.handleHost: ${JSON.stringify(handleHost)}`);
                }
                if (!URL.canParse(webOrigin) || !webOrigin.match(/^https?:\/\//)) {
                    throw new TypeError(`Invalid origin.webOrigin: ${JSON.stringify(webOrigin)}`);
                }
                const webOriginUrl = new URL(webOrigin);
                if (!webOriginUrl.pathname.match(/^\/*$/) || webOriginUrl.search !== "" ||
                    webOriginUrl.hash !== "") {
                    throw new TypeError(`Invalid origin.webOrigin: ${JSON.stringify(webOrigin)}`);
                }
                this.origin = {
                    handleHost: new URL(`https://${handleHost}/`).host,
                    webOrigin: webOriginUrl.origin,
                };
            }
        }
        this.router = new Router({
            trailingSlashInsensitive: options.trailingSlashInsensitive,
        });
        this.router.add("/.well-known/webfinger", "webfinger");
        this.router.add("/.well-known/nodeinfo", "nodeInfoJrd");
        this.objectCallbacks = {};
        this.objectTypeIds = {};
        if (options.allowPrivateAddress || options.userAgent != null) {
            if (options.documentLoader != null) {
                throw new TypeError("Cannot set documentLoader with allowPrivateAddress or " +
                    "userAgent options.");
            }
            else if (options.contextLoader != null) {
                throw new TypeError("Cannot set contextLoader with allowPrivateAddress or " +
                    "userAgent options.");
            }
            else if (options.authenticatedDocumentLoaderFactory != null) {
                throw new TypeError("Cannot set authenticatedDocumentLoaderFactory with " +
                    "allowPrivateAddress or userAgent options.");
            }
        }
        const { allowPrivateAddress, userAgent } = options;
        this.allowPrivateAddress = allowPrivateAddress ?? false;
        if (options.documentLoader != null) {
            if (options.documentLoaderFactory != null) {
                throw new TypeError("Cannot set both documentLoader and documentLoaderFactory options " +
                    "at a time; use documentLoaderFactory only.");
            }
            this.documentLoaderFactory = () => options.documentLoader;
            logger.warn("The documentLoader option is deprecated; use documentLoaderFactory " +
                "option instead.");
        }
        else {
            this.documentLoaderFactory = options.documentLoaderFactory ??
                ((opts) => {
                    return kvCache({
                        loader: getDocumentLoader({
                            allowPrivateAddress: opts?.allowPrivateAddress ??
                                allowPrivateAddress,
                            userAgent: opts?.userAgent ?? userAgent,
                        }),
                        kv: options.kv,
                        prefix: this.kvPrefixes.remoteDocument,
                    });
                });
        }
        if (options.contextLoader != null) {
            if (options.contextLoaderFactory != null) {
                throw new TypeError("Cannot set both contextLoader and contextLoaderFactory options " +
                    "at a time; use contextLoaderFactory only.");
            }
            this.contextLoaderFactory = () => options.contextLoader;
            logger.warn("The contextLoader option is deprecated; use contextLoaderFactory " +
                "option instead.");
        }
        else {
            this.contextLoaderFactory = options.contextLoaderFactory ??
                this.documentLoaderFactory;
        }
        this.authenticatedDocumentLoaderFactory =
            options.authenticatedDocumentLoaderFactory ??
                ((identity) => getAuthenticatedDocumentLoader(identity, {
                    allowPrivateAddress,
                    userAgent,
                }));
        this.userAgent = userAgent;
        this.onOutboxError = options.onOutboxError;
        this.signatureTimeWindow = options.signatureTimeWindow ?? { hours: 1 };
        this.skipSignatureVerification = options.skipSignatureVerification ?? false;
        this.outboxRetryPolicy = options.outboxRetryPolicy ??
            createExponentialBackoffPolicy();
        this.inboxRetryPolicy = options.inboxRetryPolicy ??
            createExponentialBackoffPolicy();
        this.activityTransformers = options.activityTransformers ??
            getDefaultActivityTransformers();
        this.tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
    }
    #getTracer() {
        return this.tracerProvider.getTracer(metadata.name, metadata.version);
    }
    async _startQueueInternal(ctxData, signal, queue) {
        if (this.inboxQueue == null && this.outboxQueue == null)
            return;
        const logger = getLogger(["fedify", "federation", "queue"]);
        const promises = [];
        if (this.inboxQueue != null && (queue == null || queue === "inbox") &&
            !this.inboxQueueStarted) {
            logger.debug("Starting an inbox task worker.");
            this.inboxQueueStarted = true;
            promises.push(this.inboxQueue.listen((msg) => this.#listenQueue(ctxData, msg), { signal }));
        }
        if (this.outboxQueue != null &&
            this.outboxQueue !== this.inboxQueue &&
            (queue == null || queue === "outbox") &&
            !this.outboxQueueStarted) {
            logger.debug("Starting an outbox task worker.");
            this.outboxQueueStarted = true;
            promises.push(this.outboxQueue.listen((msg) => this.#listenQueue(ctxData, msg), { signal }));
        }
        if (this.fanoutQueue != null &&
            this.fanoutQueue !== this.inboxQueue &&
            this.fanoutQueue !== this.outboxQueue &&
            (queue == null || queue === "fanout") &&
            !this.fanoutQueueStarted) {
            logger.debug("Starting a fanout task worker.");
            this.fanoutQueueStarted = true;
            promises.push(this.fanoutQueue.listen((msg) => this.#listenQueue(ctxData, msg), { signal }));
        }
        await Promise.all(promises);
    }
    #listenQueue(ctxData, message) {
        const tracer = this.#getTracer();
        const extractedContext = propagation.extract(context.active(), message.traceContext);
        return withContext({ messageId: message.id }, async () => {
            if (message.type === "fanout") {
                await tracer.startActiveSpan("activitypub.fanout", {
                    kind: SpanKind.CONSUMER,
                    attributes: {
                        "activitypub.activity.type": message.activityType,
                    },
                }, extractedContext, async (span) => {
                    if (message.activityId != null) {
                        span.setAttribute("activitypub.activity.id", message.activityId);
                    }
                    try {
                        await this.#listenFanoutMessage(ctxData, message);
                    }
                    catch (e) {
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: String(e),
                        });
                        throw e;
                    }
                    finally {
                        span.end();
                    }
                });
            }
            else if (message.type === "outbox") {
                await tracer.startActiveSpan("activitypub.outbox", {
                    kind: SpanKind.CONSUMER,
                    attributes: {
                        "activitypub.activity.type": message.activityType,
                        "activitypub.activity.retries": message.attempt,
                    },
                }, extractedContext, async (span) => {
                    if (message.activityId != null) {
                        span.setAttribute("activitypub.activity.id", message.activityId);
                    }
                    try {
                        await this.#listenOutboxMessage(ctxData, message, span);
                    }
                    catch (e) {
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: String(e),
                        });
                        throw e;
                    }
                    finally {
                        span.end();
                    }
                });
            }
            else if (message.type === "inbox") {
                await tracer.startActiveSpan("activitypub.inbox", {
                    kind: SpanKind.CONSUMER,
                    attributes: {
                        "activitypub.shared_inbox": message.identifier == null,
                    },
                }, extractedContext, async (span) => {
                    try {
                        await this.#listenInboxMessage(ctxData, message, span);
                    }
                    catch (e) {
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: String(e),
                        });
                        throw e;
                    }
                    finally {
                        span.end();
                    }
                });
            }
        });
    }
    async #listenFanoutMessage(data, message) {
        const logger = getLogger(["fedify", "federation", "fanout"]);
        logger.debug("Fanning out activity {activityId} to {inboxes} inbox(es)...", {
            activityId: message.activityId,
            inboxes: globalThis.Object.keys(message.inboxes).length,
        });
        const keys = await Promise.all(message.keys.map(async ({ keyId, privateKey }) => ({
            keyId: new URL(keyId),
            privateKey: await importJwk(privateKey, "private"),
        })));
        const activity = await Activity.fromJsonLd(message.activity, {
            contextLoader: this.contextLoaderFactory({
                allowPrivateAddress: this.allowPrivateAddress,
                userAgent: this.userAgent,
            }),
            documentLoader: this.documentLoaderFactory({
                allowPrivateAddress: this.allowPrivateAddress,
                userAgent: this.userAgent,
            }),
            tracerProvider: this.tracerProvider,
        });
        const context = this.#createContext(new URL(message.baseUrl), data, {
            documentLoader: this.documentLoaderFactory({
                allowPrivateAddress: this.allowPrivateAddress,
                userAgent: this.userAgent,
            }),
        });
        await this.sendActivity(keys, message.inboxes, activity, {
            collectionSync: message.collectionSync,
            context,
        });
    }
    async #listenOutboxMessage(_, message, span) {
        const logger = getLogger(["fedify", "federation", "outbox"]);
        const logData = {
            keyIds: message.keys.map((pair) => pair.keyId),
            inbox: message.inbox,
            activity: message.activity,
            activityId: message.activityId,
            attempt: message.attempt,
            headers: message.headers,
        };
        const keys = [];
        let rsaKeyPair = null;
        for (const { keyId, privateKey } of message.keys) {
            const pair = {
                keyId: new URL(keyId),
                privateKey: await importJwk(privateKey, "private"),
            };
            if (rsaKeyPair == null &&
                pair.privateKey.algorithm.name === "RSASSA-PKCS1-v1_5") {
                rsaKeyPair = pair;
            }
            keys.push(pair);
        }
        try {
            await sendActivity({
                keys,
                activity: message.activity,
                activityId: message.activityId,
                activityType: message.activityType,
                inbox: new URL(message.inbox),
                sharedInbox: message.sharedInbox,
                headers: new Headers(message.headers),
                tracerProvider: this.tracerProvider,
            });
        }
        catch (error) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: String(error) });
            const loaderOptions = this.#getLoaderOptions(message.baseUrl);
            const activity = await Activity.fromJsonLd(message.activity, {
                contextLoader: this.contextLoaderFactory(loaderOptions),
                documentLoader: rsaKeyPair == null
                    ? this.documentLoaderFactory(loaderOptions)
                    : this.authenticatedDocumentLoaderFactory(rsaKeyPair, loaderOptions),
                tracerProvider: this.tracerProvider,
            });
            try {
                this.onOutboxError?.(error, activity);
            }
            catch (error) {
                logger.error("An unexpected error occurred in onError handler:\n{error}", { ...logData, error });
            }
            const delay = this.outboxRetryPolicy({
                elapsedTime: dntShim.Temporal.Instant.from(message.started).until(dntShim.Temporal.Now.instant()),
                attempts: message.attempt,
            });
            if (delay != null) {
                logger.error("Failed to send activity {activityId} to {inbox} (attempt " +
                    "#{attempt}); retry...:\n{error}", { ...logData, error });
                await this.outboxQueue?.enqueue({
                    ...message,
                    attempt: message.attempt + 1,
                }, {
                    delay: dntShim.Temporal.Duration.compare(delay, { seconds: 0 }) < 0
                        ? dntShim.Temporal.Duration.from({ seconds: 0 })
                        : delay,
                });
            }
            else {
                logger.error("Failed to send activity {activityId} to {inbox} after {attempt} " +
                    "attempts; giving up:\n{error}", { ...logData, error });
            }
            return;
        }
        logger.info("Successfully sent activity {activityId} to {inbox}.", { ...logData });
    }
    async #listenInboxMessage(ctxData, message, span) {
        const logger = getLogger(["fedify", "federation", "inbox"]);
        const baseUrl = new URL(message.baseUrl);
        let context = this.#createContext(baseUrl, ctxData);
        if (message.identifier != null) {
            context = this.#createContext(baseUrl, ctxData, {
                documentLoader: await context.getDocumentLoader({
                    identifier: message.identifier,
                }),
            });
        }
        else if (this.sharedInboxKeyDispatcher != null) {
            const identity = await this.sharedInboxKeyDispatcher(context);
            if (identity != null) {
                context = this.#createContext(baseUrl, ctxData, {
                    documentLoader: "identifier" in identity || "username" in identity ||
                        "handle" in identity
                        ? await context.getDocumentLoader(identity)
                        : context.getDocumentLoader(identity),
                });
            }
        }
        const activity = await Activity.fromJsonLd(message.activity, context);
        span.setAttribute("activitypub.activity.type", getTypeId(activity).href);
        if (activity.id != null) {
            span.setAttribute("activitypub.activity.id", activity.id.href);
        }
        const cacheKey = activity.id == null ? null : [
            ...this.kvPrefixes.activityIdempotence,
            context.origin,
            activity.id.href,
        ];
        if (cacheKey != null) {
            const cached = await this.kv.get(cacheKey);
            if (cached === true) {
                logger.debug("Activity {activityId} has already been processed.", {
                    activityId: activity.id?.href,
                    activity: message.activity,
                    recipient: message.identifier,
                });
                return;
            }
        }
        await this.#getTracer().startActiveSpan("activitypub.dispatch_inbox_listener", { kind: SpanKind.INTERNAL }, async (span) => {
            const dispatched = this.inboxListeners?.dispatchWithClass(activity);
            if (dispatched == null) {
                logger.error("Unsupported activity type:\n{activity}", {
                    activityId: activity.id?.href,
                    activity: message.activity,
                    recipient: message.identifier,
                    trial: message.attempt,
                });
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: `Unsupported activity type: ${getTypeId(activity).href}`,
                });
                span.end();
                return;
            }
            const { class: cls, listener } = dispatched;
            span.updateName(`activitypub.dispatch_inbox_listener ${cls.name}`);
            try {
                await listener(context.toInboxContext(message.identifier, message.activity, activity.id?.href, getTypeId(activity).href), activity);
            }
            catch (error) {
                try {
                    await this.inboxErrorHandler?.(context, error);
                }
                catch (error) {
                    logger.error("An unexpected error occurred in inbox error handler:\n{error}", {
                        error,
                        trial: message.attempt,
                        activityId: activity.id?.href,
                        activity: message.activity,
                        recipient: message.identifier,
                    });
                }
                const delay = this.inboxRetryPolicy({
                    elapsedTime: dntShim.Temporal.Instant.from(message.started).until(dntShim.Temporal.Now.instant()),
                    attempts: message.attempt,
                });
                if (delay != null) {
                    logger.error("Failed to process the incoming activity {activityId} (attempt " +
                        "#{attempt}); retry...:\n{error}", {
                        error,
                        attempt: message.attempt,
                        activityId: activity.id?.href,
                        activity: message.activity,
                        recipient: message.identifier,
                    });
                    await this.inboxQueue?.enqueue({
                        ...message,
                        attempt: message.attempt + 1,
                    }, {
                        delay: dntShim.Temporal.Duration.compare(delay, { seconds: 0 }) < 0
                            ? dntShim.Temporal.Duration.from({ seconds: 0 })
                            : delay,
                    });
                }
                else {
                    logger.error("Failed to process the incoming activity {activityId} after " +
                        "{trial} attempts; giving up:\n{error}", {
                        error,
                        activityId: activity.id?.href,
                        activity: message.activity,
                        recipient: message.identifier,
                    });
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                return;
            }
            if (cacheKey != null) {
                await this.kv.set(cacheKey, true, {
                    ttl: dntShim.Temporal.Duration.from({ days: 1 }),
                });
            }
            logger.info("Activity {activityId} has been processed.", {
                activityId: activity.id?.href,
                activity: message.activity,
                recipient: message.identifier,
            });
            span.end();
        });
    }
    startQueue(contextData, options = {}) {
        return this._startQueueInternal(contextData, options.signal, options.queue);
    }
    createContext(urlOrRequest, contextData) {
        return urlOrRequest instanceof Request
            ? this.#createContext(urlOrRequest, contextData)
            : this.#createContext(urlOrRequest, contextData);
    }
    #createContext(urlOrRequest, contextData, opts = {}) {
        const request = urlOrRequest instanceof Request ? urlOrRequest : null;
        const url = urlOrRequest instanceof URL
            ? new URL(urlOrRequest)
            : new URL(urlOrRequest.url);
        if (request == null) {
            url.pathname = "/";
            url.hash = "";
            url.search = "";
        }
        const loaderOptions = this.#getLoaderOptions(url.origin);
        const ctxOptions = {
            url,
            federation: this,
            data: contextData,
            documentLoader: opts.documentLoader ??
                this.documentLoaderFactory(loaderOptions),
            contextLoader: this.contextLoaderFactory(loaderOptions),
        };
        if (request == null)
            return new ContextImpl(ctxOptions);
        return new RequestContextImpl({
            ...ctxOptions,
            request,
            invokedFromActorDispatcher: opts.invokedFromActorDispatcher,
            invokedFromObjectDispatcher: opts.invokedFromObjectDispatcher,
        });
    }
    #getLoaderOptions(origin) {
        origin = typeof origin === "string"
            ? new URL(origin).origin
            : origin.origin;
        return {
            allowPrivateAddress: this.allowPrivateAddress,
            userAgent: typeof this.userAgent === "string" ? this.userAgent : {
                url: origin,
                ...this.userAgent,
            },
        };
    }
    setNodeInfoDispatcher(path, dispatcher) {
        if (this.router.has("nodeInfo")) {
            throw new RouterError("NodeInfo dispatcher already set.");
        }
        const variables = this.router.add(path, "nodeInfo");
        if (variables.size !== 0) {
            throw new RouterError("Path for NodeInfo dispatcher must have no variables.");
        }
        this.nodeInfoDispatcher = dispatcher;
    }
    setActorDispatcher(path, dispatcher) {
        if (this.router.has("actor")) {
            throw new RouterError("Actor dispatcher already set.");
        }
        const variables = this.router.add(path, "actor");
        if (variables.size !== 1 ||
            !(variables.has("identifier") || variables.has("handle"))) {
            throw new RouterError("Path for actor dispatcher must have one variable: {identifier}");
        }
        if (variables.has("handle")) {
            getLogger(["fedify", "federation", "actor"]).warn("The {{handle}} variable in the actor dispatcher path is deprecated. " +
                "Use {{identifier}} instead.");
        }
        const callbacks = {
            dispatcher: async (context, identifier) => {
                const actor = await this.#getTracer().startActiveSpan("activitypub.dispatch_actor", {
                    kind: SpanKind.SERVER,
                    attributes: { "fedify.actor.identifier": identifier },
                }, async (span) => {
                    try {
                        const actor = await dispatcher(context, identifier);
                        span.setAttribute("activitypub.actor.id", (actor?.id ?? context.getActorUri(identifier)).href);
                        if (actor == null) {
                            span.setStatus({ code: SpanStatusCode.ERROR });
                        }
                        else {
                            span.setAttribute("activitypub.actor.type", getTypeId(actor).href);
                        }
                        return actor;
                    }
                    catch (error) {
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: String(error),
                        });
                        throw error;
                    }
                    finally {
                        span.end();
                    }
                });
                if (actor == null)
                    return null;
                const logger = getLogger(["fedify", "federation", "actor"]);
                if (actor.id == null) {
                    logger.warn("Actor dispatcher returned an actor without an id property.  " +
                        "Set the property with Context.getActorUri(identifier).");
                }
                else if (actor.id.href != context.getActorUri(identifier).href) {
                    logger.warn("Actor dispatcher returned an actor with an id property that " +
                        "does not match the actor URI.  Set the property with " +
                        "Context.getActorUri(identifier).");
                }
                if (this.followingCallbacks != null &&
                    this.followingCallbacks.dispatcher != null) {
                    if (actor.followingId == null) {
                        logger.warn("You configured a following collection dispatcher, but the " +
                            "actor does not have a following property.  Set the property " +
                            "with Context.getFollowingUri(identifier).");
                    }
                    else if (actor.followingId.href != context.getFollowingUri(identifier).href) {
                        logger.warn("You configured a following collection dispatcher, but the " +
                            "actor's following property does not match the following " +
                            "collection URI.  Set the property with " +
                            "Context.getFollowingUri(identifier).");
                    }
                }
                if (this.followersCallbacks != null &&
                    this.followersCallbacks.dispatcher != null) {
                    if (actor.followersId == null) {
                        logger.warn("You configured a followers collection dispatcher, but the " +
                            "actor does not have a followers property.  Set the property " +
                            "with Context.getFollowersUri(identifier).");
                    }
                    else if (actor.followersId.href != context.getFollowersUri(identifier).href) {
                        logger.warn("You configured a followers collection dispatcher, but the " +
                            "actor's followers property does not match the followers " +
                            "collection URI.  Set the property with " +
                            "Context.getFollowersUri(identifier).");
                    }
                }
                if (this.outboxCallbacks != null &&
                    this.outboxCallbacks.dispatcher != null) {
                    if (actor?.outboxId == null) {
                        logger.warn("You configured an outbox collection dispatcher, but the " +
                            "actor does not have an outbox property.  Set the property " +
                            "with Context.getOutboxUri(identifier).");
                    }
                    else if (actor.outboxId.href != context.getOutboxUri(identifier).href) {
                        logger.warn("You configured an outbox collection dispatcher, but the " +
                            "actor's outbox property does not match the outbox collection " +
                            "URI.  Set the property with Context.getOutboxUri(identifier).");
                    }
                }
                if (this.likedCallbacks != null &&
                    this.likedCallbacks.dispatcher != null) {
                    if (actor?.likedId == null) {
                        logger.warn("You configured a liked collection dispatcher, but the " +
                            "actor does not have a liked property.  Set the property " +
                            "with Context.getLikedUri(identifier).");
                    }
                    else if (actor.likedId.href != context.getLikedUri(identifier).href) {
                        logger.warn("You configured a liked collection dispatcher, but the " +
                            "actor's liked property does not match the liked collection " +
                            "URI.  Set the property with Context.getLikedUri(identifier).");
                    }
                }
                if (this.featuredCallbacks != null &&
                    this.featuredCallbacks.dispatcher != null) {
                    if (actor?.featuredId == null) {
                        logger.warn("You configured a featured collection dispatcher, but the " +
                            "actor does not have a featured property.  Set the property " +
                            "with Context.getFeaturedUri(identifier).");
                    }
                    else if (actor.featuredId.href != context.getFeaturedUri(identifier).href) {
                        logger.warn("You configured a featured collection dispatcher, but the " +
                            "actor's featured property does not match the featured collection " +
                            "URI.  Set the property with Context.getFeaturedUri(identifier).");
                    }
                }
                if (this.featuredTagsCallbacks != null &&
                    this.featuredTagsCallbacks.dispatcher != null) {
                    if (actor?.featuredTagsId == null) {
                        logger.warn("You configured a featured tags collection dispatcher, but the " +
                            "actor does not have a featuredTags property.  Set the property " +
                            "with Context.getFeaturedTagsUri(identifier).");
                    }
                    else if (actor.featuredTagsId.href !=
                        context.getFeaturedTagsUri(identifier).href) {
                        logger.warn("You configured a featured tags collection dispatcher, but the " +
                            "actor's featuredTags property does not match the featured tags " +
                            "collection URI.  Set the property with " +
                            "Context.getFeaturedTagsUri(identifier).");
                    }
                }
                if (this.router.has("inbox")) {
                    if (actor.inboxId == null) {
                        logger.warn("You configured inbox listeners, but the actor does not " +
                            "have an inbox property.  Set the property with " +
                            "Context.getInboxUri(identifier).");
                    }
                    else if (actor.inboxId.href != context.getInboxUri(identifier).href) {
                        logger.warn("You configured inbox listeners, but the actor's inbox " +
                            "property does not match the inbox URI.  Set the property " +
                            "with Context.getInboxUri(identifier).");
                    }
                    if (actor.endpoints == null || actor.endpoints.sharedInbox == null) {
                        logger.warn("You configured inbox listeners, but the actor does not have " +
                            "a endpoints.sharedInbox property.  Set the property with " +
                            "Context.getInboxUri().");
                    }
                    else if (actor.endpoints.sharedInbox.href != context.getInboxUri().href) {
                        logger.warn("You configured inbox listeners, but the actor's " +
                            "endpoints.sharedInbox property does not match the shared inbox " +
                            "URI.  Set the property with Context.getInboxUri().");
                    }
                }
                if (callbacks.keyPairsDispatcher != null) {
                    if (actor.publicKeyId == null) {
                        logger.warn("You configured a key pairs dispatcher, but the actor does " +
                            "not have a publicKey property.  Set the property with " +
                            "Context.getActorKeyPairs(identifier).");
                    }
                    if (actor.assertionMethodId == null) {
                        logger.warn("You configured a key pairs dispatcher, but the actor does " +
                            "not have an assertionMethod property.  Set the property " +
                            "with Context.getActorKeyPairs(identifier).");
                    }
                }
                return actor;
            },
        };
        this.actorCallbacks = callbacks;
        const setters = {
            setKeyPairsDispatcher: (dispatcher) => {
                callbacks.keyPairsDispatcher = (ctx, identifier) => this.#getTracer().startActiveSpan("activitypub.dispatch_actor_key_pairs", {
                    kind: SpanKind.SERVER,
                    attributes: {
                        "activitypub.actor.id": ctx.getActorUri(identifier).href,
                        "fedify.actor.identifier": identifier,
                    },
                }, async (span) => {
                    try {
                        return await dispatcher(ctx, identifier);
                    }
                    catch (e) {
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: String(e),
                        });
                        throw e;
                    }
                    finally {
                        span.end();
                    }
                });
                return setters;
            },
            mapHandle(mapper) {
                callbacks.handleMapper = mapper;
                return setters;
            },
            mapAlias(mapper) {
                callbacks.aliasMapper = mapper;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setObjectDispatcher(
    // deno-lint-ignore no-explicit-any
    cls, path, dispatcher) {
        const routeName = `object:${cls.typeId.href}`;
        if (this.router.has(routeName)) {
            throw new RouterError(`Object dispatcher for ${cls.name} already set.`);
        }
        const variables = this.router.add(path, routeName);
        if (variables.size < 1) {
            throw new RouterError("Path for object dispatcher must have at least one variable.");
        }
        const callbacks = {
            dispatcher: (ctx, values) => {
                const tracer = this.#getTracer();
                return tracer.startActiveSpan("activitypub.dispatch_object", {
                    kind: SpanKind.SERVER,
                    attributes: {
                        "fedify.object.type": cls.typeId.href,
                        ...globalThis.Object.fromEntries(globalThis.Object.entries(values).map(([k, v]) => [
                            `fedify.object.values.${k}`,
                            v,
                        ])),
                    },
                }, async (span) => {
                    try {
                        const object = await dispatcher(ctx, values);
                        span.setAttribute("activitypub.object.id", (object?.id ?? ctx.getObjectUri(cls, values)).href);
                        if (object == null) {
                            span.setStatus({ code: SpanStatusCode.ERROR });
                        }
                        else {
                            span.setAttribute("activitypub.object.type", getTypeId(object).href);
                        }
                        return object;
                    }
                    catch (e) {
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: String(e),
                        });
                        throw e;
                    }
                    finally {
                        span.end();
                    }
                });
            },
            parameters: variables,
        };
        this.objectCallbacks[cls.typeId.href] = callbacks;
        this.objectTypeIds[cls.typeId.href] = cls;
        const setters = {
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setInboxDispatcher(path, dispatcher) {
        if (this.inboxCallbacks != null) {
            throw new RouterError("Inbox dispatcher already set.");
        }
        if (this.router.has("inbox")) {
            if (this.inboxPath !== path) {
                throw new RouterError("Inbox dispatcher path must match inbox listener path.");
            }
        }
        else {
            const variables = this.router.add(path, "inbox");
            if (variables.size !== 1 ||
                !(variables.has("identifier") || variables.has("handle"))) {
                throw new RouterError("Path for inbox dispatcher must have one variable: {identifier}");
            }
            if (variables.has("handle")) {
                getLogger(["fedify", "federation", "inbox"]).warn("The {{handle}} variable in the inbox dispatcher path is deprecated. " +
                    "Use {{identifier}} instead.");
            }
            this.inboxPath = path;
        }
        const callbacks = { dispatcher };
        this.inboxCallbacks = callbacks;
        const setters = {
            setCounter(counter) {
                callbacks.counter = counter;
                return setters;
            },
            setFirstCursor(cursor) {
                callbacks.firstCursor = cursor;
                return setters;
            },
            setLastCursor(cursor) {
                callbacks.lastCursor = cursor;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setOutboxDispatcher(path, dispatcher) {
        if (this.router.has("outbox")) {
            throw new RouterError("Outbox dispatcher already set.");
        }
        const variables = this.router.add(path, "outbox");
        if (variables.size !== 1 ||
            !(variables.has("identifier") || variables.has("handle"))) {
            throw new RouterError("Path for outbox dispatcher must have one variable: {identifier}");
        }
        if (variables.has("handle")) {
            getLogger(["fedify", "federation", "outbox"]).warn("The {{handle}} variable in the outbox dispatcher path is deprecated. " +
                "Use {{identifier}} instead.");
        }
        const callbacks = { dispatcher };
        this.outboxCallbacks = callbacks;
        const setters = {
            setCounter(counter) {
                callbacks.counter = counter;
                return setters;
            },
            setFirstCursor(cursor) {
                callbacks.firstCursor = cursor;
                return setters;
            },
            setLastCursor(cursor) {
                callbacks.lastCursor = cursor;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setFollowingDispatcher(path, dispatcher) {
        if (this.router.has("following")) {
            throw new RouterError("Following collection dispatcher already set.");
        }
        const variables = this.router.add(path, "following");
        if (variables.size !== 1 ||
            !(variables.has("identifier") || variables.has("handle"))) {
            throw new RouterError("Path for following collection dispatcher must have one variable: " +
                "{identifier}");
        }
        if (variables.has("handle")) {
            getLogger(["fedify", "federation", "collection"]).warn("The {{handle}} variable in the following collection dispatcher path " +
                "is deprecated. Use {{identifier}} instead.");
        }
        const callbacks = { dispatcher };
        this.followingCallbacks = callbacks;
        const setters = {
            setCounter(counter) {
                callbacks.counter = counter;
                return setters;
            },
            setFirstCursor(cursor) {
                callbacks.firstCursor = cursor;
                return setters;
            },
            setLastCursor(cursor) {
                callbacks.lastCursor = cursor;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setFollowersDispatcher(path, dispatcher) {
        if (this.router.has("followers")) {
            throw new RouterError("Followers collection dispatcher already set.");
        }
        const variables = this.router.add(path, "followers");
        if (variables.size !== 1 ||
            !(variables.has("identifier") || variables.has("handle"))) {
            throw new RouterError("Path for followers collection dispatcher must have one variable: " +
                "{identifier}");
        }
        if (variables.has("handle")) {
            getLogger(["fedify", "federation", "collection"]).warn("The {{handle}} variable in the followers collection dispatcher path " +
                "is deprecated. Use {{identifier}} instead.");
        }
        const callbacks = { dispatcher };
        this.followersCallbacks = callbacks;
        const setters = {
            setCounter(counter) {
                callbacks.counter = counter;
                return setters;
            },
            setFirstCursor(cursor) {
                callbacks.firstCursor = cursor;
                return setters;
            },
            setLastCursor(cursor) {
                callbacks.lastCursor = cursor;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setLikedDispatcher(path, dispatcher) {
        if (this.router.has("liked")) {
            throw new RouterError("Liked collection dispatcher already set.");
        }
        const variables = this.router.add(path, "liked");
        if (variables.size !== 1 ||
            !(variables.has("identifier") || variables.has("handle"))) {
            throw new RouterError("Path for liked collection dispatcher must have one variable: " +
                "{identifier}");
        }
        if (variables.has("handle")) {
            getLogger(["fedify", "federation", "collection"]).warn("The {{handle}} variable in the liked collection dispatcher path " +
                "is deprecated. Use {{identifier}} instead.");
        }
        const callbacks = { dispatcher };
        this.likedCallbacks = callbacks;
        const setters = {
            setCounter(counter) {
                callbacks.counter = counter;
                return setters;
            },
            setFirstCursor(cursor) {
                callbacks.firstCursor = cursor;
                return setters;
            },
            setLastCursor(cursor) {
                callbacks.lastCursor = cursor;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setFeaturedDispatcher(path, dispatcher) {
        if (this.router.has("featured")) {
            throw new RouterError("Featured collection dispatcher already set.");
        }
        const variables = this.router.add(path, "featured");
        if (variables.size !== 1 ||
            !(variables.has("identifier") || variables.has("handle"))) {
            throw new RouterError("Path for featured collection dispatcher must have one variable: " +
                "{identifier}");
        }
        if (variables.has("handle")) {
            getLogger(["fedify", "federation", "collection"]).warn("The {{handle}} variable in the featured collection dispatcher path " +
                "is deprecated. Use {{identifier}} instead.");
        }
        const callbacks = { dispatcher };
        this.featuredCallbacks = callbacks;
        const setters = {
            setCounter(counter) {
                callbacks.counter = counter;
                return setters;
            },
            setFirstCursor(cursor) {
                callbacks.firstCursor = cursor;
                return setters;
            },
            setLastCursor(cursor) {
                callbacks.lastCursor = cursor;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setFeaturedTagsDispatcher(path, dispatcher) {
        if (this.router.has("featuredTags")) {
            throw new RouterError("Featured tags collection dispatcher already set.");
        }
        const variables = this.router.add(path, "featuredTags");
        if (variables.size !== 1 ||
            !(variables.has("identifier") || variables.has("handle"))) {
            throw new RouterError("Path for featured tags collection dispatcher must have one " +
                "variable: {identifier}");
        }
        if (variables.has("handle")) {
            getLogger(["fedify", "federation", "collection"]).warn("The {{handle}} variable in the featured tags collection dispatcher " +
                "path is deprecated. Use {{identifier}} instead.");
        }
        const callbacks = { dispatcher };
        this.featuredTagsCallbacks = callbacks;
        const setters = {
            setCounter(counter) {
                callbacks.counter = counter;
                return setters;
            },
            setFirstCursor(cursor) {
                callbacks.firstCursor = cursor;
                return setters;
            },
            setLastCursor(cursor) {
                callbacks.lastCursor = cursor;
                return setters;
            },
            authorize(predicate) {
                callbacks.authorizePredicate = predicate;
                return setters;
            },
        };
        return setters;
    }
    setInboxListeners(inboxPath, sharedInboxPath) {
        if (this.inboxListeners != null) {
            throw new RouterError("Inbox listeners already set.");
        }
        if (this.router.has("inbox")) {
            if (this.inboxPath !== inboxPath) {
                throw new RouterError("Inbox listener path must match inbox dispatcher path.");
            }
        }
        else {
            const variables = this.router.add(inboxPath, "inbox");
            if (variables.size !== 1 ||
                !(variables.has("identifier") || variables.has("handle"))) {
                throw new RouterError("Path for inbox must have one variable: {identifier}");
            }
            this.inboxPath = inboxPath;
            if (variables.has("handle")) {
                getLogger(["fedify", "federation", "inbox"]).warn("The {{handle}} variable in the inbox path is deprecated. " +
                    "Use {{identifier}} instead.");
            }
        }
        if (sharedInboxPath != null) {
            const siVars = this.router.add(sharedInboxPath, "sharedInbox");
            if (siVars.size !== 0) {
                throw new RouterError("Path for shared inbox must have no variables.");
            }
        }
        const listeners = this.inboxListeners = new InboxListenerSet();
        const setters = {
            on(
            // deno-lint-ignore no-explicit-any
            type, listener) {
                listeners.add(type, listener);
                return setters;
            },
            onError: (handler) => {
                this.inboxErrorHandler = handler;
                return setters;
            },
            setSharedKeyDispatcher: (dispatcher) => {
                this.sharedInboxKeyDispatcher = dispatcher;
                return setters;
            },
        };
        return setters;
    }
    async sendActivity(keys, inboxes, activity, options) {
        const logger = getLogger(["fedify", "federation", "outbox"]);
        const { immediate, collectionSync, context: ctx } = options;
        if (activity.id == null) {
            throw new TypeError("The activity to send must have an id.");
        }
        if (activity.actorId == null) {
            throw new TypeError("The activity to send must have at least one actor property.");
        }
        else if (keys.length < 1) {
            throw new TypeError("The keys must not be empty.");
        }
        const contextLoader = this.contextLoaderFactory(this.#getLoaderOptions(ctx.origin));
        const activityId = activity.id.href;
        let proofCreated = false;
        let rsaKey = null;
        for (const { keyId, privateKey } of keys) {
            validateCryptoKey(privateKey, "private");
            if (rsaKey == null && privateKey.algorithm.name === "RSASSA-PKCS1-v1_5") {
                rsaKey = { keyId, privateKey };
                continue;
            }
            if (privateKey.algorithm.name === "Ed25519") {
                activity = await signObject(activity, privateKey, keyId, {
                    contextLoader,
                    tracerProvider: this.tracerProvider,
                });
                proofCreated = true;
            }
        }
        let jsonLd = await activity.toJsonLd({
            format: "compact",
            contextLoader,
        });
        if (rsaKey == null) {
            logger.warn("No supported key found to create a Linked Data signature for " +
                "the activity {activityId}.  The activity will be sent without " +
                "a Linked Data signature.  In order to create a Linked Data " +
                "signature, at least one RSASSA-PKCS1-v1_5 key must be provided.", {
                activityId,
                keys: keys.map((pair) => ({
                    keyId: pair.keyId.href,
                    privateKey: pair.privateKey,
                })),
            });
        }
        else {
            jsonLd = await signJsonLd(jsonLd, rsaKey.privateKey, rsaKey.keyId, {
                contextLoader,
                tracerProvider: this.tracerProvider,
            });
        }
        if (!proofCreated) {
            logger.warn("No supported key found to create a proof for the activity {activityId}.  " +
                "The activity will be sent without a proof.  " +
                "In order to create a proof, at least one Ed25519 key must be provided.", {
                activityId,
                keys: keys.map((pair) => ({
                    keyId: pair.keyId.href,
                    privateKey: pair.privateKey,
                })),
            });
        }
        if (immediate || this.outboxQueue == null) {
            if (immediate) {
                logger.debug("Sending activity immediately without queue since immediate option " +
                    "is set.", { activityId: activity.id.href, activity: jsonLd });
            }
            else {
                logger.debug("Sending activity immediately without queue since queue is not set.", { activityId: activity.id.href, activity: jsonLd });
            }
            const promises = [];
            for (const inbox in inboxes) {
                promises.push(sendActivity({
                    keys,
                    activity: jsonLd,
                    activityId: activity.id?.href,
                    activityType: getTypeId(activity).href,
                    inbox: new URL(inbox),
                    sharedInbox: inboxes[inbox].sharedInbox,
                    headers: collectionSync == null ? undefined : new Headers({
                        "Collection-Synchronization": await buildCollectionSynchronizationHeader(collectionSync, inboxes[inbox].actorIds),
                    }),
                    tracerProvider: this.tracerProvider,
                }));
            }
            await Promise.all(promises);
            return;
        }
        logger.debug("Enqueuing activity {activityId} to send later.", { activityId: activity.id.href, activity: jsonLd });
        const keyJwkPairs = [];
        for (const { keyId, privateKey } of keys) {
            const privateKeyJwk = await exportJwk(privateKey);
            keyJwkPairs.push({ keyId: keyId.href, privateKey: privateKeyJwk });
        }
        if (!this.manuallyStartQueue)
            this._startQueueInternal(ctx.data);
        const carrier = {};
        propagation.inject(context.active(), carrier);
        const messages = [];
        for (const inbox in inboxes) {
            const message = {
                type: "outbox",
                id: dntShim.crypto.randomUUID(),
                baseUrl: ctx.origin,
                keys: keyJwkPairs,
                activity: jsonLd,
                activityId: activity.id?.href,
                activityType: getTypeId(activity).href,
                inbox,
                sharedInbox: inboxes[inbox].sharedInbox,
                started: new Date().toISOString(),
                attempt: 0,
                headers: collectionSync == null ? {} : {
                    "Collection-Synchronization": await buildCollectionSynchronizationHeader(collectionSync, inboxes[inbox].actorIds),
                },
                traceContext: carrier,
            };
            messages.push(message);
        }
        const { outboxQueue } = this;
        if (outboxQueue.enqueueMany == null) {
            const promises = messages.map((m) => outboxQueue.enqueue(m));
            const results = await Promise.allSettled(promises);
            const errors = results
                .filter((r) => r.status === "rejected")
                .map((r) => r.reason);
            if (errors.length > 0) {
                logger.error("Failed to enqueue activity {activityId} to send later: {errors}", { activityId: activity.id.href, errors });
                if (errors.length > 1) {
                    throw new AggregateError(errors, `Failed to enqueue activity ${activityId} to send later.`);
                }
                throw errors[0];
            }
        }
        else {
            try {
                await outboxQueue.enqueueMany(messages);
            }
            catch (error) {
                logger.error("Failed to enqueue activity {activityId} to send later: {error}", { activityId: activity.id.href, error });
                throw error;
            }
        }
    }
    fetch(request, options) {
        const requestId = getRequestId(request);
        return withContext({ requestId }, async () => {
            const tracer = this.#getTracer();
            return await tracer.startActiveSpan(request.method, {
                kind: SpanKind.SERVER,
                attributes: {
                    [ATTR_HTTP_REQUEST_METHOD]: request.method,
                    [ATTR_URL_FULL]: request.url,
                },
            }, async (span) => {
                const logger = getLogger(["fedify", "federation", "http"]);
                if (span.isRecording()) {
                    for (const [k, v] of request.headers) {
                        span.setAttribute(ATTR_HTTP_REQUEST_HEADER(k), [v]);
                    }
                }
                let response;
                try {
                    response = await this.#fetch(request, { ...options, span, tracer });
                }
                catch (error) {
                    span.setStatus({
                        code: SpanStatusCode.ERROR,
                        message: `${error}`,
                    });
                    span.end();
                    logger.error("An error occurred while serving request {method} {url}: {error}", { method: request.method, url: request.url, error });
                    throw error;
                }
                if (span.isRecording()) {
                    span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);
                    for (const [k, v] of response.headers) {
                        span.setAttribute(ATTR_HTTP_RESPONSE_HEADER(k), [v]);
                    }
                    span.setStatus({
                        code: response.status >= 500
                            ? SpanStatusCode.ERROR
                            : SpanStatusCode.UNSET,
                        message: response.statusText,
                    });
                }
                span.end();
                const url = new URL(request.url);
                const logTpl = "{method} {path}: {status}";
                const values = {
                    method: request.method,
                    path: `${url.pathname}${url.search}`,
                    url: request.url,
                    status: response.status,
                };
                if (response.status >= 500)
                    logger.error(logTpl, values);
                else if (response.status >= 400)
                    logger.warn(logTpl, values);
                else
                    logger.info(logTpl, values);
                return response;
            });
        });
    }
    async #fetch(request, { onNotFound, onNotAcceptable, onUnauthorized, contextData, span, tracer, }) {
        onNotFound ??= notFound;
        onNotAcceptable ??= notAcceptable;
        onUnauthorized ??= unauthorized;
        const url = new URL(request.url);
        const route = this.router.route(url.pathname);
        if (route == null)
            return await onNotFound(request);
        span.updateName(`${request.method} ${route.template}`);
        let context = this.#createContext(request, contextData);
        const routeName = route.name.replace(/:.*$/, "");
        switch (routeName) {
            case "webfinger":
                return await handleWebFinger(request, {
                    context,
                    host: this.origin?.handleHost,
                    actorDispatcher: this.actorCallbacks?.dispatcher,
                    actorHandleMapper: this.actorCallbacks?.handleMapper,
                    actorAliasMapper: this.actorCallbacks?.aliasMapper,
                    onNotFound,
                    tracer,
                });
            case "nodeInfoJrd":
                return await handleNodeInfoJrd(request, context);
            case "nodeInfo":
                return await handleNodeInfo(request, {
                    context,
                    nodeInfoDispatcher: this.nodeInfoDispatcher,
                });
            case "actor":
                context = this.#createContext(request, contextData, {
                    invokedFromActorDispatcher: {
                        identifier: route.values.identifier ?? route.values.handle,
                    },
                });
                return await handleActor(request, {
                    identifier: route.values.identifier ?? route.values.handle,
                    context,
                    actorDispatcher: this.actorCallbacks?.dispatcher,
                    authorizePredicate: this.actorCallbacks?.authorizePredicate,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            case "object": {
                const typeId = route.name.replace(/^object:/, "");
                const callbacks = this.objectCallbacks[typeId];
                const cls = this.objectTypeIds[typeId];
                context = this.#createContext(request, contextData, {
                    invokedFromObjectDispatcher: { cls, values: route.values },
                });
                return await handleObject(request, {
                    values: route.values,
                    context,
                    objectDispatcher: callbacks?.dispatcher,
                    authorizePredicate: callbacks?.authorizePredicate,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            }
            case "outbox":
                return await handleCollection(request, {
                    name: "outbox",
                    identifier: route.values.identifier ?? route.values.handle,
                    uriGetter: context.getOutboxUri.bind(context),
                    context,
                    collectionCallbacks: this.outboxCallbacks,
                    tracerProvider: this.tracerProvider,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            case "inbox":
                if (request.method !== "POST") {
                    return await handleCollection(request, {
                        name: "inbox",
                        identifier: route.values.identifier ?? route.values.handle,
                        uriGetter: context.getInboxUri.bind(context),
                        context,
                        collectionCallbacks: this.inboxCallbacks,
                        tracerProvider: this.tracerProvider,
                        onUnauthorized,
                        onNotFound,
                        onNotAcceptable,
                    });
                }
                context = this.#createContext(request, contextData, {
                    documentLoader: await context.getDocumentLoader({
                        identifier: route.values.identifier ?? route.values.handle,
                    }),
                });
            // falls through
            case "sharedInbox":
                if (routeName !== "inbox" && this.sharedInboxKeyDispatcher != null) {
                    const identity = await this.sharedInboxKeyDispatcher(context);
                    if (identity != null) {
                        context = this.#createContext(request, contextData, {
                            documentLoader: "identifier" in identity || "username" in identity ||
                                "handle" in identity
                                ? await context.getDocumentLoader(identity)
                                : context.getDocumentLoader(identity),
                        });
                    }
                }
                if (!this.manuallyStartQueue)
                    this._startQueueInternal(contextData);
                return await handleInbox(request, {
                    recipient: route.values.identifier ?? route.values.handle ?? null,
                    context,
                    inboxContextFactory: context.toInboxContext.bind(context),
                    kv: this.kv,
                    kvPrefixes: this.kvPrefixes,
                    queue: this.inboxQueue,
                    actorDispatcher: this.actorCallbacks?.dispatcher,
                    inboxListeners: this.inboxListeners,
                    inboxErrorHandler: this.inboxErrorHandler,
                    onNotFound,
                    signatureTimeWindow: this.signatureTimeWindow,
                    skipSignatureVerification: this.skipSignatureVerification,
                    tracerProvider: this.tracerProvider,
                });
            case "following":
                return await handleCollection(request, {
                    name: "following",
                    identifier: route.values.identifier ?? route.values.handle,
                    uriGetter: context.getFollowingUri.bind(context),
                    context,
                    collectionCallbacks: this.followingCallbacks,
                    tracerProvider: this.tracerProvider,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            case "followers": {
                let baseUrl = url.searchParams.get("base-url");
                if (baseUrl != null) {
                    try {
                        baseUrl = `${new URL(baseUrl).origin}/`;
                    }
                    catch {
                        // If base-url is invalid, set to null to behave as if it wasn't provided
                        baseUrl = null;
                    }
                }
                return await handleCollection(request, {
                    name: "followers",
                    identifier: route.values.identifier ?? route.values.handle,
                    uriGetter: baseUrl == null
                        ? context.getFollowersUri.bind(context)
                        : (identifier) => {
                            const uri = context.getFollowersUri(identifier);
                            uri.searchParams.set("base-url", baseUrl);
                            return uri;
                        },
                    context,
                    filter: baseUrl != null ? new URL(baseUrl) : undefined,
                    filterPredicate: baseUrl != null
                        ? ((i) => (i instanceof URL ? i.href : i.id?.href ?? "").startsWith(baseUrl))
                        : undefined,
                    collectionCallbacks: this.followersCallbacks,
                    tracerProvider: this.tracerProvider,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            }
            case "liked":
                return await handleCollection(request, {
                    name: "liked",
                    identifier: route.values.identifier ?? route.values.handle,
                    uriGetter: context.getLikedUri.bind(context),
                    context,
                    collectionCallbacks: this.likedCallbacks,
                    tracerProvider: this.tracerProvider,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            case "featured":
                return await handleCollection(request, {
                    name: "featured",
                    identifier: route.values.identifier ?? route.values.handle,
                    uriGetter: context.getFeaturedUri.bind(context),
                    context,
                    collectionCallbacks: this.featuredCallbacks,
                    tracerProvider: this.tracerProvider,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            case "featuredTags":
                return await handleCollection(request, {
                    name: "featured tags",
                    identifier: route.values.identifier ?? route.values.handle,
                    uriGetter: context.getFeaturedTagsUri.bind(context),
                    context,
                    collectionCallbacks: this.featuredTagsCallbacks,
                    tracerProvider: this.tracerProvider,
                    onUnauthorized,
                    onNotFound,
                    onNotAcceptable,
                });
            default: {
                const response = onNotFound(request);
                return response instanceof Promise ? await response : response;
            }
        }
    }
}
const FANOUT_THRESHOLD = 5;
export class ContextImpl {
    url;
    federation;
    data;
    documentLoader;
    contextLoader;
    invokedFromActorKeyPairsDispatcher;
    constructor({ url, federation, data, documentLoader, contextLoader, invokedFromActorKeyPairsDispatcher, }) {
        this.url = url;
        this.federation = federation;
        this.data = data;
        this.documentLoader = documentLoader;
        this.contextLoader = contextLoader;
        this.invokedFromActorKeyPairsDispatcher =
            invokedFromActorKeyPairsDispatcher;
    }
    toInboxContext(recipient, activity, activityId, activityType) {
        return new InboxContextImpl(recipient, activity, activityId, activityType, {
            url: this.url,
            federation: this.federation,
            data: this.data,
            documentLoader: this.documentLoader,
            contextLoader: this.contextLoader,
            invokedFromActorKeyPairsDispatcher: this.invokedFromActorKeyPairsDispatcher,
        });
    }
    get hostname() {
        return this.url.hostname;
    }
    get host() {
        return this.url.host;
    }
    get origin() {
        return this.url.origin;
    }
    get canonicalOrigin() {
        return this.federation.origin?.webOrigin ?? this.origin;
    }
    get tracerProvider() {
        return this.federation.tracerProvider;
    }
    getNodeInfoUri() {
        const path = this.federation.router.build("nodeInfo", {});
        if (path == null) {
            throw new RouterError("No NodeInfo dispatcher registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getActorUri(identifier) {
        const path = this.federation.router.build("actor", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No actor dispatcher registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getObjectUri(
    // deno-lint-ignore no-explicit-any
    cls, values) {
        const callbacks = this.federation.objectCallbacks[cls.typeId.href];
        if (callbacks == null) {
            throw new RouterError("No object dispatcher registered.");
        }
        for (const param of callbacks.parameters) {
            if (!(param in values)) {
                throw new TypeError(`Missing parameter: ${param}`);
            }
        }
        const path = this.federation.router.build(`object:${cls.typeId.href}`, values);
        if (path == null) {
            throw new RouterError("No object dispatcher registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getOutboxUri(identifier) {
        const path = this.federation.router.build("outbox", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No outbox dispatcher registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getInboxUri(identifier) {
        if (identifier == null) {
            const path = this.federation.router.build("sharedInbox", {});
            if (path == null) {
                throw new RouterError("No shared inbox path registered.");
            }
            return new URL(path, this.canonicalOrigin);
        }
        const path = this.federation.router.build("inbox", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No inbox path registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getFollowingUri(identifier) {
        const path = this.federation.router.build("following", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No following collection path registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getFollowersUri(identifier) {
        const path = this.federation.router.build("followers", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No followers collection path registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getLikedUri(identifier) {
        const path = this.federation.router.build("liked", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No liked collection path registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getFeaturedUri(identifier) {
        const path = this.federation.router.build("featured", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No featured collection path registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    getFeaturedTagsUri(identifier) {
        const path = this.federation.router.build("featuredTags", { identifier, handle: identifier });
        if (path == null) {
            throw new RouterError("No featured tags collection path registered.");
        }
        return new URL(path, this.canonicalOrigin);
    }
    parseUri(uri) {
        if (uri == null)
            return null;
        if (uri.origin !== this.origin && uri.origin !== this.canonicalOrigin) {
            return null;
        }
        const route = this.federation.router.route(uri.pathname);
        const logger = getLogger(["fedify", "federation"]);
        if (route == null)
            return null;
        else if (route.name === "sharedInbox") {
            return {
                type: "inbox",
                identifier: undefined,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return undefined;
                },
            };
        }
        const identifier = "identifier" in route.values
            ? route.values.identifier
            : route.values.handle;
        if (route.name === "actor") {
            return {
                type: "actor",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        else if (route.name.startsWith("object:")) {
            const typeId = route.name.replace(/^object:/, "");
            return {
                type: "object",
                class: this.federation.objectTypeIds[typeId],
                typeId: new URL(typeId),
                values: route.values,
            };
        }
        else if (route.name === "inbox") {
            return {
                type: "inbox",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        else if (route.name === "outbox") {
            return {
                type: "outbox",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        else if (route.name === "following") {
            return {
                type: "following",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        else if (route.name === "followers") {
            return {
                type: "followers",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        else if (route.name === "liked") {
            return {
                type: "liked",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        else if (route.name === "featured") {
            return {
                type: "featured",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        else if (route.name === "featuredTags") {
            return {
                type: "featuredTags",
                identifier,
                get handle() {
                    logger.warn("The ParseUriResult.handle property is deprecated; " +
                        "use ParseUriResult.identifier instead.");
                    return identifier;
                },
            };
        }
        return null;
    }
    async getActorKeyPairs(identifier) {
        const logger = getLogger(["fedify", "federation", "actor"]);
        if (this.invokedFromActorKeyPairsDispatcher != null) {
            logger.warn("Context.getActorKeyPairs({getActorKeyPairsIdentifier}) method is " +
                "invoked from the actor key pairs dispatcher " +
                "({actorKeyPairsDispatcherIdentifier}); this may cause " +
                "an infinite loop.", {
                getActorKeyPairsIdentifier: identifier,
                actorKeyPairsDispatcherIdentifier: this.invokedFromActorKeyPairsDispatcher.identifier,
            });
        }
        let keyPairs;
        try {
            keyPairs = await this.getKeyPairsFromIdentifier(identifier);
        }
        catch (_) {
            logger.warn("No actor key pairs dispatcher registered.");
            return [];
        }
        const owner = this.getActorUri(identifier);
        const result = [];
        for (const keyPair of keyPairs) {
            const newPair = {
                ...keyPair,
                cryptographicKey: new CryptographicKey({
                    id: keyPair.keyId,
                    owner,
                    publicKey: keyPair.publicKey,
                }),
                multikey: new Multikey({
                    id: keyPair.keyId,
                    controller: owner,
                    publicKey: keyPair.publicKey,
                }),
            };
            result.push(newPair);
        }
        return result;
    }
    async getKeyPairsFromIdentifier(identifier) {
        const logger = getLogger(["fedify", "federation", "actor"]);
        if (this.federation.actorCallbacks?.keyPairsDispatcher == null) {
            throw new Error("No actor key pairs dispatcher registered.");
        }
        const path = this.federation.router.build("actor", { identifier, handle: identifier });
        if (path == null) {
            logger.warn("No actor dispatcher registered.");
            return [];
        }
        const actorUri = new URL(path, this.canonicalOrigin);
        const keyPairs = await this.federation.actorCallbacks?.keyPairsDispatcher(new ContextImpl({
            ...this,
            invokedFromActorKeyPairsDispatcher: { identifier },
        }), identifier);
        if (keyPairs.length < 1) {
            logger.warn("No key pairs found for actor {identifier}.", { identifier });
        }
        let i = 0;
        const result = [];
        for (const keyPair of keyPairs) {
            result.push({
                ...keyPair,
                keyId: new URL(
                // For backwards compatibility, the first key is always the #main-key:
                i == 0 ? `#main-key` : `#key-${i + 1}`, actorUri),
            });
            i++;
        }
        return result;
    }
    async getRsaKeyPairFromIdentifier(identifier) {
        const keyPairs = await this.getKeyPairsFromIdentifier(identifier);
        for (const keyPair of keyPairs) {
            const { privateKey } = keyPair;
            if (privateKey.algorithm.name === "RSASSA-PKCS1-v1_5" &&
                privateKey.algorithm.hash
                    .name ===
                    "SHA-256") {
                return keyPair;
            }
        }
        getLogger(["fedify", "federation", "actor"]).warn("No RSA-PKCS#1-v1.5 SHA-256 key found for actor {identifier}.", { identifier });
        return null;
    }
    getDocumentLoader(identity) {
        if ("identifier" in identity || "username" in identity || "handle" in identity) {
            let identifierPromise;
            if ("username" in identity || "handle" in identity) {
                let username;
                if ("username" in identity) {
                    username = identity.username;
                }
                else {
                    username = identity.handle;
                    getLogger(["fedify", "runtime", "docloader"]).warn('The "handle" property is deprecated; use "identifier" or ' +
                        '"username" instead.', { identity });
                }
                const mapper = this.federation.actorCallbacks?.handleMapper;
                if (mapper == null) {
                    identifierPromise = Promise.resolve(username);
                }
                else {
                    const identifier = mapper(this, username);
                    identifierPromise = identifier instanceof Promise
                        ? identifier
                        : Promise.resolve(identifier);
                }
            }
            else {
                identifierPromise = Promise.resolve(identity.identifier);
            }
            return identifierPromise.then((identifier) => {
                if (identifier == null)
                    return this.documentLoader;
                const keyPair = this.getRsaKeyPairFromIdentifier(identifier);
                return keyPair.then((pair) => pair == null
                    ? this.documentLoader
                    : this.federation.authenticatedDocumentLoaderFactory(pair));
            });
        }
        return this.federation.authenticatedDocumentLoaderFactory(identity);
    }
    lookupObject(identifier, options = {}) {
        return lookupObject(identifier, {
            ...options,
            documentLoader: options.documentLoader ?? this.documentLoader,
            contextLoader: options.contextLoader ?? this.contextLoader,
            userAgent: options.userAgent ?? this.federation.userAgent,
            tracerProvider: options.tracerProvider ?? this.tracerProvider,
            // @ts-ignore: `allowPrivateAddress` is not in the type definition.
            allowPrivateAddress: this.federation.allowPrivateAddress,
        });
    }
    traverseCollection(collection, options = {}) {
        return traverseCollection(collection, {
            ...options,
            documentLoader: options.documentLoader ?? this.documentLoader,
            contextLoader: options.contextLoader ?? this.contextLoader,
        });
    }
    lookupNodeInfo(url, options = {}) {
        return options.parse === "none"
            ? getNodeInfo(url, {
                parse: "none",
                direct: options.direct,
                userAgent: options?.userAgent ?? this.federation.userAgent,
            })
            : getNodeInfo(url, {
                parse: options.parse,
                direct: options.direct,
                userAgent: options?.userAgent ?? this.federation.userAgent,
            });
    }
    sendActivity(sender, recipients, activity, options = {}) {
        const tracer = this.tracerProvider.getTracer(metadata.name, metadata.version);
        return tracer.startActiveSpan(this.federation.outboxQueue == null || options.immediate
            ? "activitypub.outbox"
            : "activitypub.fanout", {
            kind: this.federation.outboxQueue == null || options.immediate
                ? SpanKind.CLIENT
                : SpanKind.PRODUCER,
            attributes: {
                "activitypub.activity.type": getTypeId(activity).href,
                "activitypub.activity.to": activity.toIds.map((to) => to.href),
                "activitypub.activity.cc": activity.toIds.map((cc) => cc.href),
                "activitypub.activity.bto": activity.btoIds.map((bto) => bto.href),
                "activitypub.activity.bcc": activity.toIds.map((bcc) => bcc.href),
            },
        }, async (span) => {
            try {
                if (activity.id != null) {
                    span.setAttribute("activitypub.activity.id", activity.id.href);
                }
                await this.sendActivityInternal(sender, recipients, activity, options, span);
            }
            catch (e) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: String(e) });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async sendActivityInternal(sender, recipients, activity, options, span) {
        const logger = getLogger(["fedify", "federation", "outbox"]);
        let keys;
        let identifier = null;
        if ("identifier" in sender || "username" in sender || "handle" in sender) {
            if ("identifier" in sender) {
                identifier = sender.identifier;
            }
            else {
                let username;
                if ("username" in sender) {
                    username = sender.username;
                }
                else {
                    username = sender.handle;
                    logger.warn('The "handle" property for the sender parameter is deprecated; ' +
                        'use "identifier" or "username" instead.', { sender });
                }
                if (this.federation.actorCallbacks?.handleMapper == null) {
                    identifier = username;
                }
                else {
                    const mapped = await this.federation.actorCallbacks.handleMapper(this, username);
                    if (mapped == null) {
                        throw new Error(`No actor found for the given username ${JSON.stringify(username)}.`);
                    }
                    identifier = mapped;
                }
            }
            span.setAttribute("fedify.actor.identifier", identifier);
            keys = await this.getKeyPairsFromIdentifier(identifier);
            if (keys.length < 1) {
                throw new Error(`No key pair found for actor ${JSON.stringify(identifier)}.`);
            }
        }
        else if (Array.isArray(sender)) {
            if (sender.length < 1) {
                throw new Error("The sender's key pairs are empty.");
            }
            keys = sender;
        }
        else {
            keys = [sender];
        }
        if (keys.length < 1) {
            throw new TypeError("The sender's keys must not be empty.");
        }
        for (const { privateKey } of keys) {
            validateCryptoKey(privateKey, "private");
        }
        const opts = { context: this };
        let expandedRecipients;
        if (Array.isArray(recipients)) {
            expandedRecipients = recipients;
        }
        else if (recipients === "followers") {
            if (identifier == null) {
                throw new Error('If recipients is "followers", ' +
                    "sender must be an actor identifier or username.");
            }
            expandedRecipients = [];
            for await (const recipient of this.getFollowers(identifier)) {
                expandedRecipients.push(recipient);
            }
            if (options.syncCollection) {
                const collectionId = this.federation.router.build("followers", { identifier, handle: identifier });
                opts.collectionSync = collectionId == null
                    ? undefined
                    : new URL(collectionId, this.canonicalOrigin).href;
            }
        }
        else {
            expandedRecipients = [recipients];
        }
        span.setAttribute("activitypub.inboxes", expandedRecipients.length);
        for (const activityTransformer of this.federation.activityTransformers) {
            activity = activityTransformer(activity, this);
        }
        span?.setAttribute("activitypub.activity.id", activity?.id?.href ?? "");
        if (activity.actorId == null) {
            logger.error("Activity {activityId} to send does not have an actor.", { activity, activityId: activity?.id?.href });
            throw new TypeError("The activity to send must have at least one actor property.");
        }
        const inboxes = extractInboxes({
            recipients: expandedRecipients,
            preferSharedInbox: options.preferSharedInbox,
            excludeBaseUris: options.excludeBaseUris,
        });
        logger.debug("Sending activity {activityId} to inboxes:\n{inboxes}", {
            inboxes: globalThis.Object.keys(inboxes),
            activityId: activity.id?.href,
            activity,
        });
        if (this.federation.fanoutQueue == null || options.immediate ||
            options.fanout === "skip" || (options.fanout ?? "auto") === "auto" &&
            globalThis.Object.keys(inboxes).length < FANOUT_THRESHOLD) {
            await this.federation.sendActivity(keys, inboxes, activity, opts);
            return;
        }
        const keyJwkPairs = await Promise.all(keys.map(async ({ keyId, privateKey }) => ({
            keyId: keyId.href,
            privateKey: await exportJwk(privateKey),
        })));
        const carrier = {};
        propagation.inject(context.active(), carrier);
        const message = {
            type: "fanout",
            id: dntShim.crypto.randomUUID(),
            baseUrl: this.origin,
            keys: keyJwkPairs,
            inboxes: globalThis.Object.fromEntries(globalThis.Object.entries(inboxes).map(([k, { actorIds, sharedInbox }]) => [k, { actorIds: [...actorIds], sharedInbox }])),
            activity: await activity.toJsonLd({
                format: "compact",
                contextLoader: this.contextLoader,
            }),
            activityId: activity.id?.href,
            activityType: getTypeId(activity).href,
            collectionSync: opts.collectionSync,
            traceContext: carrier,
        };
        if (!this.federation.manuallyStartQueue) {
            this.federation._startQueueInternal(this.data);
        }
        this.federation.fanoutQueue.enqueue(message);
    }
    async *getFollowers(identifier) {
        if (this.federation.followersCallbacks == null) {
            throw new Error("No followers collection dispatcher registered.");
        }
        const result = await this.federation.followersCallbacks.dispatcher(this, identifier, null);
        if (result != null) {
            for (const recipient of result.items)
                yield recipient;
            return;
        }
        if (this.federation.followersCallbacks.firstCursor == null) {
            throw new Error("No first cursor dispatcher registered for followers collection.");
        }
        let cursor = await this.federation.followersCallbacks.firstCursor(this, identifier);
        if (cursor != null) {
            getLogger(["fedify", "federation", "outbox"]).warn("Since the followers collection dispatcher returned null for no " +
                "cursor (i.e., one-shot dispatcher), the pagination is used to fetch " +
                '"followers".  However, it is recommended to implement the one-shot ' +
                "dispatcher for better performance.", { identifier });
        }
        while (cursor != null) {
            const result = await this.federation.followersCallbacks.dispatcher(this, identifier, cursor);
            if (result == null)
                break;
            for (const recipient of result.items)
                yield recipient;
            cursor = result.nextCursor ?? null;
        }
    }
    routeActivity(recipient, activity, options = {}) {
        const tracerProvider = this.tracerProvider ?? this.tracerProvider;
        const tracer = tracerProvider.getTracer(metadata.name, metadata.version);
        return tracer.startActiveSpan("activitypub.inbox", {
            kind: this.federation.inboxQueue == null || options.immediate
                ? SpanKind.INTERNAL
                : SpanKind.PRODUCER,
            attributes: {
                "activitypub.activity.type": getTypeId(activity).href,
            },
        }, async (span) => {
            if (activity.id != null) {
                span.setAttribute("activitypub.activity.id", activity.id.href);
            }
            if (activity.toIds.length > 0) {
                span.setAttribute("activitypub.activity.to", activity.toIds.map((to) => to.href));
            }
            if (activity.ccIds.length > 0) {
                span.setAttribute("activitypub.activity.cc", activity.ccIds.map((cc) => cc.href));
            }
            if (activity.btoIds.length > 0) {
                span.setAttribute("activitypub.activity.bto", activity.btoIds.map((bto) => bto.href));
            }
            if (activity.bccIds.length > 0) {
                span.setAttribute("activitypub.activity.bcc", activity.bccIds.map((bcc) => bcc.href));
            }
            try {
                const ok = await this.routeActivityInternal(recipient, activity, options, span);
                if (ok) {
                    span.setAttribute("activitypub.shared_inbox", recipient == null);
                    if (recipient != null) {
                        span.setAttribute("fedify.inbox.recipient", recipient);
                    }
                }
                else {
                    span.setStatus({ code: SpanStatusCode.ERROR });
                }
                return ok;
            }
            catch (e) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: String(e) });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async routeActivityInternal(recipient, activity, options = {}, span) {
        const logger = getLogger(["fedify", "federation", "inbox"]);
        const contextLoader = options.contextLoader ?? this.contextLoader;
        const json = await activity.toJsonLd({ contextLoader });
        const keyCache = new KvKeyCache(this.federation.kv, this.federation.kvPrefixes.publicKey, this);
        const verified = await verifyObject(Activity, json, {
            contextLoader,
            documentLoader: options.documentLoader ?? this.documentLoader,
            tracerProvider: options.tracerProvider ?? this.tracerProvider,
            keyCache,
        });
        if (verified == null) {
            logger.debug("Object Integrity Proofs are not verified.", { recipient, activity: json });
            if (activity.id == null) {
                logger.debug("Activity is missing an ID; unable to fetch.", { recipient, activity: json });
                return false;
            }
            const fetched = await this.lookupObject(activity.id, options);
            if (fetched == null) {
                logger.debug("Failed to fetch the remote activity object {activityId}.", { recipient, activity: json, activityId: activity.id.href });
                return false;
            }
            else if (!(fetched instanceof Activity)) {
                logger.debug("Fetched object is not an Activity.", { recipient, activity: await fetched.toJsonLd({ contextLoader }) });
                return false;
            }
            else if (fetched.id?.href !== activity.id.href) {
                logger.debug("Fetched activity object has a different ID; failed to verify.", { recipient, activity: await fetched.toJsonLd({ contextLoader }) });
                return false;
            }
            else if (fetched.actorIds.length < 1) {
                logger.debug("Fetched activity object is missing an actor; unable to verify.", { recipient, activity: await fetched.toJsonLd({ contextLoader }) });
                return false;
            }
            const activityId = fetched.id;
            if (!fetched.actorIds.every((actor) => actor.origin === activityId.origin)) {
                logger.debug("Fetched activity object has actors from different origins; " +
                    "unable to verify.", { recipient, activity: await fetched.toJsonLd({ contextLoader }) });
                return false;
            }
            logger.debug("Successfully fetched the remote activity object {activityId}; " +
                "ignore the original activity and use the fetched one, which is trustworthy.");
            activity = fetched;
        }
        else {
            logger.debug("Object Integrity Proofs are verified.", { recipient, activity: json });
        }
        const routeResult = await routeActivity({
            context: this,
            json,
            activity,
            recipient,
            inboxListeners: this.federation.inboxListeners,
            inboxContextFactory: this.toInboxContext.bind(this),
            inboxErrorHandler: this.federation.inboxErrorHandler,
            kv: this.federation.kv,
            kvPrefixes: this.federation.kvPrefixes,
            queue: this.federation.inboxQueue,
            span,
            tracerProvider: options.tracerProvider ?? this.tracerProvider,
        });
        return routeResult === "alreadyProcessed" || routeResult === "enqueued" ||
            routeResult === "unsupportedActivity" || routeResult === "success";
    }
}
class RequestContextImpl extends ContextImpl {
    #invokedFromActorDispatcher;
    #invokedFromObjectDispatcher;
    request;
    url;
    constructor(options) {
        super(options);
        this.#invokedFromActorDispatcher = options.invokedFromActorDispatcher;
        this.#invokedFromObjectDispatcher = options.invokedFromObjectDispatcher;
        this.request = options.request;
        this.url = options.url;
    }
    async getActor(identifier) {
        if (this.federation.actorCallbacks == null ||
            this.federation.actorCallbacks.dispatcher == null) {
            throw new Error("No actor dispatcher registered.");
        }
        if (this.#invokedFromActorDispatcher != null) {
            getLogger(["fedify", "federation", "actor"]).warn("RequestContext.getActor({getActorIdentifier}) is invoked from " +
                "the actor dispatcher ({actorDispatcherIdentifier}); " +
                "this may cause an infinite loop.", {
                getActorIdentifier: identifier,
                actorDispatcherIdentifier: this.#invokedFromActorDispatcher.identifier,
            });
        }
        return await this.federation.actorCallbacks.dispatcher(new RequestContextImpl({
            ...this,
            invokedFromActorDispatcher: { identifier },
        }), identifier);
    }
    async getObject(
    // deno-lint-ignore no-explicit-any
    cls, values) {
        const callbacks = this.federation.objectCallbacks[cls.typeId.href];
        if (callbacks == null) {
            throw new Error("No object dispatcher registered.");
        }
        for (const param of callbacks.parameters) {
            if (!(param in values)) {
                throw new TypeError(`Missing parameter: ${param}`);
            }
        }
        if (this.#invokedFromObjectDispatcher != null) {
            getLogger(["fedify", "federation"]).warn("RequestContext.getObject({getObjectClass}, " +
                "{getObjectValues}) is invoked from the object dispatcher " +
                "({actorDispatcherClass}, {actorDispatcherValues}); " +
                "this may cause an infinite loop.", {
                getObjectClass: cls.name,
                getObjectValues: values,
                actorDispatcherClass: this.#invokedFromObjectDispatcher.cls.name,
                actorDispatcherValues: this.#invokedFromObjectDispatcher.values,
            });
        }
        return await callbacks.dispatcher(new RequestContextImpl({
            ...this,
            invokedFromObjectDispatcher: { cls, values },
        }), values);
    }
    #signedKey = undefined;
    async getSignedKey(options = {}) {
        if (this.#signedKey != null)
            return this.#signedKey;
        return this.#signedKey = await verifyRequest(this.request, {
            ...this,
            contextLoader: options.contextLoader ?? this.contextLoader,
            documentLoader: options.documentLoader ?? this.documentLoader,
            timeWindow: this.federation.signatureTimeWindow,
            tracerProvider: options.tracerProvider ?? this.tracerProvider,
        });
    }
    #signedKeyOwner = undefined;
    async getSignedKeyOwner(options = {}) {
        if (this.#signedKeyOwner != null)
            return this.#signedKeyOwner;
        const key = await this.getSignedKey(options);
        if (key == null)
            return this.#signedKeyOwner = null;
        return this.#signedKeyOwner = await getKeyOwner(key, {
            contextLoader: options.contextLoader ?? this.contextLoader,
            documentLoader: options.documentLoader ?? this.documentLoader,
            tracerProvider: options.tracerProvider ?? this.tracerProvider,
        });
    }
}
export class InboxContextImpl extends ContextImpl {
    recipient;
    activity;
    activityId;
    activityType;
    constructor(recipient, activity, activityId, activityType, options) {
        super(options);
        this.recipient = recipient;
        this.activity = activity;
        this.activityId = activityId;
        this.activityType = activityType;
    }
    forwardActivity(forwarder, recipients, options) {
        const tracer = this.tracerProvider.getTracer(metadata.name, metadata.version);
        return tracer.startActiveSpan("activitypub.outbox", {
            kind: this.federation.outboxQueue == null || options?.immediate
                ? SpanKind.CLIENT
                : SpanKind.PRODUCER,
            attributes: { "activitypub.activity.type": this.activityType },
        }, async (span) => {
            try {
                if (this.activityId != null) {
                    span.setAttribute("activitypub.activity.id", this.activityId);
                }
                await this.forwardActivityInternal(forwarder, recipients, options);
            }
            catch (e) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: String(e) });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async forwardActivityInternal(forwarder, recipients, options) {
        const logger = getLogger(["fedify", "federation", "inbox"]);
        let keys;
        let identifier = null;
        if ("identifier" in forwarder || "username" in forwarder ||
            "handle" in forwarder) {
            if ("identifier" in forwarder) {
                identifier = forwarder.identifier;
            }
            else {
                let username;
                if ("username" in forwarder) {
                    username = forwarder.username;
                }
                else {
                    username = forwarder.handle;
                    logger.warn('The "handle" property for the forwarder parameter is deprecated; ' +
                        'use "identifier" or "username" instead.', { forwarder });
                }
                if (this.federation.actorCallbacks?.handleMapper == null) {
                    identifier = username;
                }
                else {
                    const mapped = await this.federation.actorCallbacks.handleMapper(this, username);
                    if (mapped == null) {
                        throw new Error(`No actor found for the given username ${JSON.stringify(username)}.`);
                    }
                    identifier = mapped;
                }
            }
            keys = await this.getKeyPairsFromIdentifier(identifier);
            if (keys.length < 1) {
                throw new Error(`No key pair found for actor ${JSON.stringify(identifier)}.`);
            }
        }
        else if (Array.isArray(forwarder)) {
            if (forwarder.length < 1) {
                throw new Error("The forwarder's key pairs are empty.");
            }
            keys = forwarder;
        }
        else {
            keys = [forwarder];
        }
        if (!hasSignature(this.activity)) {
            let hasProof;
            try {
                const activity = await Activity.fromJsonLd(this.activity, this);
                hasProof = await activity.getProof() != null;
            }
            catch {
                hasProof = false;
            }
            if (!hasProof) {
                if (options?.skipIfUnsigned)
                    return;
                logger.warn("The received activity {activityId} is not signed; even if it is " +
                    "forwarded to other servers as is, it may not be accepted by " +
                    "them due to the lack of a signature/proof.");
            }
        }
        if (recipients === "followers") {
            if (identifier == null) {
                throw new Error('If recipients is "followers", ' +
                    "forwarder must be an actor identifier or username.");
            }
            const followers = [];
            for await (const recipient of this.getFollowers(identifier)) {
                followers.push(recipient);
            }
            recipients = followers;
        }
        const inboxes = extractInboxes({
            recipients: Array.isArray(recipients) ? recipients : [recipients],
            preferSharedInbox: options?.preferSharedInbox,
            excludeBaseUris: options?.excludeBaseUris,
        });
        logger.debug("Forwarding activity {activityId} to inboxes:\n{inboxes}", {
            inboxes: globalThis.Object.keys(inboxes),
            activityId: this.activityId,
            activity: this.activity,
        });
        if (options?.immediate || this.federation.outboxQueue == null) {
            if (options?.immediate) {
                logger.debug("Forwarding activity immediately without queue since immediate " +
                    "option is set.");
            }
            else {
                logger.debug("Forwarding activity immediately without queue since queue is not " +
                    "set.");
            }
            const promises = [];
            for (const inbox in inboxes) {
                promises.push(sendActivity({
                    keys,
                    activity: this.activity,
                    activityId: this.activityId,
                    activityType: this.activityType,
                    inbox: new URL(inbox),
                    sharedInbox: inboxes[inbox].sharedInbox,
                    tracerProvider: this.tracerProvider,
                }));
            }
            await Promise.all(promises);
            return;
        }
        logger.debug("Enqueuing activity {activityId} to forward later.", { activityId: this.activityId, activity: this.activity });
        const keyJwkPairs = [];
        for (const { keyId, privateKey } of keys) {
            const privateKeyJwk = await exportJwk(privateKey);
            keyJwkPairs.push({ keyId: keyId.href, privateKey: privateKeyJwk });
        }
        const carrier = {};
        propagation.inject(context.active(), carrier);
        const messages = [];
        for (const inbox in inboxes) {
            const message = {
                type: "outbox",
                id: dntShim.crypto.randomUUID(),
                baseUrl: this.origin,
                keys: keyJwkPairs,
                activity: this.activity,
                activityId: this.activityId,
                activityType: this.activityType,
                inbox,
                sharedInbox: inboxes[inbox].sharedInbox,
                started: new Date().toISOString(),
                attempt: 0,
                headers: {},
                traceContext: carrier,
            };
            messages.push(message);
        }
        const { outboxQueue } = this.federation;
        if (outboxQueue.enqueueMany == null) {
            const promises = messages.map((m) => outboxQueue.enqueue(m));
            const results = await Promise.allSettled(promises);
            const errors = results
                .filter((r) => r.status === "rejected")
                .map((r) => r.reason);
            if (errors.length > 0) {
                logger.error("Failed to enqueue activity {activityId} to forward later:\n{errors}", { activityId: this.activityId, errors });
                if (errors.length > 1) {
                    throw new AggregateError(errors, `Failed to enqueue activity ${this.activityId} to forward later.`);
                }
                throw errors[0];
            }
        }
        else {
            try {
                await outboxQueue.enqueueMany(messages);
            }
            catch (error) {
                logger.error("Failed to enqueue activity {activityId} to forward later:\n{error}", { activityId: this.activityId, error });
                throw error;
            }
        }
    }
}
function notFound(_request) {
    return new Response("Not Found", { status: 404 });
}
function notAcceptable(_request) {
    return new Response("Not Acceptable", {
        status: 406,
        headers: {
            Vary: "Accept, Signature",
        },
    });
}
function unauthorized(_request) {
    return new Response("Unauthorized", {
        status: 401,
        headers: {
            Vary: "Accept, Signature",
        },
    });
}
/**
 * Generates or extracts a unique identifier for a request.
 *
 * This function first attempts to extract an existing request ID from standard
 * tracing headers. If none exists, it generates a new one. The ID format is:
 *
 *  -  If from headers, uses the existing ID.
 *  -  If generated, uses format `req_` followed by a base36 timestamp and
 *     6 random chars.
 *
 * @param request The incoming HTTP request.
 * @returns A string identifier unique to this request.
 */
function getRequestId(request) {
    // First try to get existing trace ID from standard headers:
    const traceId = request.headers.get("X-Request-Id") ||
        request.headers.get("X-Correlation-Id") ||
        request.headers.get("Traceparent")?.split("-")[1];
    if (traceId != null)
        return traceId;
    // Generate new ID if none exists:
    // - Use timestamp for rough chronological ordering
    // - Add random suffix for uniqueness within same millisecond
    // - Prefix to distinguish from potential existing IDs
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).slice(2, 8);
    return `req_${timestamp}${random}`;
}
