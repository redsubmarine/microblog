import { getLogger } from "@logtape/logtape";
import { parse } from "../deps/jsr.io/@std/semver/1.0.4/mod.js";
import { getUserAgent, } from "../runtime/docloader.js";
const logger = getLogger(["fedify", "nodeinfo", "client"]);
export async function getNodeInfo(url, options = {}) {
    try {
        let nodeInfoUrl = url;
        if (!options.direct) {
            const wellKnownUrl = new URL("/.well-known/nodeinfo", url);
            const wellKnownResponse = await fetch(wellKnownUrl, {
                headers: {
                    Accept: "application/json",
                    "User-Agent": typeof options.userAgent === "string"
                        ? options.userAgent
                        : getUserAgent(options.userAgent),
                },
            });
            if (!wellKnownResponse.ok) {
                logger.error("Failed to fetch {url}: {status} {statusText}", {
                    url: wellKnownUrl.href,
                    status: wellKnownResponse.status,
                    statusText: wellKnownResponse.statusText,
                });
                return undefined;
            }
            const wellKnownRd = await wellKnownResponse.json();
            const link = wellKnownRd?.links?.find((link) => link != null &&
                "rel" in link &&
                (link.rel === "http://nodeinfo.diaspora.software/ns/schema/2.0" ||
                    link.rel === "http://nodeinfo.diaspora.software/ns/schema/2.1") &&
                "href" in link &&
                link.href != null);
            if (link == null) {
                logger.error("Failed to find a NodeInfo document link from {url}: {resourceDescriptor}", { url: wellKnownUrl.href, resourceDescriptor: wellKnownRd });
                return undefined;
            }
            nodeInfoUrl = link.href;
        }
        const response = await fetch(nodeInfoUrl, {
            headers: {
                Accept: "application/json",
                "User-Agent": typeof options.userAgent === "string"
                    ? options.userAgent
                    : getUserAgent(options.userAgent),
            },
        });
        if (!response.ok) {
            logger.error("Failed to fetch NodeInfo document from {url}: {status} {statusText}", {
                url: nodeInfoUrl.toString(),
                status: response.status,
                statusText: response.statusText,
            });
            return undefined;
        }
        const data = await response.json();
        if (options.parse === "none")
            return data;
        return parseNodeInfo(data, {
            tryBestEffort: options.parse === "best-effort",
        }) ?? undefined;
    }
    catch (error) {
        logger.error("Failed to fetch NodeInfo document from {url}: {error}", {
            url: url.toString(),
            error,
        });
        return undefined;
    }
}
/**
 * Parses a NodeInfo document.
 * @param data A JSON value that complies with the NodeInfo schema.
 * @param options Options for parsing the NodeInfo document.
 * @returns The parsed NodeInfo document if it is valid.  Otherwise, `null`
 *          is returned.
 * @since 1.2.0
 */
export function parseNodeInfo(data, options = {}) {
    if (typeof data !== "object" || data == null || !("software" in data)) {
        return null;
    }
    const software = parseSoftware(data.software, options);
    if (software == null)
        return null;
    let protocols = [];
    if ("protocols" in data && Array.isArray(data.protocols)) {
        const ps = data.protocols.map(parseProtocol);
        protocols = ps.filter((p) => p != null);
        if (ps.length != protocols.length && !options.tryBestEffort)
            return null;
    }
    else {
        if (!options.tryBestEffort)
            return null;
    }
    let services;
    if ("services" in data) {
        if (typeof data.services === "object" && data.services != null) {
            const ss = parseServices(data.services, options);
            if (ss == null) {
                if (!options.tryBestEffort)
                    return null;
            }
            else {
                services = ss;
            }
        }
        else if (!options.tryBestEffort)
            return null;
    }
    let openRegistrations;
    if ("openRegistrations" in data) {
        if (typeof data.openRegistrations === "boolean") {
            openRegistrations = data.openRegistrations;
        }
        else {
            if (!options.tryBestEffort)
                return null;
        }
    }
    let usage = {
        users: {},
        localPosts: 0,
        localComments: 0,
    };
    if ("usage" in data) {
        const u = parseUsage(data.usage, options);
        if (u == null) {
            if (!options.tryBestEffort)
                return null;
        }
        else {
            usage = u;
        }
    }
    let metadata;
    if ("metadata" in data) {
        if (typeof data.metadata === "object" && data.metadata != null) {
            metadata = Object.fromEntries(Object.entries(data.metadata));
        }
        else if (!options.tryBestEffort)
            return null;
    }
    const result = { software, protocols, usage };
    if (services != null)
        result.services = services;
    if (openRegistrations != null)
        result.openRegistrations = openRegistrations;
    if (metadata != null)
        result.metadata = metadata;
    return result;
}
export function parseSoftware(data, options = {}) {
    if (typeof data !== "object" || data == null) {
        if (!options.tryBestEffort)
            data = {};
        return null;
    }
    let name;
    if ("name" in data && typeof data.name === "string" &&
        data.name.match(/^\s*[A-Za-z0-9-]+\s*$/)) {
        if (!data.name.match(/^[a-z0-9-]+$/) && !options.tryBestEffort)
            return null;
        name = data.name.trim().toLowerCase();
    }
    else {
        return null;
    }
    let version;
    if ("version" in data && typeof data.version === "string") {
        try {
            version = parse(data.version);
        }
        catch {
            if (!options.tryBestEffort)
                return null;
            version = { major: 0, minor: 0, patch: 0, build: [], prerelease: [] };
        }
    }
    else {
        if (!options.tryBestEffort)
            return null;
        version = { major: 0, minor: 0, patch: 0, build: [], prerelease: [] };
    }
    let repository;
    if ("repository" in data) {
        if (typeof data.repository === "string") {
            try {
                repository = new URL(data.repository);
            }
            catch {
                if (!options.tryBestEffort)
                    return null;
            }
        }
        else {
            if (!options.tryBestEffort)
                return null;
        }
    }
    let homepage;
    if ("homepage" in data) {
        if (typeof data.homepage === "string") {
            try {
                homepage = new URL(data.homepage);
            }
            catch {
                if (!options.tryBestEffort)
                    return null;
            }
        }
        else {
            if (!options.tryBestEffort)
                return null;
        }
    }
    const result = { name, version };
    if (repository != null)
        result.repository = repository;
    if (homepage != null)
        result.homepage = homepage;
    return result;
}
export function parseProtocol(data) {
    // cSpell: disable
    if (data === "activitypub" || data === "buddycloud" || data === "dfrn" ||
        data === "diaspora" || data === "libertree" || data === "ostatus" ||
        data === "pumpio" || data === "tent" || data === "xmpp" ||
        data === "zot") {
        // cSpell: enable
        return data;
    }
    return null;
}
export function parseServices(data, options = {}) {
    if (!(typeof data === "object") || data == null) {
        if (options.tryBestEffort)
            return {};
        return null;
    }
    let inbound;
    if ("inbound" in data && Array.isArray(data.inbound)) {
        const is = data.inbound.map(parseInboundService);
        inbound = is.filter((i) => i != null);
        if (is.length > inbound.length && !options.tryBestEffort)
            return null;
    }
    let outbound;
    if ("outbound" in data && Array.isArray(data.outbound)) {
        const os = data.outbound.map(parseOutboundService);
        outbound = os.filter((o) => o != null);
        if (os.length > outbound.length && !options.tryBestEffort)
            return null;
    }
    const result = {};
    if (inbound != null)
        result.inbound = inbound;
    if (outbound != null)
        result.outbound = outbound;
    return result;
}
export function parseInboundService(data) {
    // cSpell: disable
    if (data === "atom1.0" || data === "gnusocial" || data === "imap" ||
        data === "pnut" || data === "pop3" || data === "pumpio" ||
        data === "rss2.0" || data === "twitter") {
        // cSpell: enable
        return data;
    }
    return null;
}
export function parseOutboundService(data) {
    // cSpell: disable
    if (data === "atom1.0" || data === "blogger" || data === "buddycloud" ||
        data === "diaspora" || data === "dreamwidth" || data === "drupal" ||
        data === "facebook" || data === "friendica" || data === "gnusocial" ||
        data === "google" || data === "insanejournal" || data === "libertree" ||
        data === "linkedin" || data === "livejournal" || data === "mediagoblin" ||
        data === "myspace" || data === "pinterest" || data === "pnut" ||
        data === "posterous" || data === "pumpio" || data === "redmatrix" ||
        data === "rss2.0" || data === "smtp" || data === "tent" ||
        data === "tumblr" || data === "twitter" || data === "wordpress" ||
        data === "xmpp") {
        // cSpell: enable
        return data;
    }
    return null;
}
export function parseUsage(data, options = {}) {
    if (typeof data !== "object" || data == null)
        return null;
    const users = {};
    if ("users" in data && typeof data.users === "object" && data.users != null) {
        if ("total" in data.users) {
            if (typeof data.users.total === "number") {
                users.total = data.users.total;
            }
            else {
                if (!options.tryBestEffort)
                    return null;
                if (typeof data.users.total === "string") {
                    const n = parseInt(data.users.total);
                    if (!isNaN(n))
                        users.total = n;
                }
            }
        }
        if ("activeHalfyear" in data.users) {
            if (typeof data.users.activeHalfyear === "number") {
                users.activeHalfyear = data.users.activeHalfyear;
            }
            else {
                if (!options.tryBestEffort)
                    return null;
                if (typeof data.users.activeHalfyear === "string") {
                    const n = parseInt(data.users.activeHalfyear);
                    if (!isNaN(n))
                        users.activeHalfyear = n;
                }
            }
        }
        if ("activeMonth" in data.users) {
            if (typeof data.users.activeMonth === "number") {
                users.activeMonth = data.users.activeMonth;
            }
            else {
                if (!options.tryBestEffort)
                    return null;
                if (typeof data.users.activeMonth === "string") {
                    const n = parseInt(data.users.activeMonth);
                    if (!isNaN(n))
                        users.activeMonth = n;
                }
            }
        }
    }
    else {
        if (!options.tryBestEffort)
            return null;
    }
    let localPosts = 0;
    if ("localPosts" in data) {
        if (typeof data.localPosts === "number") {
            localPosts = data.localPosts;
        }
        else {
            if (!options.tryBestEffort)
                return null;
            if (typeof data.localPosts === "string") {
                const n = parseInt(data.localPosts);
                if (!isNaN(n))
                    localPosts = n;
            }
        }
    }
    let localComments = 0;
    if ("localComments" in data) {
        if (typeof data.localComments === "number") {
            localComments = data.localComments;
        }
        else {
            if (!options.tryBestEffort)
                return null;
            if (typeof data.localComments === "string") {
                const n = parseInt(data.localComments);
                if (!isNaN(n))
                    localComments = n;
            }
        }
    }
    return { users, localPosts, localComments };
}
