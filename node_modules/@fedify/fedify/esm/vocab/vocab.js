var _a, _b, _c, _d, _e, _f, _g, _h;
// deno-lint-ignore-file ban-unused-ignore prefer-const
import * as dntShim from "../_dnt.shims.js";
// @ts-ignore TS7016
import jsonld from "jsonld";
import { getLogger } from "@logtape/logtape";
import { SpanStatusCode, trace, } from "@opentelemetry/api";
import { LanguageTag, parseLanguageTag } from "@phensley/language-tag";
import { decode as decodeMultibase, encode as encodeMultibase, } from "../runtime/multibase/index.js";
import { getDocumentLoader, } from "../runtime/docloader.js";
import { exportMultibaseKey, exportSpki, importMultibaseKey, importPem, } from "../runtime/key.js";
import { LanguageString } from "../runtime/langstr.js";
/** Describes an object of any kind. The Object type serves as the base type for
 * most of the other kinds of objects defined in the Activity Vocabulary,
 * including other Core types such as {@link Activity},
 * {@link IntransitiveActivity}, {@link Collection} and
 * {@link OrderedCollection}.
 */
export class Object {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link Object}: `https://www.w3.org/ns/activitystreams#Object`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Object");
    }
    #_49BipA5dq9eoH8LX8xdsVumveTca_attachment = [];
    #_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [];
    #_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [];
    #_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
    #_3mhZzGXSpQ431mBSz2kvych22v4e_context = [];
    #_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
    #_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [];
    #_86xFhmgBapoMvYqjbjRuDPayTrS_generator = [];
    #_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [];
    #_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [];
    #_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [];
    #_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [];
    #_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
    #_5e258TDXtuhaFRPZiGoDfEpjdMr_published = [];
    #_7UpwM3JWcXhADcscukEehBorf6k_replies = [];
    #_3kAfck9PcEYt2L7xug5y99YPbANs_shares = [];
    #_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [];
    #_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [];
    #_2w3Jmue4up8iVDUA51WZqomEF438_startTime = [];
    #_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [];
    #_5chuqj6s95p5gg2sk1HntGfarRf_tag = [];
    #_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [];
    #_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [];
    #_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [];
    #_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [];
    #_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [];
    #_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [];
    #_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
    #_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [];
    #_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [];
    #_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [];
    #_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [];
    /**
     * Constructs a new instance of Object with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("attachments" in values && values.attachments != null) {
            if (Array.isArray(values.attachments) &&
                values.attachments.every((v) => v instanceof _a || v instanceof Link ||
                    v instanceof PropertyValue || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment = values.attachments;
            }
            else {
                throw new TypeError("The attachments must be an array of type " +
                    "Object | Link | PropertyValue | URL" + ".");
            }
        }
        if ("attribution" in values && values.attribution != null) {
            if (values.attribution instanceof Application ||
                values.attribution instanceof Group ||
                values.attribution instanceof Organization ||
                values.attribution instanceof Person ||
                values.attribution instanceof Service ||
                values.attribution instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [values.attribution];
            }
            else {
                throw new TypeError("The attribution must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("attributions" in values && values.attributions != null) {
            if ("attribution" in values &&
                values.attribution != null) {
                throw new TypeError("Cannot initialize both attribution and " +
                    "attributions at the same time.");
            }
            if (Array.isArray(values.attributions) &&
                values.attributions.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = values.attributions;
            }
            else {
                throw new TypeError("The attributions must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("audience" in values && values.audience != null) {
            if (values.audience instanceof _a || values.audience instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [values.audience];
            }
            else {
                throw new TypeError("The audience must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("audiences" in values && values.audiences != null) {
            if ("audience" in values &&
                values.audience != null) {
                throw new TypeError("Cannot initialize both audience and " +
                    "audiences at the same time.");
            }
            if (Array.isArray(values.audiences) &&
                values.audiences.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = values.audiences;
            }
            else {
                throw new TypeError("The audiences must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("content" in values && values.content != null) {
            if (typeof values.content === "string" ||
                values.content instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
            }
            else {
                throw new TypeError("The content must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("contents" in values && values.contents != null) {
            if ("content" in values &&
                values.content != null) {
                throw new TypeError("Cannot initialize both content and " +
                    "contents at the same time.");
            }
            if (Array.isArray(values.contents) &&
                values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
            }
            else {
                throw new TypeError("The contents must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("contexts" in values && values.contexts != null) {
            if (Array.isArray(values.contexts) &&
                values.contexts.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context = values.contexts;
            }
            else {
                throw new TypeError("The contexts must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("name" in values && values.name != null) {
            if (typeof values.name === "string" || values.name instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
            }
            else {
                throw new TypeError("The name must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("names" in values && values.names != null) {
            if ("name" in values &&
                values.name != null) {
                throw new TypeError("Cannot initialize both name and " +
                    "names at the same time.");
            }
            if (Array.isArray(values.names) &&
                values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
            }
            else {
                throw new TypeError("The names must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("endTime" in values && values.endTime != null) {
            if (values.endTime instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [values.endTime];
            }
            else {
                throw new TypeError("The endTime must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        if ("generators" in values && values.generators != null) {
            if (Array.isArray(values.generators) &&
                values.generators.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator = values.generators;
            }
            else {
                throw new TypeError("The generators must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("icon" in values && values.icon != null) {
            if (values.icon instanceof Image || values.icon instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [values.icon];
            }
            else {
                throw new TypeError("The icon must be of type " +
                    "Image | URL" + ".");
            }
        }
        if ("icons" in values && values.icons != null) {
            if ("icon" in values &&
                values.icon != null) {
                throw new TypeError("Cannot initialize both icon and " +
                    "icons at the same time.");
            }
            if (Array.isArray(values.icons) &&
                values.icons.every((v) => v instanceof Image || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = values.icons;
            }
            else {
                throw new TypeError("The icons must be an array of type " +
                    "Image | URL" + ".");
            }
        }
        if ("image" in values && values.image != null) {
            if (values.image instanceof Image || values.image instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [values.image];
            }
            else {
                throw new TypeError("The image must be of type " +
                    "Image | URL" + ".");
            }
        }
        if ("images" in values && values.images != null) {
            if ("image" in values &&
                values.image != null) {
                throw new TypeError("Cannot initialize both image and " +
                    "images at the same time.");
            }
            if (Array.isArray(values.images) &&
                values.images.every((v) => v instanceof Image || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = values.images;
            }
            else {
                throw new TypeError("The images must be an array of type " +
                    "Image | URL" + ".");
            }
        }
        if ("replyTarget" in values && values.replyTarget != null) {
            if (values.replyTarget instanceof _a ||
                values.replyTarget instanceof Link || values.replyTarget instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [values.replyTarget];
            }
            else {
                throw new TypeError("The replyTarget must be of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("replyTargets" in values && values.replyTargets != null) {
            if ("replyTarget" in values &&
                values.replyTarget != null) {
                throw new TypeError("Cannot initialize both replyTarget and " +
                    "replyTargets at the same time.");
            }
            if (Array.isArray(values.replyTargets) &&
                values.replyTargets.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = values.replyTargets;
            }
            else {
                throw new TypeError("The replyTargets must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("location" in values && values.location != null) {
            if (values.location instanceof _a || values.location instanceof Link ||
                values.location instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [values.location];
            }
            else {
                throw new TypeError("The location must be of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("locations" in values && values.locations != null) {
            if ("location" in values &&
                values.location != null) {
                throw new TypeError("Cannot initialize both location and " +
                    "locations at the same time.");
            }
            if (Array.isArray(values.locations) &&
                values.locations.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = values.locations;
            }
            else {
                throw new TypeError("The locations must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("preview" in values && values.preview != null) {
            if (values.preview instanceof Link || values.preview instanceof _a ||
                values.preview instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [values.preview];
            }
            else {
                throw new TypeError("The preview must be of type " +
                    "Link | Object | URL" + ".");
            }
        }
        if ("previews" in values && values.previews != null) {
            if ("preview" in values &&
                values.preview != null) {
                throw new TypeError("Cannot initialize both preview and " +
                    "previews at the same time.");
            }
            if (Array.isArray(values.previews) &&
                values.previews.every((v) => v instanceof Link || v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
            }
            else {
                throw new TypeError("The previews must be an array of type " +
                    "Link | Object | URL" + ".");
            }
        }
        if ("published" in values && values.published != null) {
            if (values.published instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published = [values.published];
            }
            else {
                throw new TypeError("The published must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        if ("replies" in values && values.replies != null) {
            if (values.replies instanceof Collection || values.replies instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_7UpwM3JWcXhADcscukEehBorf6k_replies = [values.replies];
            }
            else {
                throw new TypeError("The replies must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("shares" in values && values.shares != null) {
            if (values.shares instanceof Collection || values.shares instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares = [values.shares];
            }
            else {
                throw new TypeError("The shares must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("likes" in values && values.likes != null) {
            if (values.likes instanceof Collection || values.likes instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [values.likes];
            }
            else {
                throw new TypeError("The likes must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("emojiReactions" in values && values.emojiReactions != null) {
            if (values.emojiReactions instanceof Collection ||
                values.emojiReactions instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [
                    values.emojiReactions,
                ];
            }
            else {
                throw new TypeError("The emojiReactions must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("startTime" in values && values.startTime != null) {
            if (values.startTime instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime = [values.startTime];
            }
            else {
                throw new TypeError("The startTime must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        if ("summary" in values && values.summary != null) {
            if (typeof values.summary === "string" ||
                values.summary instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [values.summary];
            }
            else {
                throw new TypeError("The summary must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("summaries" in values && values.summaries != null) {
            if ("summary" in values &&
                values.summary != null) {
                throw new TypeError("Cannot initialize both summary and " +
                    "summaries at the same time.");
            }
            if (Array.isArray(values.summaries) &&
                values.summaries.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = values.summaries;
            }
            else {
                throw new TypeError("The summaries must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("tags" in values && values.tags != null) {
            if (Array.isArray(values.tags) &&
                values.tags.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag = values.tags;
            }
            else {
                throw new TypeError("The tags must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("updated" in values && values.updated != null) {
            if (values.updated instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [values.updated];
            }
            else {
                throw new TypeError("The updated must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        if ("url" in values && values.url != null) {
            if (values.url instanceof URL || values.url instanceof Link) {
                // @ts-ignore: type is checked above.
                this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [values.url];
            }
            else {
                throw new TypeError("The url must be of type " +
                    "URL | Link" + ".");
            }
        }
        if ("urls" in values && values.urls != null) {
            if ("url" in values &&
                values.url != null) {
                throw new TypeError("Cannot initialize both url and " +
                    "urls at the same time.");
            }
            if (Array.isArray(values.urls) &&
                values.urls.every((v) => v instanceof URL || v instanceof Link)) {
                // @ts-ignore: type is checked above.
                this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = values.urls;
            }
            else {
                throw new TypeError("The urls must be an array of type " +
                    "URL | Link" + ".");
            }
        }
        if ("to" in values && values.to != null) {
            if (values.to instanceof _a || values.to instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [values.to];
            }
            else {
                throw new TypeError("The to must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("tos" in values && values.tos != null) {
            if ("to" in values &&
                values.to != null) {
                throw new TypeError("Cannot initialize both to and " +
                    "tos at the same time.");
            }
            if (Array.isArray(values.tos) &&
                values.tos.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = values.tos;
            }
            else {
                throw new TypeError("The tos must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("bto" in values && values.bto != null) {
            if (values.bto instanceof _a || values.bto instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [values.bto];
            }
            else {
                throw new TypeError("The bto must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("btos" in values && values.btos != null) {
            if ("bto" in values &&
                values.bto != null) {
                throw new TypeError("Cannot initialize both bto and " +
                    "btos at the same time.");
            }
            if (Array.isArray(values.btos) &&
                values.btos.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = values.btos;
            }
            else {
                throw new TypeError("The btos must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("cc" in values && values.cc != null) {
            if (values.cc instanceof _a || values.cc instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [values.cc];
            }
            else {
                throw new TypeError("The cc must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("ccs" in values && values.ccs != null) {
            if ("cc" in values &&
                values.cc != null) {
                throw new TypeError("Cannot initialize both cc and " +
                    "ccs at the same time.");
            }
            if (Array.isArray(values.ccs) &&
                values.ccs.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = values.ccs;
            }
            else {
                throw new TypeError("The ccs must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("bcc" in values && values.bcc != null) {
            if (values.bcc instanceof _a || values.bcc instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [values.bcc];
            }
            else {
                throw new TypeError("The bcc must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("bccs" in values && values.bccs != null) {
            if ("bcc" in values &&
                values.bcc != null) {
                throw new TypeError("Cannot initialize both bcc and " +
                    "bccs at the same time.");
            }
            if (Array.isArray(values.bccs) &&
                values.bccs.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = values.bccs;
            }
            else {
                throw new TypeError("The bccs must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("mediaType" in values && values.mediaType != null) {
            if (typeof values.mediaType === "string") {
                // @ts-ignore: type is checked above.
                this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
            }
            else {
                throw new TypeError("The mediaType must be of type " +
                    "string" + ".");
            }
        }
        if ("duration" in values && values.duration != null) {
            if (values.duration instanceof dntShim.Temporal.Duration) {
                // @ts-ignore: type is checked above.
                this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [values.duration];
            }
            else {
                throw new TypeError("The duration must be of type " +
                    "Temporal.Duration" + ".");
            }
        }
        if ("sensitive" in values && values.sensitive != null) {
            if (typeof values.sensitive === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [values.sensitive];
            }
            else {
                throw new TypeError("The sensitive must be of type " +
                    "boolean" + ".");
            }
        }
        if ("source" in values && values.source != null) {
            if (values.source instanceof Source) {
                // @ts-ignore: type is checked above.
                this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [values.source];
            }
            else {
                throw new TypeError("The source must be of type " +
                    "Source" + ".");
            }
        }
        if ("proof" in values && values.proof != null) {
            if (values.proof instanceof DataIntegrityProof ||
                values.proof instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [values.proof];
            }
            else {
                throw new TypeError("The proof must be of type " +
                    "DataIntegrityProof | URL" + ".");
            }
        }
        if ("proofs" in values && values.proofs != null) {
            if ("proof" in values &&
                values.proof != null) {
                throw new TypeError("Cannot initialize both proof and " +
                    "proofs at the same time.");
            }
            if (Array.isArray(values.proofs) &&
                values.proofs.every((v) => v instanceof DataIntegrityProof || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = values.proofs;
            }
            else {
                throw new TypeError("The proofs must be an array of type " +
                    "DataIntegrityProof | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment =
            this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment;
        if ("attachments" in values && values.attachments != null) {
            if (Array.isArray(values.attachments) &&
                values.attachments.every((v) => v instanceof _a || v instanceof Link ||
                    v instanceof PropertyValue || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment = values.attachments;
            }
            else {
                throw new TypeError("The attachments must be an array of type " +
                    "Object | Link | PropertyValue | URL" + ".");
            }
        }
        clone.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo =
            this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
        if ("attribution" in values && values.attribution != null) {
            if (values.attribution instanceof Application ||
                values.attribution instanceof Group ||
                values.attribution instanceof Organization ||
                values.attribution instanceof Person ||
                values.attribution instanceof Service ||
                values.attribution instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [
                    values.attribution,
                ];
            }
            else {
                throw new TypeError("The attribution must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("attributions" in values && values.attributions != null) {
            if ("attribution" in values &&
                values.attribution != null) {
                throw new TypeError("Cannot update both attribution and " +
                    "attributions at the same time.");
            }
            if (Array.isArray(values.attributions) &&
                values.attributions.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = values.attributions;
            }
            else {
                throw new TypeError("The attributions must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience =
            this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
        if ("audience" in values && values.audience != null) {
            if (values.audience instanceof _a || values.audience instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [values.audience];
            }
            else {
                throw new TypeError("The audience must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("audiences" in values && values.audiences != null) {
            if ("audience" in values &&
                values.audience != null) {
                throw new TypeError("Cannot update both audience and " +
                    "audiences at the same time.");
            }
            if (Array.isArray(values.audiences) &&
                values.audiences.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = values.audiences;
            }
            else {
                throw new TypeError("The audiences must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content =
            this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
        if ("content" in values && values.content != null) {
            if (typeof values.content === "string" ||
                values.content instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
            }
            else {
                throw new TypeError("The content must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("contents" in values && values.contents != null) {
            if ("content" in values &&
                values.content != null) {
                throw new TypeError("Cannot update both content and " +
                    "contents at the same time.");
            }
            if (Array.isArray(values.contents) &&
                values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
            }
            else {
                throw new TypeError("The contents must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_3mhZzGXSpQ431mBSz2kvych22v4e_context =
            this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context;
        if ("contexts" in values && values.contexts != null) {
            if (Array.isArray(values.contexts) &&
                values.contexts.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3mhZzGXSpQ431mBSz2kvych22v4e_context = values.contexts;
            }
            else {
                throw new TypeError("The contexts must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name =
            this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        if ("name" in values && values.name != null) {
            if (typeof values.name === "string" || values.name instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
            }
            else {
                throw new TypeError("The name must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("names" in values && values.names != null) {
            if ("name" in values &&
                values.name != null) {
                throw new TypeError("Cannot update both name and " +
                    "names at the same time.");
            }
            if (Array.isArray(values.names) &&
                values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
            }
            else {
                throw new TypeError("The names must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime =
            this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime;
        if ("endTime" in values && values.endTime != null) {
            if (values.endTime instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                clone.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [values.endTime];
            }
            else {
                throw new TypeError("The endTime must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        clone.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator =
            this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator;
        if ("generators" in values && values.generators != null) {
            if (Array.isArray(values.generators) &&
                values.generators.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator = values.generators;
            }
            else {
                throw new TypeError("The generators must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        clone.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon =
            this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
        if ("icon" in values && values.icon != null) {
            if (values.icon instanceof Image || values.icon instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [values.icon];
            }
            else {
                throw new TypeError("The icon must be of type " +
                    "Image | URL" + ".");
            }
        }
        if ("icons" in values && values.icons != null) {
            if ("icon" in values &&
                values.icon != null) {
                throw new TypeError("Cannot update both icon and " +
                    "icons at the same time.");
            }
            if (Array.isArray(values.icons) &&
                values.icons.every((v) => v instanceof Image || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = values.icons;
            }
            else {
                throw new TypeError("The icons must be an array of type " +
                    "Image | URL" + ".");
            }
        }
        clone.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image =
            this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
        if ("image" in values && values.image != null) {
            if (values.image instanceof Image || values.image instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [values.image];
            }
            else {
                throw new TypeError("The image must be of type " +
                    "Image | URL" + ".");
            }
        }
        if ("images" in values && values.images != null) {
            if ("image" in values &&
                values.image != null) {
                throw new TypeError("Cannot update both image and " +
                    "images at the same time.");
            }
            if (Array.isArray(values.images) &&
                values.images.every((v) => v instanceof Image || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = values.images;
            }
            else {
                throw new TypeError("The images must be an array of type " +
                    "Image | URL" + ".");
            }
        }
        clone.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo =
            this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
        if ("replyTarget" in values && values.replyTarget != null) {
            if (values.replyTarget instanceof _a ||
                values.replyTarget instanceof Link || values.replyTarget instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [values.replyTarget];
            }
            else {
                throw new TypeError("The replyTarget must be of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("replyTargets" in values && values.replyTargets != null) {
            if ("replyTarget" in values &&
                values.replyTarget != null) {
                throw new TypeError("Cannot update both replyTarget and " +
                    "replyTargets at the same time.");
            }
            if (Array.isArray(values.replyTargets) &&
                values.replyTargets.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = values.replyTargets;
            }
            else {
                throw new TypeError("The replyTargets must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        clone.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location =
            this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
        if ("location" in values && values.location != null) {
            if (values.location instanceof _a || values.location instanceof Link ||
                values.location instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [values.location];
            }
            else {
                throw new TypeError("The location must be of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("locations" in values && values.locations != null) {
            if ("location" in values &&
                values.location != null) {
                throw new TypeError("Cannot update both location and " +
                    "locations at the same time.");
            }
            if (Array.isArray(values.locations) &&
                values.locations.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = values.locations;
            }
            else {
                throw new TypeError("The locations must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview =
            this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        if ("preview" in values && values.preview != null) {
            if (values.preview instanceof Link || values.preview instanceof _a ||
                values.preview instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [values.preview];
            }
            else {
                throw new TypeError("The preview must be of type " +
                    "Link | Object | URL" + ".");
            }
        }
        if ("previews" in values && values.previews != null) {
            if ("preview" in values &&
                values.preview != null) {
                throw new TypeError("Cannot update both preview and " +
                    "previews at the same time.");
            }
            if (Array.isArray(values.previews) &&
                values.previews.every((v) => v instanceof Link || v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
            }
            else {
                throw new TypeError("The previews must be an array of type " +
                    "Link | Object | URL" + ".");
            }
        }
        clone.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published =
            this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published;
        if ("published" in values && values.published != null) {
            if (values.published instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                clone.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published = [values.published];
            }
            else {
                throw new TypeError("The published must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        clone.#_7UpwM3JWcXhADcscukEehBorf6k_replies =
            this.#_7UpwM3JWcXhADcscukEehBorf6k_replies;
        if ("replies" in values && values.replies != null) {
            if (values.replies instanceof Collection || values.replies instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_7UpwM3JWcXhADcscukEehBorf6k_replies = [values.replies];
            }
            else {
                throw new TypeError("The replies must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares =
            this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares;
        if ("shares" in values && values.shares != null) {
            if (values.shares instanceof Collection || values.shares instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares = [values.shares];
            }
            else {
                throw new TypeError("The shares must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes =
            this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes;
        if ("likes" in values && values.likes != null) {
            if (values.likes instanceof Collection || values.likes instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [values.likes];
            }
            else {
                throw new TypeError("The likes must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions =
            this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions;
        if ("emojiReactions" in values && values.emojiReactions != null) {
            if (values.emojiReactions instanceof Collection ||
                values.emojiReactions instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [
                    values.emojiReactions,
                ];
            }
            else {
                throw new TypeError("The emojiReactions must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime =
            this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime;
        if ("startTime" in values && values.startTime != null) {
            if (values.startTime instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                clone.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime = [values.startTime];
            }
            else {
                throw new TypeError("The startTime must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        clone.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary =
            this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
        if ("summary" in values && values.summary != null) {
            if (typeof values.summary === "string" ||
                values.summary instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [values.summary];
            }
            else {
                throw new TypeError("The summary must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("summaries" in values && values.summaries != null) {
            if ("summary" in values &&
                values.summary != null) {
                throw new TypeError("Cannot update both summary and " +
                    "summaries at the same time.");
            }
            if (Array.isArray(values.summaries) &&
                values.summaries.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = values.summaries;
            }
            else {
                throw new TypeError("The summaries must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_5chuqj6s95p5gg2sk1HntGfarRf_tag =
            this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag;
        if ("tags" in values && values.tags != null) {
            if (Array.isArray(values.tags) &&
                values.tags.every((v) => v instanceof _a || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_5chuqj6s95p5gg2sk1HntGfarRf_tag = values.tags;
            }
            else {
                throw new TypeError("The tags must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        clone.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated =
            this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated;
        if ("updated" in values && values.updated != null) {
            if (values.updated instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                clone.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [values.updated];
            }
            else {
                throw new TypeError("The updated must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        clone.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url =
            this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
        if ("url" in values && values.url != null) {
            if (values.url instanceof URL || values.url instanceof Link) {
                // @ts-ignore: type is checked above.
                clone.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [values.url];
            }
            else {
                throw new TypeError("The url must be of type " +
                    "URL | Link" + ".");
            }
        }
        if ("urls" in values && values.urls != null) {
            if ("url" in values &&
                values.url != null) {
                throw new TypeError("Cannot update both url and " +
                    "urls at the same time.");
            }
            if (Array.isArray(values.urls) &&
                values.urls.every((v) => v instanceof URL || v instanceof Link)) {
                // @ts-ignore: type is checked above.
                clone.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = values.urls;
            }
            else {
                throw new TypeError("The urls must be an array of type " +
                    "URL | Link" + ".");
            }
        }
        clone.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to =
            this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
        if ("to" in values && values.to != null) {
            if (values.to instanceof _a || values.to instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [values.to];
            }
            else {
                throw new TypeError("The to must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("tos" in values && values.tos != null) {
            if ("to" in values &&
                values.to != null) {
                throw new TypeError("Cannot update both to and " +
                    "tos at the same time.");
            }
            if (Array.isArray(values.tos) &&
                values.tos.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = values.tos;
            }
            else {
                throw new TypeError("The tos must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto =
            this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
        if ("bto" in values && values.bto != null) {
            if (values.bto instanceof _a || values.bto instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [values.bto];
            }
            else {
                throw new TypeError("The bto must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("btos" in values && values.btos != null) {
            if ("bto" in values &&
                values.bto != null) {
                throw new TypeError("Cannot update both bto and " +
                    "btos at the same time.");
            }
            if (Array.isArray(values.btos) &&
                values.btos.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = values.btos;
            }
            else {
                throw new TypeError("The btos must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc =
            this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
        if ("cc" in values && values.cc != null) {
            if (values.cc instanceof _a || values.cc instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [values.cc];
            }
            else {
                throw new TypeError("The cc must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("ccs" in values && values.ccs != null) {
            if ("cc" in values &&
                values.cc != null) {
                throw new TypeError("Cannot update both cc and " +
                    "ccs at the same time.");
            }
            if (Array.isArray(values.ccs) &&
                values.ccs.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = values.ccs;
            }
            else {
                throw new TypeError("The ccs must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc =
            this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
        if ("bcc" in values && values.bcc != null) {
            if (values.bcc instanceof _a || values.bcc instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [values.bcc];
            }
            else {
                throw new TypeError("The bcc must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("bccs" in values && values.bccs != null) {
            if ("bcc" in values &&
                values.bcc != null) {
                throw new TypeError("Cannot update both bcc and " +
                    "bccs at the same time.");
            }
            if (Array.isArray(values.bccs) &&
                values.bccs.every((v) => v instanceof _a || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = values.bccs;
            }
            else {
                throw new TypeError("The bccs must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType =
            this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
        if ("mediaType" in values && values.mediaType != null) {
            if (typeof values.mediaType === "string") {
                // @ts-ignore: type is checked above.
                clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
            }
            else {
                throw new TypeError("The mediaType must be of type " +
                    "string" + ".");
            }
        }
        clone.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration =
            this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration;
        if ("duration" in values && values.duration != null) {
            if (values.duration instanceof dntShim.Temporal.Duration) {
                // @ts-ignore: type is checked above.
                clone.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [values.duration];
            }
            else {
                throw new TypeError("The duration must be of type " +
                    "Temporal.Duration" + ".");
            }
        }
        clone.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive =
            this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive;
        if ("sensitive" in values && values.sensitive != null) {
            if (typeof values.sensitive === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [values.sensitive];
            }
            else {
                throw new TypeError("The sensitive must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source =
            this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source;
        if ("source" in values && values.source != null) {
            if (values.source instanceof Source) {
                // @ts-ignore: type is checked above.
                clone.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [values.source];
            }
            else {
                throw new TypeError("The source must be of type " +
                    "Source" + ".");
            }
        }
        clone.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof =
            this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
        if ("proof" in values && values.proof != null) {
            if (values.proof instanceof DataIntegrityProof ||
                values.proof instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [values.proof];
            }
            else {
                throw new TypeError("The proof must be of type " +
                    "DataIntegrityProof | URL" + ".");
            }
        }
        if ("proofs" in values && values.proofs != null) {
            if ("proof" in values &&
                values.proof != null) {
                throw new TypeError("Cannot update both proof and " +
                    "proofs at the same time.");
            }
            if (Array.isArray(values.proofs) &&
                values.proofs.every((v) => v instanceof DataIntegrityProof || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = values.proofs;
            }
            else {
                throw new TypeError("The proofs must be an array of type " +
                    "DataIntegrityProof | URL" + ".");
            }
        }
        return clone;
    }
    async #fetchAttachment(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#attachment_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #attachment_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await PropertyValue.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
                "http://schema.org#PropertyValue",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getAttachments},
     * but returns their `@id`s instead of the objects themselves.
     */
    get attachmentIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies a resource attached or related to an object that potentially
     * requires special handling.  The intent is to provide a model that is at
     * least semantically similar to attachments in email.
     */
    async *getAttachments(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAttachment(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "attachment" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["attachment"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#attachment_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchAttribution(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#attribution_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #attribution_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getAttribution},
     * but returns its `@id` URL instead of the object itself.
     */
    get attributionId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length < 1) {
            return null;
        }
        const v = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies one or more entities to which this object is attributed.
     * The attributed entities might not be Actors.  For instance,
     * an object might be attributed to the completion of another activity.
     */
    async getAttribution(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length < 1) {
            return null;
        }
        const v = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAttribution(v, options);
            if (fetched == null)
                return null;
            this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "attributedTo" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["attributedTo"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#attribution_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getAttributions},
     * but returns their `@id`s instead of the objects themselves.
     */
    get attributionIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies one or more entities to which this object is attributed.
     * The attributed entities might not be Actors.  For instance,
     * an object might be attributed to the completion of another activity.
     */
    async *getAttributions(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAttribution(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "attributedTo" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["attributedTo"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#attribution_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchAudience(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#audience_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #audience_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getAudience},
     * but returns its `@id` URL instead of the object itself.
     */
    get audienceId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length < 1)
            return null;
        const v = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies one or more entities that represent the total population of
     * entities for which the object can considered to be relevant.
     */
    async getAudience(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length < 1)
            return null;
        const v = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAudience(v, options);
            if (fetched == null)
                return null;
            this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "audience" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["audience"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#audience_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getAudiences},
     * but returns their `@id`s instead of the objects themselves.
     */
    get audienceIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies one or more entities that represent the total population of
     * entities for which the object can considered to be relevant.
     */
    async *getAudiences(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAudience(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "audience" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["audience"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#audience_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** The content or textual representation of the Object encoded as a JSON
     * string.  By default, the value of `content` is HTML.  The `mediaType`
     * property can be used in the object to indicate a different content type.
     *
     * The content MAY be expressed using multiple language-tagged values.
     */
    get content() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length < 1)
            return null;
        return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
    }
    /** The content or textual representation of the Object encoded as a JSON
     * string.  By default, the value of `content` is HTML.  The `mediaType`
     * property can be used in the object to indicate a different content type.
     *
     * The content MAY be expressed using multiple language-tagged values.
     */
    get contents() {
        return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
    }
    async #fetchContext(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#context_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #context_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getContexts},
     * but returns their `@id`s instead of the objects themselves.
     */
    get contextIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies the context within which the object exists or an activity was
     * performed.
     *
     * The notion of "context" used is intentionally vague.  The intended function
     * is to serve as a means of grouping objects and activities that share
     * a common originating context or purpose.  An example could be all activities
     * relating to a common project or event.
     */
    async *getContexts(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchContext(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "context" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["context"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#context_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** A simple, human-readable, plain-text name for the object. HTML markup MUST
     * NOT be included. The name MAY be expressed using multiple language-tagged
     * values.
     */
    get name() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length < 1)
            return null;
        return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
    }
    /** A simple, human-readable, plain-text name for the object. HTML markup MUST
     * NOT be included. The name MAY be expressed using multiple language-tagged
     * values.
     */
    get names() {
        return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
    }
    /** The date and time describing the actual or expected ending time of
     * the object.  When used with an {@link Activity} object, for instance,
     * the `endTime`` property specifies the moment the activity concluded
     * or is expected to conclude.
     */
    get endTime() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime.length < 1)
            return null;
        return this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime[0];
    }
    async #fetchGenerator(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#generator_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #generator_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getGenerators},
     * but returns their `@id`s instead of the objects themselves.
     */
    get generatorIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies the entity (e.g. an application) that generated the object.
     */
    async *getGenerators(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchGenerator(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "generator" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["generator"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#generator_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchIcon(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#icon_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #icon_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Image.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Image"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getIcon},
     * but returns its `@id` URL instead of the object itself.
     */
    get iconId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length < 1)
            return null;
        const v = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Indicates an entity that describes an icon for this object.
     * The image should have an aspect ratio of one (horizontal) to one
     * (vertical) and should be suitable for presentation at a small size.
     */
    async getIcon(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length < 1)
            return null;
        const v = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchIcon(v, options);
            if (fetched == null)
                return null;
            this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "icon" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["icon"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#icon_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getIcons},
     * but returns their `@id`s instead of the objects themselves.
     */
    get iconIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Indicates an entity that describes an icon for this object.
     * The image should have an aspect ratio of one (horizontal) to one
     * (vertical) and should be suitable for presentation at a small size.
     */
    async *getIcons(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchIcon(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "icon" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["icon"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#icon_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchImage(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#image_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #image_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Image.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Image"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getImage},
     * but returns its `@id` URL instead of the object itself.
     */
    get imageId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length < 1)
            return null;
        const v = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Indicates an entity that describes an image for this object.
     * Unlike the icon property, there are no aspect ratio or display size
     * limitations assumed.
     */
    async getImage(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length < 1)
            return null;
        const v = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchImage(v, options);
            if (fetched == null)
                return null;
            this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "image" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["image"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#image_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getImages},
     * but returns their `@id`s instead of the objects themselves.
     */
    get imageIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Indicates an entity that describes an image for this object.
     * Unlike the icon property, there are no aspect ratio or display size
     * limitations assumed.
     */
    async *getImages(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchImage(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "image" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["image"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#image_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchReplyTarget(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#replyTarget_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #replyTarget_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getReplyTarget},
     * but returns its `@id` URL instead of the object itself.
     */
    get replyTargetId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length < 1)
            return null;
        const v = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Indicates one or more entities for which this object is considered
     * a response.
     */
    async getReplyTarget(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length < 1)
            return null;
        const v = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchReplyTarget(v, options);
            if (fetched == null)
                return null;
            this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "inReplyTo" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["inReplyTo"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#replyTarget_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getReplyTargets},
     * but returns their `@id`s instead of the objects themselves.
     */
    get replyTargetIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Indicates one or more entities for which this object is considered
     * a response.
     */
    async *getReplyTargets(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchReplyTarget(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "inReplyTo" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["inReplyTo"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#replyTarget_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchLocation(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#location_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #location_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getLocation},
     * but returns its `@id` URL instead of the object itself.
     */
    get locationId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length < 1)
            return null;
        const v = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Indicates one or more physical or logical locations associated with
     * the object.
     */
    async getLocation(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length < 1)
            return null;
        const v = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLocation(v, options);
            if (fetched == null)
                return null;
            this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "location" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["location"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#location_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getLocations},
     * but returns their `@id`s instead of the objects themselves.
     */
    get locationIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Indicates one or more physical or logical locations associated with
     * the object.
     */
    async *getLocations(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchLocation(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "location" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["location"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#location_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchPreview(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#preview_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #preview_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Link",
                "https://www.w3.org/ns/activitystreams#Object",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getPreview},
     * but returns its `@id` URL instead of the object itself.
     */
    get previewId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length < 1)
            return null;
        const v = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies an entity that provides a preview of this object.
     */
    async getPreview(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length < 1)
            return null;
        const v = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPreview(v, options);
            if (fetched == null)
                return null;
            this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "preview" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["preview"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#preview_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getPreviews},
     * but returns their `@id`s instead of the objects themselves.
     */
    get previewIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies an entity that provides a preview of this object.
     */
    async *getPreviews(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchPreview(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "preview" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["preview"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#preview_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** The date and time at which the object was published.
     */
    get published() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published.length < 1)
            return null;
        return this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published[0];
    }
    async #fetchReplies(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#replies_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #replies_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getReplies},
     * but returns its `@id` URL instead of the object itself.
     */
    get repliesId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_7UpwM3JWcXhADcscukEehBorf6k_replies.length < 1)
            return null;
        const v = this.#_7UpwM3JWcXhADcscukEehBorf6k_replies[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies a {@link Collection} containing objects considered to be
     * responses to this object.
     */
    async getReplies(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_7UpwM3JWcXhADcscukEehBorf6k_replies.length < 1)
            return null;
        const v = this.#_7UpwM3JWcXhADcscukEehBorf6k_replies[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchReplies(v, options);
            if (fetched == null)
                return null;
            this.#_7UpwM3JWcXhADcscukEehBorf6k_replies[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "replies" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["replies"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#replies_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchShares(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#shares_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #shares_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getShares},
     * but returns its `@id` URL instead of the object itself.
     */
    get sharesId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares.length < 1)
            return null;
        const v = this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Every object *may* have a `shares` collection. This is a list of all
     * {@link Announce} activities with this object as the `object` property,
     * added as a [side effect]. The `shares` collection *must* be either
     * an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
     * on privileges of an authenticated user or as appropriate
     * when no authentication is given.
     *
     * [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
     */
    async getShares(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares.length < 1)
            return null;
        const v = this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchShares(v, options);
            if (fetched == null)
                return null;
            this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "shares" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["shares"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#shares_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchLikes(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#likes_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #likes_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getLikes},
     * but returns its `@id` URL instead of the object itself.
     */
    get likesId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.length < 1)
            return null;
        const v = this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Every object *may* have a `likes` collection. This is a list of all
     * {@link Like} activities with this object as the `object` property,
     * added as a [side effect]. The `likes` collection *must* be either
     * an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
     * on privileges of an authenticated user or as appropriate
     * when no authentication is given.
     *
     * [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
     */
    async getLikes(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.length < 1)
            return null;
        const v = this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLikes(v, options);
            if (fetched == null)
                return null;
            this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "likes" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["likes"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#likes_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchEmojiReactions(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#emojiReactions_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #emojiReactions_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getEmojiReactions},
     * but returns its `@id` URL instead of the object itself.
     */
    get emojiReactionsId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.length < 1) {
            return null;
        }
        const v = this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies a {@link Collection} containing objects considered to be
     * emoji reactions to this object.
     */
    async getEmojiReactions(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.length < 1) {
            return null;
        }
        const v = this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchEmojiReactions(v, options);
            if (fetched == null)
                return null;
            this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "emojiReactions" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["emojiReactions"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#emojiReactions_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /** The date and time describing the actual or expected starting time of
     * the object.  When used with an {@link Activity} object, for instance,
     * the `startTime` property specifies the moment the activity began or
     * is scheduled to begin.
     */
    get startTime() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime.length < 1)
            return null;
        return this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime[0];
    }
    /** A natural language summarization of the object encoded as HTML.
     * Multiple language tagged summaries MAY be provided.
     */
    get summary() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length < 1)
            return null;
        return this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary[0];
    }
    /** A natural language summarization of the object encoded as HTML.
     * Multiple language tagged summaries MAY be provided.
     */
    get summaries() {
        return this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
    }
    async #fetchTag(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#tag_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #tag_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getTags},
     * but returns their `@id`s instead of the objects themselves.
     */
    get tagIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** One or more "tags" that have been associated with an objects.
     * A tag can be any kind of Object.  The key difference between `attachment`
     * and `tag` is that the former implies association by inclusion,
     * while the latter implies associated by reference.
     */
    async *getTags(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchTag(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "tag" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["tag"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#tag_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** The date and time at which the object was updated.
     */
    get updated() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated.length < 1)
            return null;
        return this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated[0];
    }
    /** Identifies one or more links to representations of the object.
     */
    get url() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length < 1)
            return null;
        return this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url[0];
    }
    /** Identifies one or more links to representations of the object.
     */
    get urls() {
        return this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
    }
    async #fetchTo(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#to_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #to_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getTo},
     * but returns its `@id` URL instead of the object itself.
     */
    get toId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length < 1)
            return null;
        const v = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies an entity considered to be part of the public primary audience
     * of an Object.
     */
    async getTo(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length < 1)
            return null;
        const v = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchTo(v, options);
            if (fetched == null)
                return null;
            this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "to" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["to"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#to_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getTos},
     * but returns their `@id`s instead of the objects themselves.
     */
    get toIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies an entity considered to be part of the public primary audience
     * of an Object.
     */
    async *getTos(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchTo(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "to" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["to"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#to_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchBto(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#bto_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #bto_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getBto},
     * but returns its `@id` URL instead of the object itself.
     */
    get btoId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length < 1)
            return null;
        const v = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies an Object that is part of the private primary audience of
     * this Object.
     */
    async getBto(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length < 1)
            return null;
        const v = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchBto(v, options);
            if (fetched == null)
                return null;
            this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "bto" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["bto"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#bto_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getBtos},
     * but returns their `@id`s instead of the objects themselves.
     */
    get btoIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies an Object that is part of the private primary audience of
     * this Object.
     */
    async *getBtos(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchBto(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "bto" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["bto"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#bto_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchCc(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#cc_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #cc_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getCc},
     * but returns its `@id` URL instead of the object itself.
     */
    get ccId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length < 1)
            return null;
        const v = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies an Object that is part of the public secondary audience of
     * this Object.
     */
    async getCc(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length < 1)
            return null;
        const v = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchCc(v, options);
            if (fetched == null)
                return null;
            this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "cc" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["cc"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#cc_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getCcs},
     * but returns their `@id`s instead of the objects themselves.
     */
    get ccIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies an Object that is part of the public secondary audience of
     * this Object.
     */
    async *getCcs(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchCc(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "cc" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["cc"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#cc_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchBcc(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#bcc_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #bcc_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _a.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getBcc},
     * but returns its `@id` URL instead of the object itself.
     */
    get bccId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length < 1)
            return null;
        const v = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies one or more Objects that are part of the private secondary
     * audience of this Object.
     */
    async getBcc(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length < 1)
            return null;
        const v = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchBcc(v, options);
            if (fetched == null)
                return null;
            this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "bcc" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["bcc"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#bcc_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getBccs},
     * but returns their `@id`s instead of the objects themselves.
     */
    get bccIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies one or more Objects that are part of the private secondary
     * audience of this Object.
     */
    async *getBccs(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchBcc(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "bcc" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["bcc"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#bcc_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** When used on an {@link Object}, identifies the MIME media type of the value
     * of the `content` property.  If not specified, the `content` property is
     * assumed to contain `text/html` content.
     */
    get mediaType() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length < 1)
            return null;
        return this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
    }
    /** When the object describes a time-bound resource, such as an audio or video,
     * a meeting, etc, the `duration` property indicates the object's approximate
     * duration.  The value MUST be expressed as an `xsd:duration` as defined by
     * W3C XML Schema Definition Language (XSD) 1.1 Part 2: DataTypes, section
     * 3.3.6 (e.g. a period of 5 seconds is represented as `PT5S`).
     */
    get duration() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration.length < 1)
            return null;
        return this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration[0];
    }
    /** Whether it contains any sensitive contents.
     */
    get sensitive() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive.length < 1)
            return null;
        return this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive[0];
    }
    /** The `source` property is intended to convey some sort of source from which
     * the `content` markup was derived, as a form of provenance, or to support
     * future editing by clients.  In general, clients do the conversion from
     * `source` to `content`, not the other way around.
     */
    get source() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source.length < 1)
            return null;
        return this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source[0];
    }
    async #fetchProof(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#proof_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #proof_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await DataIntegrityProof.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#DataIntegrityProof"].join(", "));
    }
    /**
     * Similar to
     * {@link Object.getProof},
     * but returns its `@id` URL instead of the object itself.
     */
    get proofId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length < 1)
            return null;
        const v = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** A cryptographic proof that can be used to verify the integrity of an object.
     */
    async getProof(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length < 1)
            return null;
        const v = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchProof(v, options);
            if (fetched == null)
                return null;
            this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "proof" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["proof"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#proof_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Object.getProofs},
     * but returns their `@id`s instead of the objects themselves.
     */
    get proofIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A cryptographic proof that can be used to verify the integrity of an object.
     */
    async *getProofs(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchProof(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "proof" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["proof"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#proof_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = {};
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _a
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Link
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["attachment"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["attributedTo"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["audience"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["content"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _a
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["context"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["name"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime) {
                const item = v.toString();
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["endTime"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _a
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["generator"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["icon"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["image"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _a
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["inReplyTo"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _a
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["location"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Link
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["preview"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published) {
                const item = v.toString();
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["published"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_7UpwM3JWcXhADcscukEehBorf6k_replies) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["replies"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["shares"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["likes"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["emojiReactions"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime) {
                const item = v.toString();
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["startTime"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["summary"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _a
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["tag"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated) {
                const item = v.toString();
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["updated"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["url"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["to"] = compactItems.length > 1 ? compactItems : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["bto"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["cc"] = compactItems.length > 1 ? compactItems : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["bcc"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["mediaType"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration) {
                const item = v.toString();
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["duration"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["sensitive"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source) {
                const item = await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["source"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["proof"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Object";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _a
                    ? await v.toJsonLd(options)
                    : v instanceof Link
                        ? await v.toJsonLd(options)
                        : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#attachment"] = propValue;
        }
        array = [];
        for (const v of this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#attributedTo"] = propValue;
        }
        array = [];
        for (const v of this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#audience"] = propValue;
        }
        array = [];
        for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#content"] = propValue;
        }
        array = [];
        for (const v of this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _a
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#context"] = propValue;
        }
        array = [];
        for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#name"] = propValue;
        }
        array = [];
        for (const v of this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                "@value": v.toString(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#endTime"] = propValue;
        }
        array = [];
        for (const v of this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _a
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#generator"] = propValue;
        }
        array = [];
        for (const v of this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#icon"] = propValue;
        }
        array = [];
        for (const v of this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#image"] = propValue;
        }
        array = [];
        for (const v of this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _a
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#inReplyTo"] = propValue;
        }
        array = [];
        for (const v of this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _a
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#location"] = propValue;
        }
        array = [];
        for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Link
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#preview"] = propValue;
        }
        array = [];
        for (const v of this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                "@value": v.toString(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#published"] = propValue;
        }
        array = [];
        for (const v of this.#_7UpwM3JWcXhADcscukEehBorf6k_replies) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#replies"] = propValue;
        }
        array = [];
        for (const v of this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#shares"] = propValue;
        }
        array = [];
        for (const v of this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#likes"] = propValue;
        }
        array = [];
        for (const v of this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://fedibird.com/ns#emojiReactions"] = propValue;
        }
        array = [];
        for (const v of this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                "@value": v.toString(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#startTime"] = propValue;
        }
        array = [];
        for (const v of this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#summary"] = propValue;
        }
        array = [];
        for (const v of this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _a
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#tag"] = propValue;
        }
        array = [];
        for (const v of this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                "@value": v.toString(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#updated"] = propValue;
        }
        array = [];
        for (const v of this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#url"] = propValue;
        }
        array = [];
        for (const v of this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#to"] = propValue;
        }
        array = [];
        for (const v of this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#bto"] = propValue;
        }
        array = [];
        for (const v of this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#cc"] = propValue;
        }
        array = [];
        for (const v of this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#bcc"] = propValue;
        }
        array = [];
        for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#mediaType"] = propValue;
        }
        array = [];
        for (const v of this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#duration",
                "@value": v.toString(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#duration"] = propValue;
        }
        array = [];
        for (const v of this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#sensitive"] = propValue;
        }
        array = [];
        for (const v of this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source) {
            const element = await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#source"] = propValue;
        }
        array = [];
        for (const v of this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push({ "@graph": element });
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#proof"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Object"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content != null &&
            this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0)
            return false;
        if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name != null &&
            this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0)
            return false;
        if (this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary != null &&
            this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length > 0)
            return false;
        if (this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof != null &&
            this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length > 0)
            return false;
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Object__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Object__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("http://joinmastodon.org/ns#Emoji")) {
                return await Emoji.fromJsonLd(json, options);
            }
            if (values["@type"].includes("http://litepub.social/ns#ChatMessage")) {
                return await ChatMessage.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Activity")) {
                return await Activity.fromJsonLd(json, options);
            }
            if (values["@type"].includes("http://litepub.social/ns#EmojiReact")) {
                return await EmojiReact.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Accept")) {
                return await Accept.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) {
                return await TentativeAccept.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Add")) {
                return await Add.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Announce")) {
                return await Announce.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Create")) {
                return await Create.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Delete")) {
                return await Delete.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Dislike")) {
                return await Dislike.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Flag")) {
                return await Flag.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Follow")) {
                return await Follow.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Ignore")) {
                return await Ignore.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) {
                return await Block.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#IntransitiveActivity")) {
                return await IntransitiveActivity.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) {
                return await Arrive.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) {
                return await Question.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) {
                return await Travel.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Join")) {
                return await Join.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Leave")) {
                return await Leave.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Like")) {
                return await Like.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Listen")) {
                return await Listen.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Move")) {
                return await Move.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Offer")) {
                return await Offer.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) {
                return await Invite.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Read")) {
                return await Read.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Reject")) {
                return await Reject.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) {
                return await TentativeReject.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Remove")) {
                return await Remove.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Undo")) {
                return await Undo.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Update")) {
                return await Update.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#View")) {
                return await View.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Application")) {
                return await Application.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Article")) {
                return await Article.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Collection")) {
                return await Collection.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#CollectionPage")) {
                return await CollectionPage.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) {
                return await OrderedCollectionPage.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")) {
                return await OrderedCollection.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Document")) {
                return await Document.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Audio")) {
                return await Audio.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Image")) {
                return await Image.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Page")) {
                return await Page.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Video")) {
                return await Video.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Event")) {
                return await Event.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Group")) {
                return await Group.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Note")) {
                return await Note.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")) {
                return await Organization.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Person")) {
                return await Person.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Place")) {
                return await Place.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Profile")) {
                return await Profile.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Relationship")) {
                return await Relationship.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Service")) {
                return await Service.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Tombstone")) {
                return await Tombstone.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Object")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _49BipA5dq9eoH8LX8xdsVumveTca_attachment = [];
        let _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array = values["https://www.w3.org/ns/activitystreams#attachment"];
        for (const v of _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array == null
            ? []
            : _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array.length === 1 &&
                "@list" in _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array[0]
                ? _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array[0]["@list"]
                : _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _49BipA5dq9eoH8LX8xdsVumveTca_attachment.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await _a.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("http://schema.org#PropertyValue")
                        ? await PropertyValue.fromJsonLd(v, options)
                        : undefined;
            if (typeof decoded === "undefined")
                continue;
            _49BipA5dq9eoH8LX8xdsVumveTca_attachment.push(decoded);
        }
        instance.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment =
            _49BipA5dq9eoH8LX8xdsVumveTca_attachment;
        const _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [];
        let _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array = values["https://www.w3.org/ns/activitystreams#attributedTo"];
        for (const v of _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array == null
            ? []
            : _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array.length === 1 &&
                "@list" in _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array[0]
                ? _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array[0]["@list"]
                : _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.push(decoded);
        }
        instance.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo =
            _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
        const _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [];
        let _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array = values["https://www.w3.org/ns/activitystreams#audience"];
        for (const v of _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array == null
            ? []
            : _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array.length === 1 &&
                "@list" in _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array[0]
                ? _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array[0]["@list"]
                : _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.push(await _a.fromJsonLd(v, options));
        }
        instance.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience =
            _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
        const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
        let _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array = values["https://www.w3.org/ns/activitystreams#content"];
        for (const v of _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array == null
            ? []
            : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array.length === 1 &&
                "@list" in _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0]
                ? _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0]["@list"]
                : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.push(decoded);
        }
        instance.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content =
            _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
        const _3mhZzGXSpQ431mBSz2kvych22v4e_context = [];
        let _3mhZzGXSpQ431mBSz2kvych22v4e_context__array = values["https://www.w3.org/ns/activitystreams#context"];
        for (const v of _3mhZzGXSpQ431mBSz2kvych22v4e_context__array == null
            ? []
            : _3mhZzGXSpQ431mBSz2kvych22v4e_context__array.length === 1 &&
                "@list" in _3mhZzGXSpQ431mBSz2kvych22v4e_context__array[0]
                ? _3mhZzGXSpQ431mBSz2kvych22v4e_context__array[0]["@list"]
                : _3mhZzGXSpQ431mBSz2kvych22v4e_context__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3mhZzGXSpQ431mBSz2kvych22v4e_context.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await _a.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3mhZzGXSpQ431mBSz2kvych22v4e_context.push(decoded);
        }
        instance.#_3mhZzGXSpQ431mBSz2kvych22v4e_context =
            _3mhZzGXSpQ431mBSz2kvych22v4e_context;
        const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
        let _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array = values["https://www.w3.org/ns/activitystreams#name"];
        for (const v of _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array == null
            ? []
            : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array.length === 1 &&
                "@list" in _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]
                ? _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]["@list"]
                : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.push(decoded);
        }
        instance.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name =
            _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        const _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [];
        let _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array = values["https://www.w3.org/ns/activitystreams#endTime"];
        for (const v of _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array == null
            ? []
            : _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array.length === 1 &&
                "@list" in _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array[0]
                ? _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array[0]["@list"]
                : _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array) {
            if (v == null)
                continue;
            _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime.push(dntShim.Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/)
                ? v["@value"]
                : v["@value"] + "Z"));
        }
        instance.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime =
            _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime;
        const _86xFhmgBapoMvYqjbjRuDPayTrS_generator = [];
        let _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array = values["https://www.w3.org/ns/activitystreams#generator"];
        for (const v of _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array == null
            ? []
            : _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array.length === 1 &&
                "@list" in _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array[0]
                ? _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array[0]["@list"]
                : _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _86xFhmgBapoMvYqjbjRuDPayTrS_generator.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await _a.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _86xFhmgBapoMvYqjbjRuDPayTrS_generator.push(decoded);
        }
        instance.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator =
            _86xFhmgBapoMvYqjbjRuDPayTrS_generator;
        const _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [];
        let _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array = values["https://www.w3.org/ns/activitystreams#icon"];
        for (const v of _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array == null
            ? []
            : _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array.length === 1 &&
                "@list" in _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array[0]
                ? _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array[0]["@list"]
                : _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.push(await Image.fromJsonLd(v, options));
        }
        instance.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon =
            _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
        const _3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [];
        let _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array = values["https://www.w3.org/ns/activitystreams#image"];
        for (const v of _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array == null
            ? []
            : _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array.length === 1 &&
                "@list" in _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array[0]
                ? _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array[0]["@list"]
                : _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3dXrUdkARxwyJLtJcYi1AJ92H41U_image.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3dXrUdkARxwyJLtJcYi1AJ92H41U_image.push(await Image.fromJsonLd(v, options));
        }
        instance.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image =
            _3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
        const _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [];
        let _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array = values["https://www.w3.org/ns/activitystreams#inReplyTo"];
        for (const v of _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array == null
            ? []
            : _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array.length === 1 &&
                "@list" in _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array[0]
                ? _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array[0]["@list"]
                : _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await _a.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.push(decoded);
        }
        instance.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo =
            _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
        const _31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [];
        let _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array = values["https://www.w3.org/ns/activitystreams#location"];
        for (const v of _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array == null
            ? []
            : _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array.length === 1 &&
                "@list" in _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array[0]
                ? _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array[0]["@list"]
                : _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _31k5MUZJsnsPNg8dQQJieWaXTFnR_location.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await _a.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _31k5MUZJsnsPNg8dQQJieWaXTFnR_location.push(decoded);
        }
        instance.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location =
            _31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
        const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
        let _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array = values["https://www.w3.org/ns/activitystreams#preview"];
        for (const v of _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array == null
            ? []
            : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array.length === 1 &&
                "@list" in _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0]
                ? _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0]["@list"]
                : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Link",
                    "https://www.w3.org/ns/activitystreams#Hashtag",
                    "https://www.w3.org/ns/activitystreams#Mention",
                ].some((t) => v["@type"].includes(t))
                ? await Link.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Object",
                        "http://joinmastodon.org/ns#Emoji",
                        "http://litepub.social/ns#ChatMessage",
                        "https://www.w3.org/ns/activitystreams#Activity",
                        "http://litepub.social/ns#EmojiReact",
                        "https://www.w3.org/ns/activitystreams#Accept",
                        "https://www.w3.org/ns/activitystreams#TentativeAccept",
                        "https://www.w3.org/ns/activitystreams#Add",
                        "https://www.w3.org/ns/activitystreams#Announce",
                        "https://www.w3.org/ns/activitystreams#Create",
                        "https://www.w3.org/ns/activitystreams#Delete",
                        "https://www.w3.org/ns/activitystreams#Dislike",
                        "https://www.w3.org/ns/activitystreams#Flag",
                        "https://www.w3.org/ns/activitystreams#Follow",
                        "https://www.w3.org/ns/activitystreams#Ignore",
                        "https://www.w3.org/ns/activitystreams#Block",
                        "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                        "https://www.w3.org/ns/activitystreams#Arrive",
                        "https://www.w3.org/ns/activitystreams#Question",
                        "https://www.w3.org/ns/activitystreams#Travel",
                        "https://www.w3.org/ns/activitystreams#Join",
                        "https://www.w3.org/ns/activitystreams#Leave",
                        "https://www.w3.org/ns/activitystreams#Like",
                        "https://www.w3.org/ns/activitystreams#Listen",
                        "https://www.w3.org/ns/activitystreams#Move",
                        "https://www.w3.org/ns/activitystreams#Offer",
                        "https://www.w3.org/ns/activitystreams#Invite",
                        "https://www.w3.org/ns/activitystreams#Read",
                        "https://www.w3.org/ns/activitystreams#Reject",
                        "https://www.w3.org/ns/activitystreams#TentativeReject",
                        "https://www.w3.org/ns/activitystreams#Remove",
                        "https://www.w3.org/ns/activitystreams#Undo",
                        "https://www.w3.org/ns/activitystreams#Update",
                        "https://www.w3.org/ns/activitystreams#View",
                        "https://www.w3.org/ns/activitystreams#Application",
                        "https://www.w3.org/ns/activitystreams#Article",
                        "https://www.w3.org/ns/activitystreams#Collection",
                        "https://www.w3.org/ns/activitystreams#CollectionPage",
                        "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                        "https://www.w3.org/ns/activitystreams#OrderedCollection",
                        "https://www.w3.org/ns/activitystreams#Document",
                        "https://www.w3.org/ns/activitystreams#Audio",
                        "https://www.w3.org/ns/activitystreams#Image",
                        "https://www.w3.org/ns/activitystreams#Page",
                        "https://www.w3.org/ns/activitystreams#Video",
                        "https://www.w3.org/ns/activitystreams#Event",
                        "https://www.w3.org/ns/activitystreams#Group",
                        "https://www.w3.org/ns/activitystreams#Note",
                        "https://www.w3.org/ns/activitystreams#Organization",
                        "https://www.w3.org/ns/activitystreams#Person",
                        "https://www.w3.org/ns/activitystreams#Place",
                        "https://www.w3.org/ns/activitystreams#Profile",
                        "https://www.w3.org/ns/activitystreams#Relationship",
                        "https://www.w3.org/ns/activitystreams#Service",
                        "https://www.w3.org/ns/activitystreams#Tombstone",
                    ].some((t) => v["@type"].includes(t))
                    ? await _a.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(decoded);
        }
        instance.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview =
            _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        const _5e258TDXtuhaFRPZiGoDfEpjdMr_published = [];
        let _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array = values["https://www.w3.org/ns/activitystreams#published"];
        for (const v of _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array == null
            ? []
            : _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array.length === 1 &&
                "@list" in _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array[0]
                ? _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array[0]["@list"]
                : _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array) {
            if (v == null)
                continue;
            _5e258TDXtuhaFRPZiGoDfEpjdMr_published.push(dntShim.Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/)
                ? v["@value"]
                : v["@value"] + "Z"));
        }
        instance.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published =
            _5e258TDXtuhaFRPZiGoDfEpjdMr_published;
        const _7UpwM3JWcXhADcscukEehBorf6k_replies = [];
        let _7UpwM3JWcXhADcscukEehBorf6k_replies__array = values["https://www.w3.org/ns/activitystreams#replies"];
        for (const v of _7UpwM3JWcXhADcscukEehBorf6k_replies__array == null
            ? []
            : _7UpwM3JWcXhADcscukEehBorf6k_replies__array.length === 1 &&
                "@list" in _7UpwM3JWcXhADcscukEehBorf6k_replies__array[0]
                ? _7UpwM3JWcXhADcscukEehBorf6k_replies__array[0]["@list"]
                : _7UpwM3JWcXhADcscukEehBorf6k_replies__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _7UpwM3JWcXhADcscukEehBorf6k_replies.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _7UpwM3JWcXhADcscukEehBorf6k_replies.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_7UpwM3JWcXhADcscukEehBorf6k_replies =
            _7UpwM3JWcXhADcscukEehBorf6k_replies;
        const _3kAfck9PcEYt2L7xug5y99YPbANs_shares = [];
        let _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array = values["https://www.w3.org/ns/activitystreams#shares"];
        for (const v of _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array == null
            ? []
            : _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array.length === 1 &&
                "@list" in _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array[0]
                ? _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array[0]["@list"]
                : _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3kAfck9PcEYt2L7xug5y99YPbANs_shares.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3kAfck9PcEYt2L7xug5y99YPbANs_shares.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares =
            _3kAfck9PcEYt2L7xug5y99YPbANs_shares;
        const _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [];
        let _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array = values["https://www.w3.org/ns/activitystreams#likes"];
        for (const v of _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array == null
            ? []
            : _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array.length === 1 &&
                "@list" in _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array[0]
                ? _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array[0]["@list"]
                : _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes =
            _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes;
        const _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [];
        let _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array = values["http://fedibird.com/ns#emojiReactions"];
        for (const v of _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array == null
            ? []
            : _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array.length === 1 &&
                "@list" in _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array[0]
                ? _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array[0]["@list"]
                : _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions =
            _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions;
        const _2w3Jmue4up8iVDUA51WZqomEF438_startTime = [];
        let _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array = values["https://www.w3.org/ns/activitystreams#startTime"];
        for (const v of _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array == null
            ? []
            : _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array.length === 1 &&
                "@list" in _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array[0]
                ? _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array[0]["@list"]
                : _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array) {
            if (v == null)
                continue;
            _2w3Jmue4up8iVDUA51WZqomEF438_startTime.push(dntShim.Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/)
                ? v["@value"]
                : v["@value"] + "Z"));
        }
        instance.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime =
            _2w3Jmue4up8iVDUA51WZqomEF438_startTime;
        const _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [];
        let _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array = values["https://www.w3.org/ns/activitystreams#summary"];
        for (const v of _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array == null
            ? []
            : _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array.length === 1 &&
                "@list" in _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array[0]
                ? _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array[0]["@list"]
                : _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.push(decoded);
        }
        instance.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary =
            _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
        const _5chuqj6s95p5gg2sk1HntGfarRf_tag = [];
        let _5chuqj6s95p5gg2sk1HntGfarRf_tag__array = values["https://www.w3.org/ns/activitystreams#tag"];
        for (const v of _5chuqj6s95p5gg2sk1HntGfarRf_tag__array == null
            ? []
            : _5chuqj6s95p5gg2sk1HntGfarRf_tag__array.length === 1 &&
                "@list" in _5chuqj6s95p5gg2sk1HntGfarRf_tag__array[0]
                ? _5chuqj6s95p5gg2sk1HntGfarRf_tag__array[0]["@list"]
                : _5chuqj6s95p5gg2sk1HntGfarRf_tag__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _5chuqj6s95p5gg2sk1HntGfarRf_tag.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await _a.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _5chuqj6s95p5gg2sk1HntGfarRf_tag.push(decoded);
        }
        instance.#_5chuqj6s95p5gg2sk1HntGfarRf_tag =
            _5chuqj6s95p5gg2sk1HntGfarRf_tag;
        const _385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [];
        let _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array = values["https://www.w3.org/ns/activitystreams#updated"];
        for (const v of _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array == null
            ? []
            : _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array.length === 1 &&
                "@list" in _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array[0]
                ? _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array[0]["@list"]
                : _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array) {
            if (v == null)
                continue;
            _385aB7ySixcf5Un6z3VsWmThgCzQ_updated.push(dntShim.Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/)
                ? v["@value"]
                : v["@value"] + "Z"));
        }
        instance.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated =
            _385aB7ySixcf5Un6z3VsWmThgCzQ_updated;
        const _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [];
        let _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array = values["https://www.w3.org/ns/activitystreams#url"];
        for (const v of _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array == null
            ? []
            : _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array.length === 1 &&
                "@list" in _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array[0]
                ? _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array[0]["@list"]
                : _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@id" in v &&
                typeof v["@id"] === "string" &&
                v["@id"] !== "" && v["@id"] !== "/"
                ? new URL(v["@id"])
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.push(decoded);
        }
        instance.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url =
            _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
        const _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [];
        let _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array = values["https://www.w3.org/ns/activitystreams#to"];
        for (const v of _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array == null
            ? []
            : _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array.length === 1 &&
                "@list" in _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array[0]
                ? _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array[0]["@list"]
                : _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.push(await _a.fromJsonLd(v, options));
        }
        instance.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to =
            _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
        const _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [];
        let _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array = values["https://www.w3.org/ns/activitystreams#bto"];
        for (const v of _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array == null
            ? []
            : _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array.length === 1 &&
                "@list" in _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array[0]
                ? _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array[0]["@list"]
                : _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.push(await _a.fromJsonLd(v, options));
        }
        instance.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto =
            _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
        const _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [];
        let _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array = values["https://www.w3.org/ns/activitystreams#cc"];
        for (const v of _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array == null
            ? []
            : _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array.length === 1 &&
                "@list" in _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array[0]
                ? _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array[0]["@list"]
                : _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.push(await _a.fromJsonLd(v, options));
        }
        instance.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc =
            _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
        const _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [];
        let _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array = values["https://www.w3.org/ns/activitystreams#bcc"];
        for (const v of _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array == null
            ? []
            : _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array.length === 1 &&
                "@list" in _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array[0]
                ? _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array[0]["@list"]
                : _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.push(await _a.fromJsonLd(v, options));
        }
        instance.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc =
            _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
        const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
        let _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array = values["https://www.w3.org/ns/activitystreams#mediaType"];
        for (const v of _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array == null
            ? []
            : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array.length === 1 &&
                "@list" in _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]
                ? _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]["@list"]
                : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array) {
            if (v == null)
                continue;
            _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.push(v["@value"]);
        }
        instance.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType =
            _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
        const _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [];
        let _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array = values["https://www.w3.org/ns/activitystreams#duration"];
        for (const v of _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array == null
            ? []
            : _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array.length === 1 &&
                "@list" in _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array[0]
                ? _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array[0]["@list"]
                : _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array) {
            if (v == null)
                continue;
            _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration.push(dntShim.Temporal.Duration.from(v["@value"]));
        }
        instance.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration =
            _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration;
        const _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [];
        let _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array = values["https://www.w3.org/ns/activitystreams#sensitive"];
        for (const v of _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array == null
            ? []
            : _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array.length === 1 &&
                "@list" in _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array[0]
                ? _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array[0]["@list"]
                : _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array) {
            if (v == null)
                continue;
            _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive.push(v["@value"]);
        }
        instance.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive =
            _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive;
        const _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [];
        let _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array = values["https://www.w3.org/ns/activitystreams#source"];
        for (const v of _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array == null
            ? []
            : _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array.length === 1 &&
                "@list" in _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array[0]
                ? _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array[0]["@list"]
                : _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array) {
            if (v == null)
                continue;
            _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source.push(await Source.fromJsonLd(v, options));
        }
        instance.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source =
            _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source;
        const _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [];
        let _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array = values["https://w3id.org/security#proof"];
        for (const v of _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array == null
            ? []
            : _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array.length === 1 &&
                "@list" in _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array[0]
                ? _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array[0]["@list"]
                : _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.push(await DataIntegrityProof.fromJsonLd(v, options));
        }
        instance.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof =
            _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _49BipA5dq9eoH8LX8xdsVumveTca_attachment = this
            .#_49BipA5dq9eoH8LX8xdsVumveTca_attachment
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_49BipA5dq9eoH8LX8xdsVumveTca_attachment.length > 1 ||
            !("attachment" in proxy) &&
                _49BipA5dq9eoH8LX8xdsVumveTca_attachment.length > 0) {
            proxy.attachments = _49BipA5dq9eoH8LX8xdsVumveTca_attachment;
        }
        const _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = this
            .#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length == 1) {
            proxy.attribution = _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0];
        }
        if (_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length > 1 ||
            !("attribution" in proxy) &&
                _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length > 0) {
            proxy.attributions = _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
        }
        const _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = this
            .#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length == 1) {
            proxy.audience = _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0];
        }
        if (_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length > 1 ||
            !("audience" in proxy) &&
                _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length > 0) {
            proxy.audiences = _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
        }
        const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = this
            .#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length == 1) {
            proxy.content = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
        }
        if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 1 ||
            !("content" in proxy) &&
                _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0) {
            proxy.contents = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
        }
        const _3mhZzGXSpQ431mBSz2kvych22v4e_context = this
            .#_3mhZzGXSpQ431mBSz2kvych22v4e_context
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3mhZzGXSpQ431mBSz2kvych22v4e_context.length > 1 ||
            !("context" in proxy) &&
                _3mhZzGXSpQ431mBSz2kvych22v4e_context.length > 0) {
            proxy.contexts = _3mhZzGXSpQ431mBSz2kvych22v4e_context;
        }
        const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this
            .#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length == 1) {
            proxy.name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
        }
        if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 1 ||
            !("name" in proxy) &&
                _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0) {
            proxy.names = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        }
        const _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = this
            .#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime.length == 1) {
            proxy.endTime = _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime[0];
        }
        const _86xFhmgBapoMvYqjbjRuDPayTrS_generator = this
            .#_86xFhmgBapoMvYqjbjRuDPayTrS_generator
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_86xFhmgBapoMvYqjbjRuDPayTrS_generator.length > 1 ||
            !("generator" in proxy) &&
                _86xFhmgBapoMvYqjbjRuDPayTrS_generator.length > 0) {
            proxy.generators = _86xFhmgBapoMvYqjbjRuDPayTrS_generator;
        }
        const _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = this
            .#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length == 1) {
            proxy.icon = _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0];
        }
        if (_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length > 1 ||
            !("icon" in proxy) &&
                _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length > 0) {
            proxy.icons = _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
        }
        const _3dXrUdkARxwyJLtJcYi1AJ92H41U_image = this
            .#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length == 1) {
            proxy.image = _3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0];
        }
        if (_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length > 1 ||
            !("image" in proxy) &&
                _3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length > 0) {
            proxy.images = _3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
        }
        const _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = this
            .#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length == 1) {
            proxy.replyTarget = _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0];
        }
        if (_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length > 1 ||
            !("replyTarget" in proxy) &&
                _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length > 0) {
            proxy.replyTargets = _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
        }
        const _31k5MUZJsnsPNg8dQQJieWaXTFnR_location = this
            .#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length == 1) {
            proxy.location = _31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0];
        }
        if (_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length > 1 ||
            !("location" in proxy) &&
                _31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length > 0) {
            proxy.locations = _31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
        }
        const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = this
            .#_gCVTegXxWWCw6wWRxa1QF65zusg_preview
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length == 1) {
            proxy.preview = _gCVTegXxWWCw6wWRxa1QF65zusg_preview[0];
        }
        if (_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 1 ||
            !("preview" in proxy) &&
                _gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 0) {
            proxy.previews = _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        }
        const _5e258TDXtuhaFRPZiGoDfEpjdMr_published = this
            .#_5e258TDXtuhaFRPZiGoDfEpjdMr_published
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_5e258TDXtuhaFRPZiGoDfEpjdMr_published.length == 1) {
            proxy.published = _5e258TDXtuhaFRPZiGoDfEpjdMr_published[0];
        }
        const _7UpwM3JWcXhADcscukEehBorf6k_replies = this
            .#_7UpwM3JWcXhADcscukEehBorf6k_replies
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_7UpwM3JWcXhADcscukEehBorf6k_replies.length == 1) {
            proxy.replies = _7UpwM3JWcXhADcscukEehBorf6k_replies[0];
        }
        const _3kAfck9PcEYt2L7xug5y99YPbANs_shares = this
            .#_3kAfck9PcEYt2L7xug5y99YPbANs_shares
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3kAfck9PcEYt2L7xug5y99YPbANs_shares.length == 1) {
            proxy.shares = _3kAfck9PcEYt2L7xug5y99YPbANs_shares[0];
        }
        const _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = this
            .#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.length == 1) {
            proxy.likes = _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0];
        }
        const _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = this
            .#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.length == 1) {
            proxy.emojiReactions = _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0];
        }
        const _2w3Jmue4up8iVDUA51WZqomEF438_startTime = this
            .#_2w3Jmue4up8iVDUA51WZqomEF438_startTime
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2w3Jmue4up8iVDUA51WZqomEF438_startTime.length == 1) {
            proxy.startTime = _2w3Jmue4up8iVDUA51WZqomEF438_startTime[0];
        }
        const _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = this
            .#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length == 1) {
            proxy.summary = _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary[0];
        }
        if (_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length > 1 ||
            !("summary" in proxy) &&
                _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length > 0) {
            proxy.summaries = _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
        }
        const _5chuqj6s95p5gg2sk1HntGfarRf_tag = this
            .#_5chuqj6s95p5gg2sk1HntGfarRf_tag
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_5chuqj6s95p5gg2sk1HntGfarRf_tag.length > 1 ||
            !("tag" in proxy) &&
                _5chuqj6s95p5gg2sk1HntGfarRf_tag.length > 0) {
            proxy.tags = _5chuqj6s95p5gg2sk1HntGfarRf_tag;
        }
        const _385aB7ySixcf5Un6z3VsWmThgCzQ_updated = this
            .#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_385aB7ySixcf5Un6z3VsWmThgCzQ_updated.length == 1) {
            proxy.updated = _385aB7ySixcf5Un6z3VsWmThgCzQ_updated[0];
        }
        const _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = this
            .#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length == 1) {
            proxy.url = _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url[0];
        }
        if (_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length > 1 ||
            !("url" in proxy) &&
                _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length > 0) {
            proxy.urls = _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
        }
        const _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = this
            .#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length == 1) {
            proxy.to = _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0];
        }
        if (_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length > 1 ||
            !("to" in proxy) &&
                _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length > 0) {
            proxy.tos = _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
        }
        const _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = this
            .#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length == 1) {
            proxy.bto = _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0];
        }
        if (_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length > 1 ||
            !("bto" in proxy) &&
                _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length > 0) {
            proxy.btos = _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
        }
        const _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = this
            .#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length == 1) {
            proxy.cc = _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0];
        }
        if (_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length > 1 ||
            !("cc" in proxy) &&
                _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length > 0) {
            proxy.ccs = _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
        }
        const _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = this
            .#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length == 1) {
            proxy.bcc = _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0];
        }
        if (_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length > 1 ||
            !("bcc" in proxy) &&
                _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length > 0) {
            proxy.bccs = _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
        }
        const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this
            .#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length == 1) {
            proxy.mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
        }
        const _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = this
            .#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration.length == 1) {
            proxy.duration = _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration[0];
        }
        const _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = this
            .#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive.length == 1) {
            proxy.sensitive = _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive[0];
        }
        const _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = this
            .#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source.length == 1) {
            proxy.source = _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source[0];
        }
        const _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = this
            .#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length == 1) {
            proxy.proof = _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0];
        }
        if (_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length > 1 ||
            !("proof" in proxy) &&
                _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length > 0) {
            proxy.proofs = _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Object " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Object " + inspect(proxy, options);
    }
}
_a = Object;
/** Represents a custom emoji.
 */
export class Emoji extends Object {
    /**
     * The type URI of {@link Emoji}: `http://joinmastodon.org/ns#Emoji`.
     */
    static get typeId() {
        return new URL("http://joinmastodon.org/ns#Emoji");
    }
    /**
     * Constructs a new instance of Emoji with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Emoji";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = ["https://www.w3.org/ns/activitystreams", {
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                }];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["http://joinmastodon.org/ns#Emoji"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            ["https://www.w3.org/ns/activitystreams", {
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                }];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Emoji__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Emoji__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("http://joinmastodon.org/ns#Emoji")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Emoji)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Emoji " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Emoji " + inspect(proxy, options);
    }
}
/** `ChatMessage`s are the messages sent in 1-on-1 chats.  They are similar to
 * {@link Note}s, but the addressing is done by having a single AP actor in
 * the `to` field.  Addressing multiple actors is not allowed.  These messages
 * are always private, there is no public version of them.  They are created with
 * a {@link Create} activity.
 */
export class ChatMessage extends Object {
    /**
     * The type URI of {@link ChatMessage}: `http://litepub.social/ns#ChatMessage`.
     */
    static get typeId() {
        return new URL("http://litepub.social/ns#ChatMessage");
    }
    #_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
    /**
     * Constructs a new instance of ChatMessage with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
        return clone;
    }
    /** The URI of the ActivityStreams object that this object quotes.
     *
     * This property sets three JSON-LD properties at once under the hood:
     *
     * 1. https://www.w3.org/ns/activitystreams#quoteUrl
     * 2. https://misskey-hub.net/ns#_misskey_quote
     * 3. http://fedibird.com/ns#quoteUri
     *
     * When a JSON-LD object is parsed, this property is filled with one of
     * the values of those three properties in order.
     */
    get quoteUrl() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1)
            return null;
        return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["quoteUrl"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
                result["_misskey_quote"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
                result["quoteUri"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "ChatMessage";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "Emoji": "toot:Emoji",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
            const element = { "@value": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
            values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
            values["http://fedibird.com/ns#quoteUri"] = propValue;
        }
        values["@type"] = ["http://litepub.social/ns#ChatMessage"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "Emoji": "toot:Emoji",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__ChatMessage__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__ChatMessage__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("http://litepub.social/ns#ChatMessage")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof ChatMessage)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
        let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["https://misskey-hub.net/ns#_misskey_quote"];
        }
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["http://fedibird.com/ns#quoteUri"];
        }
        for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null
            ? []
            : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 &&
                "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]
                ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"]
                : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
            if (v == null)
                continue;
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
        }
        instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this
            .#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) {
            proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "ChatMessage " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "ChatMessage " + inspect(proxy, options);
    }
}
/** An Activity is a subtype of {@link Object} that describes some form of action
 * that may happen, is currently happening, or has already happened.
 * The {@link Activity} type itself serves as an abstract base type for all types
 * of activities.  It is important to note that the {@link Activity} type itself
 * does not carry any specific semantics about the kind of action being taken.
 */
export class Activity extends Object {
    /**
     * The type URI of {@link Activity}: `https://www.w3.org/ns/activitystreams#Activity`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Activity");
    }
    #_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [];
    #_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
    #_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [];
    #_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [];
    #_25zu2s3VxVujgEKqrDycjE284XQR_origin = [];
    #_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [];
    /**
     * Constructs a new instance of Activity with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("actor" in values && values.actor != null) {
            if (values.actor instanceof Application || values.actor instanceof Group ||
                values.actor instanceof Organization ||
                values.actor instanceof Person || values.actor instanceof Service ||
                values.actor instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [values.actor];
            }
            else {
                throw new TypeError("The actor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("actors" in values && values.actors != null) {
            if ("actor" in values &&
                values.actor != null) {
                throw new TypeError("Cannot initialize both actor and " +
                    "actors at the same time.");
            }
            if (Array.isArray(values.actors) &&
                values.actors.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = values.actors;
            }
            else {
                throw new TypeError("The actors must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("object" in values && values.object != null) {
            if (values.object instanceof Object || values.object instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
            }
            else {
                throw new TypeError("The object must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("objects" in values && values.objects != null) {
            if ("object" in values &&
                values.object != null) {
                throw new TypeError("Cannot initialize both object and " +
                    "objects at the same time.");
            }
            if (Array.isArray(values.objects) &&
                values.objects.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
            }
            else {
                throw new TypeError("The objects must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("target" in values && values.target != null) {
            if (values.target instanceof Object || values.target instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [values.target];
            }
            else {
                throw new TypeError("The target must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("targets" in values && values.targets != null) {
            if ("target" in values &&
                values.target != null) {
                throw new TypeError("Cannot initialize both target and " +
                    "targets at the same time.");
            }
            if (Array.isArray(values.targets) &&
                values.targets.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = values.targets;
            }
            else {
                throw new TypeError("The targets must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("result" in values && values.result != null) {
            if (values.result instanceof Object || values.result instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [values.result];
            }
            else {
                throw new TypeError("The result must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("results" in values && values.results != null) {
            if ("result" in values &&
                values.result != null) {
                throw new TypeError("Cannot initialize both result and " +
                    "results at the same time.");
            }
            if (Array.isArray(values.results) &&
                values.results.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = values.results;
            }
            else {
                throw new TypeError("The results must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("origin" in values && values.origin != null) {
            if (values.origin instanceof Object || values.origin instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = [values.origin];
            }
            else {
                throw new TypeError("The origin must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("origins" in values && values.origins != null) {
            if ("origin" in values &&
                values.origin != null) {
                throw new TypeError("Cannot initialize both origin and " +
                    "origins at the same time.");
            }
            if (Array.isArray(values.origins) &&
                values.origins.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = values.origins;
            }
            else {
                throw new TypeError("The origins must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("instrument" in values && values.instrument != null) {
            if (values.instrument instanceof Object || values.instrument instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [values.instrument];
            }
            else {
                throw new TypeError("The instrument must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("instruments" in values && values.instruments != null) {
            if ("instrument" in values &&
                values.instrument != null) {
                throw new TypeError("Cannot initialize both instrument and " +
                    "instruments at the same time.");
            }
            if (Array.isArray(values.instruments) &&
                values.instruments.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = values.instruments;
            }
            else {
                throw new TypeError("The instruments must be an array of type " +
                    "Object | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor =
            this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
        if ("actor" in values && values.actor != null) {
            if (values.actor instanceof Application || values.actor instanceof Group ||
                values.actor instanceof Organization ||
                values.actor instanceof Person || values.actor instanceof Service ||
                values.actor instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [values.actor];
            }
            else {
                throw new TypeError("The actor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("actors" in values && values.actors != null) {
            if ("actor" in values &&
                values.actor != null) {
                throw new TypeError("Cannot update both actor and " +
                    "actors at the same time.");
            }
            if (Array.isArray(values.actors) &&
                values.actors.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = values.actors;
            }
            else {
                throw new TypeError("The actors must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object =
            this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        if ("object" in values && values.object != null) {
            if (values.object instanceof Object || values.object instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
            }
            else {
                throw new TypeError("The object must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("objects" in values && values.objects != null) {
            if ("object" in values &&
                values.object != null) {
                throw new TypeError("Cannot update both object and " +
                    "objects at the same time.");
            }
            if (Array.isArray(values.objects) &&
                values.objects.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
            }
            else {
                throw new TypeError("The objects must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target =
            this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
        if ("target" in values && values.target != null) {
            if (values.target instanceof Object || values.target instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [values.target];
            }
            else {
                throw new TypeError("The target must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("targets" in values && values.targets != null) {
            if ("target" in values &&
                values.target != null) {
                throw new TypeError("Cannot update both target and " +
                    "targets at the same time.");
            }
            if (Array.isArray(values.targets) &&
                values.targets.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = values.targets;
            }
            else {
                throw new TypeError("The targets must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result =
            this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
        if ("result" in values && values.result != null) {
            if (values.result instanceof Object || values.result instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [values.result];
            }
            else {
                throw new TypeError("The result must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("results" in values && values.results != null) {
            if ("result" in values &&
                values.result != null) {
                throw new TypeError("Cannot update both result and " +
                    "results at the same time.");
            }
            if (Array.isArray(values.results) &&
                values.results.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = values.results;
            }
            else {
                throw new TypeError("The results must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_25zu2s3VxVujgEKqrDycjE284XQR_origin =
            this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin;
        if ("origin" in values && values.origin != null) {
            if (values.origin instanceof Object || values.origin instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = [values.origin];
            }
            else {
                throw new TypeError("The origin must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("origins" in values && values.origins != null) {
            if ("origin" in values &&
                values.origin != null) {
                throw new TypeError("Cannot update both origin and " +
                    "origins at the same time.");
            }
            if (Array.isArray(values.origins) &&
                values.origins.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = values.origins;
            }
            else {
                throw new TypeError("The origins must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument =
            this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
        if ("instrument" in values && values.instrument != null) {
            if (values.instrument instanceof Object || values.instrument instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [values.instrument];
            }
            else {
                throw new TypeError("The instrument must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("instruments" in values && values.instruments != null) {
            if ("instrument" in values &&
                values.instrument != null) {
                throw new TypeError("Cannot update both instrument and " +
                    "instruments at the same time.");
            }
            if (Array.isArray(values.instruments) &&
                values.instruments.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = values.instruments;
            }
            else {
                throw new TypeError("The instruments must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        return clone;
    }
    async #fetchActor(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#actor_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #actor_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Activity.getActor},
     * but returns its `@id` URL instead of the object itself.
     */
    get actorId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length < 1)
            return null;
        const v = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Describes one or more entities that either performed or are expected to
     * perform the activity.  Any single activity can have multiple actors.
     * The actor MAY be specified using an indirect {@link Link}.
     */
    async getActor(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length < 1)
            return null;
        const v = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchActor(v, options);
            if (fetched == null)
                return null;
            this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "actor" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["actor"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#actor_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Activity.getActors},
     * but returns their `@id`s instead of the objects themselves.
     */
    get actorIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Describes one or more entities that either performed or are expected to
     * perform the activity.  Any single activity can have multiple actors.
     * The actor MAY be specified using an indirect {@link Link}.
     */
    async *getActors(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchActor(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "actor" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["actor"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#actor_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchObject(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#object_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #object_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Activity.getObject},
     * but returns its `@id` URL instead of the object itself.
     */
    get objectId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1)
            return null;
        const v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** When used within an {@link Activity}, describes the direct object of
     * the activity.  For instance, in the activity "John added a movie to his
     * wishlist", the object of the activity is the movie added.
     */
    async getObject(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1)
            return null;
        const v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchObject(v, options);
            if (fetched == null)
                return null;
            this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "object" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["object"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#object_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Activity.getObjects},
     * but returns their `@id`s instead of the objects themselves.
     */
    get objectIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** When used within an {@link Activity}, describes the direct object of
     * the activity.  For instance, in the activity "John added a movie to his
     * wishlist", the object of the activity is the movie added.
     */
    async *getObjects(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchObject(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "object" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["object"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#object_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchTarget(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#target_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #target_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Activity.getTarget},
     * but returns its `@id` URL instead of the object itself.
     */
    get targetId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length < 1)
            return null;
        const v = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Describes the indirect object, or target, of the activity.  The precise
     * meaning of the target is largely dependent on the type of action being
     * described but will often be the object of the English preposition "to".
     * For instance, in the activity "John added a movie to his wishlist",
     * the target of the activity is John's wishlist.  An activity can have more
     * than one target.
     */
    async getTarget(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length < 1)
            return null;
        const v = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchTarget(v, options);
            if (fetched == null)
                return null;
            this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "target" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["target"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#target_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Activity.getTargets},
     * but returns their `@id`s instead of the objects themselves.
     */
    get targetIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Describes the indirect object, or target, of the activity.  The precise
     * meaning of the target is largely dependent on the type of action being
     * described but will often be the object of the English preposition "to".
     * For instance, in the activity "John added a movie to his wishlist",
     * the target of the activity is John's wishlist.  An activity can have more
     * than one target.
     */
    async *getTargets(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchTarget(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "target" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["target"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#target_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchResult(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#result_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #result_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Activity.getResult},
     * but returns its `@id` URL instead of the object itself.
     */
    get resultId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length < 1)
            return null;
        const v = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Describes the result of the activity.  For instance, if a particular action
     * results in the creation of a new resource, the result property can be used
     * to describe that new resource.
     */
    async getResult(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length < 1)
            return null;
        const v = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchResult(v, options);
            if (fetched == null)
                return null;
            this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "result" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["result"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#result_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Activity.getResults},
     * but returns their `@id`s instead of the objects themselves.
     */
    get resultIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Describes the result of the activity.  For instance, if a particular action
     * results in the creation of a new resource, the result property can be used
     * to describe that new resource.
     */
    async *getResults(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchResult(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "result" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["result"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#result_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchOrigin(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#origin_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #origin_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Activity.getOrigin},
     * but returns its `@id` URL instead of the object itself.
     */
    get originId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin.length < 1)
            return null;
        const v = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Describes an indirect object of the activity from which the activity is
     * directed.  The precise meaning of the origin is the object of the English
     * preposition "from". For instance, in the activity "John moved an item to
     * List B from List A", the origin of the activity is "List A".
     */
    async getOrigin(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin.length < 1)
            return null;
        const v = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchOrigin(v, options);
            if (fetched == null)
                return null;
            this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "origin" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["origin"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#origin_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Activity.getOrigins},
     * but returns their `@id`s instead of the objects themselves.
     */
    get originIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Describes an indirect object of the activity from which the activity is
     * directed.  The precise meaning of the origin is the object of the English
     * preposition "from". For instance, in the activity "John moved an item to
     * List B from List A", the origin of the activity is "List A".
     */
    async *getOrigins(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchOrigin(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "origin" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["origin"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#origin_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchInstrument(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#instrument_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #instrument_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Activity.getInstrument},
     * but returns its `@id` URL instead of the object itself.
     */
    get instrumentId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length < 1)
            return null;
        const v = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies one or more objects used (or to be used) in the completion of
     * an {@link Activity}.
     */
    async getInstrument(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length < 1)
            return null;
        const v = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchInstrument(v, options);
            if (fetched == null)
                return null;
            this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "instrument" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["instrument"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#instrument_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Activity.getInstruments},
     * but returns their `@id`s instead of the objects themselves.
     */
    get instrumentIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies one or more objects used (or to be used) in the completion of
     * an {@link Activity}.
     */
    async *getInstruments(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchInstrument(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "instrument" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["instrument"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#instrument_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#actor"] = propValue;
        }
        array = [];
        for (const v of this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#object"] = propValue;
        }
        array = [];
        for (const v of this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#target"] = propValue;
        }
        array = [];
        for (const v of this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#result"] = propValue;
        }
        array = [];
        for (const v of this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#origin"] = propValue;
        }
        array = [];
        for (const v of this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#instrument"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Activity"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Activity__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Activity__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("http://litepub.social/ns#EmojiReact")) {
                return await EmojiReact.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Accept")) {
                return await Accept.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) {
                return await TentativeAccept.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Add")) {
                return await Add.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Announce")) {
                return await Announce.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Create")) {
                return await Create.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Delete")) {
                return await Delete.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Dislike")) {
                return await Dislike.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Flag")) {
                return await Flag.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Follow")) {
                return await Follow.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Ignore")) {
                return await Ignore.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) {
                return await Block.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#IntransitiveActivity")) {
                return await IntransitiveActivity.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) {
                return await Arrive.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) {
                return await Question.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) {
                return await Travel.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Join")) {
                return await Join.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Leave")) {
                return await Leave.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Like")) {
                return await Like.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Listen")) {
                return await Listen.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Move")) {
                return await Move.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Offer")) {
                return await Offer.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) {
                return await Invite.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Read")) {
                return await Read.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Reject")) {
                return await Reject.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) {
                return await TentativeReject.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Remove")) {
                return await Remove.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Undo")) {
                return await Undo.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Update")) {
                return await Update.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#View")) {
                return await View.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Activity")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Activity)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [];
        let _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array = values["https://www.w3.org/ns/activitystreams#actor"];
        for (const v of _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array == null
            ? []
            : _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array.length === 1 &&
                "@list" in _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array[0]
                ? _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array[0]["@list"]
                : _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.push(decoded);
        }
        instance.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor =
            _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
        const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
        let _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array = values["https://www.w3.org/ns/activitystreams#object"];
        for (const v of _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array == null
            ? []
            : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array.length === 1 &&
                "@list" in _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0]
                ? _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0]["@list"]
                : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(await Object.fromJsonLd(v, options));
        }
        instance.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object =
            _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        const _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [];
        let _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array = values["https://www.w3.org/ns/activitystreams#target"];
        for (const v of _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array == null
            ? []
            : _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array.length === 1 &&
                "@list" in _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array[0]
                ? _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array[0]["@list"]
                : _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.push(await Object.fromJsonLd(v, options));
        }
        instance.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target =
            _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
        const _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [];
        let _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array = values["https://www.w3.org/ns/activitystreams#result"];
        for (const v of _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array == null
            ? []
            : _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array.length === 1 &&
                "@list" in _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array[0]
                ? _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array[0]["@list"]
                : _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.push(await Object.fromJsonLd(v, options));
        }
        instance.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result =
            _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
        const _25zu2s3VxVujgEKqrDycjE284XQR_origin = [];
        let _25zu2s3VxVujgEKqrDycjE284XQR_origin__array = values["https://www.w3.org/ns/activitystreams#origin"];
        for (const v of _25zu2s3VxVujgEKqrDycjE284XQR_origin__array == null
            ? []
            : _25zu2s3VxVujgEKqrDycjE284XQR_origin__array.length === 1 &&
                "@list" in _25zu2s3VxVujgEKqrDycjE284XQR_origin__array[0]
                ? _25zu2s3VxVujgEKqrDycjE284XQR_origin__array[0]["@list"]
                : _25zu2s3VxVujgEKqrDycjE284XQR_origin__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _25zu2s3VxVujgEKqrDycjE284XQR_origin.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _25zu2s3VxVujgEKqrDycjE284XQR_origin.push(await Object.fromJsonLd(v, options));
        }
        instance.#_25zu2s3VxVujgEKqrDycjE284XQR_origin =
            _25zu2s3VxVujgEKqrDycjE284XQR_origin;
        const _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [];
        let _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array = values["https://www.w3.org/ns/activitystreams#instrument"];
        for (const v of _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array == null
            ? []
            : _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array.length === 1 &&
                "@list" in _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array[0]
                ? _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array[0]["@list"]
                : _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.push(await Object.fromJsonLd(v, options));
        }
        instance.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument =
            _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = this
            .#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length == 1) {
            proxy.actor = _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0];
        }
        if (_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length > 1 ||
            !("actor" in proxy) &&
                _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length > 0) {
            proxy.actors = _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
        }
        const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = this
            .#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length == 1) {
            proxy.object = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
        }
        if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 1 ||
            !("object" in proxy) &&
                _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 0) {
            proxy.objects = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        }
        const _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = this
            .#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length == 1) {
            proxy.target = _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0];
        }
        if (_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length > 1 ||
            !("target" in proxy) &&
                _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length > 0) {
            proxy.targets = _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
        }
        const _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = this
            .#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length == 1) {
            proxy.result = _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0];
        }
        if (_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length > 1 ||
            !("result" in proxy) &&
                _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length > 0) {
            proxy.results = _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
        }
        const _25zu2s3VxVujgEKqrDycjE284XQR_origin = this
            .#_25zu2s3VxVujgEKqrDycjE284XQR_origin
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_25zu2s3VxVujgEKqrDycjE284XQR_origin.length == 1) {
            proxy.origin = _25zu2s3VxVujgEKqrDycjE284XQR_origin[0];
        }
        if (_25zu2s3VxVujgEKqrDycjE284XQR_origin.length > 1 ||
            !("origin" in proxy) &&
                _25zu2s3VxVujgEKqrDycjE284XQR_origin.length > 0) {
            proxy.origins = _25zu2s3VxVujgEKqrDycjE284XQR_origin;
        }
        const _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = this
            .#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length == 1) {
            proxy.instrument = _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0];
        }
        if (_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length > 1 ||
            !("instrument" in proxy) &&
                _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length > 0) {
            proxy.instruments = _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Activity " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Activity " + inspect(proxy, options);
    }
}
/** Represents an emoji reaction.  See also [FEP-c0e0](https://w3id.org/fep/c0e0).
 */
export class EmojiReact extends Activity {
    /**
     * The type URI of {@link EmojiReact}: `http://litepub.social/ns#EmojiReact`.
     */
    static get typeId() {
        return new URL("http://litepub.social/ns#EmojiReact");
    }
    /**
     * Constructs a new instance of EmojiReact with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["http://litepub.social/ns#EmojiReact"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "litepub": "http://litepub.social/ns#",
                    "toot": "http://joinmastodon.org/ns#",
                    "EmojiReact": "litepub:EmojiReact",
                    "Emoji": "toot:Emoji",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__EmojiReact__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__EmojiReact__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("http://litepub.social/ns#EmojiReact")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof EmojiReact)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "EmojiReact " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "EmojiReact " + inspect(proxy, options);
    }
}
/** A pair of property name and value.
 */
export class PropertyValue {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link PropertyValue}: `http://schema.org#PropertyValue`.
     */
    static get typeId() {
        return new URL("http://schema.org#PropertyValue");
    }
    #_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
    #_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [];
    /**
     * Constructs a new instance of PropertyValue with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("name" in values && values.name != null) {
            if (typeof values.name === "string" || values.name instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
            }
            else {
                throw new TypeError("The name must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("value" in values && values.value != null) {
            if (typeof values.value === "string" ||
                values.value instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [values.value];
            }
            else {
                throw new TypeError("The value must be of type " +
                    "string | LanguageString" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name =
            this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        if ("name" in values && values.name != null) {
            if (typeof values.name === "string" || values.name instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
            }
            else {
                throw new TypeError("The name must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value =
            this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value;
        if ("value" in values && values.value != null) {
            if (typeof values.value === "string" ||
                values.value instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [values.value];
            }
            else {
                throw new TypeError("The value must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        return clone;
    }
    /** The name of a property.
     */
    get name() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length < 1)
            return null;
        return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
    }
    /** The value of a property.
     */
    get value() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.length < 1)
            return null;
        return this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = {};
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["name"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["value"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "PropertyValue";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = ["https://www.w3.org/ns/activitystreams", {
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                }];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#name"] = propValue;
        }
        array = [];
        for (const v of this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://schema.org#value"] = propValue;
        }
        values["@type"] = ["http://schema.org#PropertyValue"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            ["https://www.w3.org/ns/activitystreams", {
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                }];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name != null &&
            this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0)
            return false;
        if (this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value != null &&
            this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.length > 0)
            return false;
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__PropertyValue__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__PropertyValue__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("http://schema.org#PropertyValue")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
        let _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array = values["https://www.w3.org/ns/activitystreams#name"];
        for (const v of _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array == null
            ? []
            : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array.length === 1 &&
                "@list" in _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]
                ? _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]["@list"]
                : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.push(decoded);
        }
        instance.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name =
            _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        const _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [];
        let _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array = values["http://schema.org#value"];
        for (const v of _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array == null
            ? []
            : _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array.length === 1 &&
                "@list" in _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array[0]
                ? _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array[0]["@list"]
                : _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.push(decoded);
        }
        instance.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value =
            _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this
            .#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length == 1) {
            proxy.name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
        }
        const _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = this
            .#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.length == 1) {
            proxy.value = _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "PropertyValue " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "PropertyValue " + inspect(proxy, options);
    }
}
/** Means of communicating or interacting with the DID subject or associated
 * entities via one or more service endpoints. Examples include discovery
 * services, agent services, social networking services, file storage services,
 * and verifiable credential repository services.
 */
export class DidService {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link DidService}: `https://www.w3.org/ns/did#Service`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/did#Service");
    }
    #_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [];
    /**
     * Constructs a new instance of DidService with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("endpoint" in values && values.endpoint != null) {
            if (values.endpoint instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [values.endpoint];
            }
            else {
                throw new TypeError("The endpoint must be of type " +
                    "URL" + ".");
            }
        }
        if ("endpoints" in values && values.endpoints != null) {
            if ("endpoint" in values &&
                values.endpoint != null) {
                throw new TypeError("Cannot initialize both endpoint and " +
                    "endpoints at the same time.");
            }
            if (Array.isArray(values.endpoints) &&
                values.endpoints.every((v) => v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = values.endpoints;
            }
            else {
                throw new TypeError("The endpoints must be an array of type " +
                    "URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint =
            this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
        if ("endpoint" in values && values.endpoint != null) {
            if (values.endpoint instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [
                    values.endpoint,
                ];
            }
            else {
                throw new TypeError("The endpoint must be of type " +
                    "URL" + ".");
            }
        }
        if ("endpoints" in values && values.endpoints != null) {
            if ("endpoint" in values &&
                values.endpoint != null) {
                throw new TypeError("Cannot update both endpoint and " +
                    "endpoints at the same time.");
            }
            if (Array.isArray(values.endpoints) &&
                values.endpoints.every((v) => v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = values.endpoints;
            }
            else {
                throw new TypeError("The endpoints must be an array of type " +
                    "URL" + ".");
            }
        }
        return clone;
    }
    /** A network address, such as an HTTP URL, at which services operate on behalf
     * of a DID subject.
     */
    get endpoint() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length < 1) {
            return null;
        }
        return this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint[0];
    }
    /** A network address, such as an HTTP URL, at which services operate on behalf
     * of a DID subject.
     */
    get endpoints() {
        return this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/did#serviceEndpoint"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/did#Service"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://www.w3.org/ns/did/v1";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__DidService__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__DidService__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://w3id.org/fep/9091#Export")) {
                return await Export.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/did#Service")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [];
        let _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array = values["https://www.w3.org/ns/did#serviceEndpoint"];
        for (const v of _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array == null
            ? []
            : _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array.length === 1 &&
                "@list" in _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array[0]
                ? _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array[0]["@list"]
                : _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array) {
            if (v == null)
                continue;
            _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.push(new URL(v["@id"]));
        }
        instance.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint =
            _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = this
            .#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length == 1) {
            proxy.endpoint = _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint[0];
        }
        if (_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length > 1 ||
            !("endpoint" in proxy) &&
                _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length > 0) {
            proxy.endpoints = _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "DidService " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "DidService " + inspect(proxy, options);
    }
}
/** "Export Actor" service.
 */
export class Export extends DidService {
    /**
     * The type URI of {@link Export}: `https://w3id.org/fep/9091#Export`.
     */
    static get typeId() {
        return new URL("https://w3id.org/fep/9091#Export");
    }
    /**
     * Constructs a new instance of Export with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://w3id.org/fep/9091#Export"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://www.w3.org/ns/did/v1";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Export__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Export__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://w3id.org/fep/9091#Export")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Export)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Export " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Export " + inspect(proxy, options);
    }
}
/** A proof that can be added to any activity or object, allowing recipients to
 * verify the identity of the actor and the integrity of the data.
 */
export class DataIntegrityProof {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link DataIntegrityProof}: `https://w3id.org/security#DataIntegrityProof`.
     */
    static get typeId() {
        return new URL("https://w3id.org/security#DataIntegrityProof");
    }
    #_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [];
    #_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [];
    #_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [];
    #_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [];
    #_3qzP3ukEZoUziK5FEiA1RhU4aqac = [];
    /**
     * Constructs a new instance of DataIntegrityProof with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("cryptosuite" in values && values.cryptosuite != null) {
            if (values.cryptosuite == "eddsa-jcs-2022") {
                // @ts-ignore: type is checked above.
                this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [values.cryptosuite];
            }
            else {
                throw new TypeError("The cryptosuite must be of type " +
                    '"eddsa-jcs-2022"' + ".");
            }
        }
        if ("verificationMethod" in values && values.verificationMethod != null) {
            if (values.verificationMethod instanceof Multikey ||
                values.verificationMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [
                    values.verificationMethod,
                ];
            }
            else {
                throw new TypeError("The verificationMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("proofPurpose" in values && values.proofPurpose != null) {
            if (values.proofPurpose === "assertionMethod" ||
                values.proofPurpose === "authentication" ||
                values.proofPurpose === "capabilityInvocation" ||
                values.proofPurpose === "capabilityDelegation" ||
                values.proofPurpose === "keyAgreement") {
                // @ts-ignore: type is checked above.
                this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [
                    values.proofPurpose,
                ];
            }
            else {
                throw new TypeError("The proofPurpose must be of type " +
                    '"assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement"' +
                    ".");
            }
        }
        if ("proofValue" in values && values.proofValue != null) {
            if (values.proofValue instanceof Uint8Array) {
                // @ts-ignore: type is checked above.
                this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [values.proofValue];
            }
            else {
                throw new TypeError("The proofValue must be of type " +
                    "Uint8Array" + ".");
            }
        }
        if ("created" in values && values.created != null) {
            if (values.created instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = [values.created];
            }
            else {
                throw new TypeError("The created must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite =
            this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite;
        if ("cryptosuite" in values && values.cryptosuite != null) {
            if (values.cryptosuite == "eddsa-jcs-2022") {
                // @ts-ignore: type is checked above.
                clone.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [values.cryptosuite];
            }
            else {
                throw new TypeError("The cryptosuite must be of type " +
                    '"eddsa-jcs-2022"' + ".");
            }
        }
        clone.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod =
            this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod;
        if ("verificationMethod" in values && values.verificationMethod != null) {
            if (values.verificationMethod instanceof Multikey ||
                values.verificationMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [
                    values.verificationMethod,
                ];
            }
            else {
                throw new TypeError("The verificationMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        clone.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose =
            this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose;
        if ("proofPurpose" in values && values.proofPurpose != null) {
            if (values.proofPurpose === "assertionMethod" ||
                values.proofPurpose === "authentication" ||
                values.proofPurpose === "capabilityInvocation" ||
                values.proofPurpose === "capabilityDelegation" ||
                values.proofPurpose === "keyAgreement") {
                // @ts-ignore: type is checked above.
                clone.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [
                    values.proofPurpose,
                ];
            }
            else {
                throw new TypeError("The proofPurpose must be of type " +
                    '"assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement"' +
                    ".");
            }
        }
        clone.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue =
            this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue;
        if ("proofValue" in values && values.proofValue != null) {
            if (values.proofValue instanceof Uint8Array) {
                // @ts-ignore: type is checked above.
                clone.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [values.proofValue];
            }
            else {
                throw new TypeError("The proofValue must be of type " +
                    "Uint8Array" + ".");
            }
        }
        clone.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac;
        if ("created" in values && values.created != null) {
            if (values.created instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                clone.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = [values.created];
            }
            else {
                throw new TypeError("The created must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        return clone;
    }
    /** The cryptographic suite used to create the proof.
     */
    get cryptosuite() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite.length < 1)
            return null;
        return this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite[0];
    }
    async #fetchVerificationMethod(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#verificationMethod_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #verificationMethod_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Multikey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Multikey"].join(", "));
    }
    /**
     * Similar to
     * {@link DataIntegrityProof.getVerificationMethod},
     * but returns its `@id` URL instead of the object itself.
     */
    get verificationMethodId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.length < 1) {
            return null;
        }
        const v = this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** A key owned by an actor according to [FEP-521a: Representing actor's public
     * keys][1].
     *
     * [1]: https://w3id.org/fep/521a
     */
    async getVerificationMethod(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.length < 1) {
            return null;
        }
        const v = this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchVerificationMethod(v, options);
            if (fetched == null)
                return null;
            this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        return v;
    }
    /** The reason the proof was created.
     *
     * - `"assertionMethod"`
     * - `"authentication"`
     * - `"capabilityInvocation"`
     * - `"capabilityDelegation"`
     * - `"keyAgreement"`
     */
    get proofPurpose() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose.length < 1) {
            return null;
        }
        return this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose[0];
    }
    /** The proof value.
     */
    get proofValue() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue.length < 1)
            return null;
        return this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue[0];
    }
    /** The date and time the proof was created.
     */
    get created() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac.length < 1)
            return null;
        return this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#cryptosuite"] = propValue;
        }
        array = [];
        for (const v of this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#verificationMethod"] = propValue;
        }
        array = [];
        for (const v of this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose) {
            const element = {
                "@id": "https://w3id.org/security#" + v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#proofPurpose"] = propValue;
        }
        array = [];
        for (const v of this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue) {
            const element = {
                "@type": "https://w3id.org/security#multibase",
                "@value": new TextDecoder().decode(encodeMultibase("base58btc", v)),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#proofValue"] = propValue;
        }
        array = [];
        for (const v of this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                "@value": v.toString(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://purl.org/dc/terms/created"] = propValue;
        }
        values["@type"] = ["https://w3id.org/security#DataIntegrityProof"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://w3id.org/security/data-integrity/v1";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__DataIntegrityProof__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__DataIntegrityProof__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://w3id.org/security#DataIntegrityProof")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [];
        let _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array = values["https://w3id.org/security#cryptosuite"];
        for (const v of _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array == null
            ? []
            : _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array.length === 1 &&
                "@list" in _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array[0]
                ? _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array[0]["@list"]
                : _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array) {
            if (v == null)
                continue;
            _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite.push(v["@value"]);
        }
        instance.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite =
            _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite;
        const _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [];
        let _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array = values["https://w3id.org/security#verificationMethod"];
        for (const v of _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array == null
            ? []
            : _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array.length ===
                1 &&
                "@list" in
                    _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array[0]
                ? _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array[0]["@list"]
                : _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.push(await Multikey.fromJsonLd(v, options));
        }
        instance.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod =
            _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod;
        const _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [];
        let _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array = values["https://w3id.org/security#proofPurpose"];
        for (const v of _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array == null
            ? []
            : _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array.length === 1 &&
                "@list" in _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array[0]
                ? _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array[0]["@list"]
                : _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array) {
            if (v == null)
                continue;
            _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose.push(v["@id"].substring(26));
        }
        instance.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose =
            _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose;
        const _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [];
        let _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array = values["https://w3id.org/security#proofValue"];
        for (const v of _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array == null
            ? []
            : _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array.length === 1 &&
                "@list" in _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array[0]
                ? _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array[0]["@list"]
                : _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array) {
            if (v == null)
                continue;
            _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue.push(decodeMultibase(v["@value"]));
        }
        instance.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue =
            _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue;
        const _3qzP3ukEZoUziK5FEiA1RhU4aqac = [];
        let _3qzP3ukEZoUziK5FEiA1RhU4aqac__array = values["http://purl.org/dc/terms/created"];
        for (const v of _3qzP3ukEZoUziK5FEiA1RhU4aqac__array == null
            ? []
            : _3qzP3ukEZoUziK5FEiA1RhU4aqac__array.length === 1 &&
                "@list" in _3qzP3ukEZoUziK5FEiA1RhU4aqac__array[0]
                ? _3qzP3ukEZoUziK5FEiA1RhU4aqac__array[0]["@list"]
                : _3qzP3ukEZoUziK5FEiA1RhU4aqac__array) {
            if (v == null)
                continue;
            _3qzP3ukEZoUziK5FEiA1RhU4aqac.push(dntShim.Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/)
                ? v["@value"]
                : v["@value"] + "Z"));
        }
        instance.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = _3qzP3ukEZoUziK5FEiA1RhU4aqac;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = this
            .#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite.length == 1) {
            proxy.cryptosuite = _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite[0];
        }
        const _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = this
            .#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.length == 1) {
            proxy.verificationMethod =
                _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0];
        }
        const _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = this
            .#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose.length == 1) {
            proxy.proofPurpose = _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose[0];
        }
        const _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = this
            .#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue.length == 1) {
            proxy.proofValue = _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue[0];
        }
        const _3qzP3ukEZoUziK5FEiA1RhU4aqac = this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3qzP3ukEZoUziK5FEiA1RhU4aqac.length == 1) {
            proxy.created = _3qzP3ukEZoUziK5FEiA1RhU4aqac[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "DataIntegrityProof " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "DataIntegrityProof " + inspect(proxy, options);
    }
}
/** A key owned by an actor.
 */
export class CryptographicKey {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link CryptographicKey}: `https://w3id.org/security#Key`.
     */
    static get typeId() {
        return new URL("https://w3id.org/security#Key");
    }
    #_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [];
    #_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [];
    /**
     * Constructs a new instance of CryptographicKey with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("owner" in values && values.owner != null) {
            if (values.owner instanceof Application || values.owner instanceof Group ||
                values.owner instanceof Organization ||
                values.owner instanceof Person || values.owner instanceof Service ||
                values.owner instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [values.owner];
            }
            else {
                throw new TypeError("The owner must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("publicKey" in values && values.publicKey != null) {
            if (
            // @ts-ignore: CryptoKey exists in the global scope.
            // dnt-shim-ignore
            values.publicKey instanceof CryptoKey) {
                // @ts-ignore: type is checked above.
                this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptoKey" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner =
            this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner;
        if ("owner" in values && values.owner != null) {
            if (values.owner instanceof Application || values.owner instanceof Group ||
                values.owner instanceof Organization ||
                values.owner instanceof Person || values.owner instanceof Service ||
                values.owner instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [values.owner];
            }
            else {
                throw new TypeError("The owner must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem =
            this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem;
        if ("publicKey" in values && values.publicKey != null) {
            if (
            // @ts-ignore: CryptoKey exists in the global scope.
            // dnt-shim-ignore
            values.publicKey instanceof CryptoKey) {
                // @ts-ignore: type is checked above.
                clone.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptoKey" + ".");
            }
        }
        return clone;
    }
    async #fetchOwner(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#owner_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #owner_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link CryptographicKey.getOwner},
     * but returns its `@id` URL instead of the object itself.
     */
    get ownerId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.length < 1)
            return null;
        const v = this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** An actor who owns this key.
     */
    async getOwner(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.length < 1)
            return null;
        const v = this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchOwner(v, options);
            if (fetched == null)
                return null;
            this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "owner" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["owner"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#owner_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /** A PEM-encoded public key.
     */
    get publicKey() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem.length < 1) {
            return null;
        }
        return this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = {};
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["owner"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem) {
                const item = await exportSpki(v);
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["publicKeyPem"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "CryptographicKey";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = "https://w3id.org/security/v1";
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#owner"] = propValue;
        }
        array = [];
        for (const v of this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem) {
            const element = { "@value": await exportSpki(v) };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#publicKeyPem"] = propValue;
        }
        values["@type"] = ["https://w3id.org/security#Key"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://w3id.org/security/v1";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__CryptographicKey__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__CryptographicKey__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://w3id.org/security#Key")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [];
        let _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array = values["https://w3id.org/security#owner"];
        for (const v of _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array == null
            ? []
            : _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array.length === 1 &&
                "@list" in _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array[0]
                ? _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array[0]["@list"]
                : _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.push(decoded);
        }
        instance.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner =
            _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner;
        const _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [];
        let _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array = values["https://w3id.org/security#publicKeyPem"];
        for (const v of _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array == null
            ? []
            : _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array.length === 1 &&
                "@list" in _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array[0]
                ? _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array[0]["@list"]
                : _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array) {
            if (v == null)
                continue;
            _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem.push(await importPem(v["@value"]));
        }
        instance.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem =
            _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = this
            .#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.length == 1) {
            proxy.owner = _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0];
        }
        const _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = this
            .#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem.length == 1) {
            proxy.publicKey = _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "CryptographicKey " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "CryptographicKey " + inspect(proxy, options);
    }
}
/** Represents a key owned by an actor according to [FEP-521a: Representing
 * actor's public keys.][1]
 *
 * [1]: https://w3id.org/fep/521a
 */
export class Multikey {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link Multikey}: `https://w3id.org/security#Multikey`.
     */
    static get typeId() {
        return new URL("https://w3id.org/security#Multikey");
    }
    #_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [];
    #_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [];
    /**
     * Constructs a new instance of Multikey with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("controller" in values && values.controller != null) {
            if (values.controller instanceof Application ||
                values.controller instanceof Group ||
                values.controller instanceof Organization ||
                values.controller instanceof Person ||
                values.controller instanceof Service || values.controller instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [values.controller];
            }
            else {
                throw new TypeError("The controller must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("publicKey" in values && values.publicKey != null) {
            if (
            // @ts-ignore: CryptoKey exists in the global scope.
            // dnt-shim-ignore
            values.publicKey instanceof CryptoKey) {
                // @ts-ignore: type is checked above.
                this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [
                    values.publicKey,
                ];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptoKey" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller =
            this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller;
        if ("controller" in values && values.controller != null) {
            if (values.controller instanceof Application ||
                values.controller instanceof Group ||
                values.controller instanceof Organization ||
                values.controller instanceof Person ||
                values.controller instanceof Service || values.controller instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [values.controller];
            }
            else {
                throw new TypeError("The controller must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase =
            this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase;
        if ("publicKey" in values && values.publicKey != null) {
            if (
            // @ts-ignore: CryptoKey exists in the global scope.
            // dnt-shim-ignore
            values.publicKey instanceof CryptoKey) {
                // @ts-ignore: type is checked above.
                clone.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [
                    values.publicKey,
                ];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptoKey" + ".");
            }
        }
        return clone;
    }
    async #fetchController(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#controller_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #controller_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Multikey.getController},
     * but returns its `@id` URL instead of the object itself.
     */
    get controllerId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.length < 1)
            return null;
        const v = this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** An actor who owns this key.
     */
    async getController(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.length < 1)
            return null;
        const v = this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchController(v, options);
            if (fetched == null)
                return null;
            this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "controller" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["controller"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#controller_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /** A [Multibase]-encoded value of a [Multicodec] prefix and the key.
     *
     * [Multibase]: https://www.w3.org/TR/vc-data-integrity/#multibase-0
     * [Multicodec]: https://github.com/multiformats/multicodec/
     */
    get publicKey() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase.length < 1) {
            return null;
        }
        return this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = {};
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["controller"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase) {
                const item = await exportMultibaseKey(v);
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["publicKeyMultibase"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Multikey";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = "https://w3id.org/security/multikey/v1";
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#controller"] = propValue;
        }
        array = [];
        for (const v of this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase) {
            const element = {
                "@type": "https://w3id.org/security#multibase",
                "@value": await exportMultibaseKey(v),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#publicKeyMultibase"] = propValue;
        }
        values["@type"] = ["https://w3id.org/security#Multikey"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://w3id.org/security/multikey/v1";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Multikey__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Multikey__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://w3id.org/security#Multikey")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [];
        let _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array = values["https://w3id.org/security#controller"];
        for (const v of _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array == null
            ? []
            : _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array.length === 1 &&
                "@list" in _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array[0]
                ? _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array[0]["@list"]
                : _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.push(decoded);
        }
        instance.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller =
            _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller;
        const _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [];
        let _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array = values["https://w3id.org/security#publicKeyMultibase"];
        for (const v of _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array == null
            ? []
            : _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array.length ===
                1 &&
                "@list" in
                    _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array[0]
                ? _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array[0]["@list"]
                : _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array) {
            if (v == null)
                continue;
            _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase.push(await importMultibaseKey(v["@value"]));
        }
        instance.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase =
            _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = this
            .#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.length == 1) {
            proxy.controller = _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0];
        }
        const _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = this
            .#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase.length == 1) {
            proxy.publicKey = _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Multikey " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Multikey " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` accepts the `object`.  The `target` property can be
 * used in certain circumstances to indicate the context into which the `object`
 * has been accepted.
 */
export class Accept extends Activity {
    /**
     * The type URI of {@link Accept}: `https://www.w3.org/ns/activitystreams#Accept`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Accept");
    }
    /**
     * Constructs a new instance of Accept with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Accept"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Accept__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Accept__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) {
                return await TentativeAccept.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Accept")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Accept)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Accept " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Accept " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has added the `object` to the `target`.
 * If the `target` property is not explicitly specified, the target would need
 * to be determined implicitly by context.  The `origin` can be used to identify
 * the context from which the `object` originated.
 */
export class Add extends Activity {
    /**
     * The type URI of {@link Add}: `https://www.w3.org/ns/activitystreams#Add`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Add");
    }
    /**
     * Constructs a new instance of Add with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Add"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Add__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Add__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Add")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Add)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Add " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Add " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is calling the `target`'s attention the `object`.
 *
 * The `origin` typically has no defined meaning.
 */
export class Announce extends Activity {
    /**
     * The type URI of {@link Announce}: `https://www.w3.org/ns/activitystreams#Announce`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Announce");
    }
    /**
     * Constructs a new instance of Announce with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Announce"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Announce__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Announce__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Announce")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Announce)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Announce " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Announce " + inspect(proxy, options);
    }
}
/** Describes a software application.
 */
export class Application extends Object {
    /**
     * The type URI of {@link Application}: `https://www.w3.org/ns/activitystreams#Application`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Application");
    }
    #_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
    #_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
    #_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
    #_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
    #_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
    #_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
    #_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
    #_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
    #_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
    #_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
    #_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
    #_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
    #_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
    #_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
    #_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
    #_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
    #_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
    #_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
    #_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
    #_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
    #_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
    #_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
    /**
     * Constructs a new instance of Application with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot initialize both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot initialize both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot initialize both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof _b ||
                values.successor instanceof Group ||
                values.successor instanceof Organization ||
                values.successor instanceof Person ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof _b || values.alias instanceof Group ||
                values.alias instanceof Organization ||
                values.alias instanceof Person || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot initialize both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof _b || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot initialize both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot update both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot update both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot update both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [
                    values.discoverable,
                ];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof _b ||
                values.successor instanceof Group ||
                values.successor instanceof Organization ||
                values.successor instanceof Person ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof _b || values.alias instanceof Group ||
                values.alias instanceof Organization ||
                values.alias instanceof Person || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot update both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof _b || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot update both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
        return clone;
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsername() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) {
            return null;
        }
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsernames() {
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
    }
    async #fetchPublicKey(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#publicKey_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #publicKey_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CryptographicKey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Key"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getPublicKey},
     * but returns its `@id` URL instead of the object itself.
     */
    get publicKeyId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** A public part of the key pair owned by this actor.
     */
    async getPublicKey(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPublicKey(v, options);
            if (fetched == null)
                return null;
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "publicKey" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["publicKey"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#publicKey_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Application.getPublicKeys},
     * but returns their `@id`s instead of the objects themselves.
     */
    get publicKeyIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A public part of the key pair owned by this actor.
     */
    async *getPublicKeys(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchPublicKey(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "publicKey" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["publicKey"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#publicKey_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchAssertionMethod(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#assertionMethod_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #assertionMethod_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Multikey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Multikey"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getAssertionMethod},
     * but returns its `@id` URL instead of the object itself.
     */
    get assertionMethodId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async getAssertionMethod(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAssertionMethod(v, options);
            if (fetched == null)
                return null;
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "assertionMethod" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["assertionMethod"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#assertionMethod_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Application.getAssertionMethods},
     * but returns their `@id`s instead of the objects themselves.
     */
    get assertionMethodIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async *getAssertionMethods(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAssertionMethod(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "assertionMethod" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["assertionMethod"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#assertionMethod_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** When `true`, conveys that for this actor, follow requests are not usually
     * automatically approved, but instead are examined by a person who may accept
     * or reject the request, at some time in the future.  Setting of `false`
     * conveys no information and may be ignored.  This information is typically
     * used to affect display of accounts, such as showing an account as private or
     * locked.
     */
    get manuallyApprovesFollowers() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1)
            return null;
        return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
    }
    async #fetchInbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#inbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #inbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getInbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get inboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The inbox stream contains all activities received by the actor.  The server
     * SHOULD filter content according to the requester's permission.  In general,
     * the owner of an inbox is likely to be able to access all of their inbox
     * contents.  Depending on access control, some other content may be public,
     * whereas other content may require authentication for non-owner users,
     * if they can access the inbox at all.
     *
     * The server MUST perform de-duplication of activities returned by the inbox.
     * Duplication can occur if an activity is addressed both to an actor's
     * followers, and a specific actor who also follows the recipient actor,
     * and the server has failed to de-duplicate the recipients list.
     * Such deduplication MUST be performed by comparing the `id` of the activities
     * and dropping any activities already seen.
     */
    async getInbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchInbox(v, options);
            if (fetched == null)
                return null;
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "inbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["inbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#inbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchOutbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#outbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #outbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getOutbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get outboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The outbox stream contains activities the user has published,
     * subject to the ability of the requestor to retrieve the activity
     * (that is, the contents of the outbox are filtered by the permissions of
     * the person reading it).  If a user submits a request without
     * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
     * the server should respond with all of the
     * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
     * This could potentially be all relevant objects published by the user,
     * though the number of available items is left to the discretion of those
     * implementing and deploying the server.
     */
    async getOutbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchOutbox(v, options);
            if (fetched == null)
                return null;
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "outbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["outbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#outbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowing(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#following_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #following_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getFollowing},
     * but returns its `@id` URL instead of the object itself.
     */
    get followingId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everybody that the actor has followed, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * The `following` collection MUST be either an {@link OrderedCollection}
     * or a {@link Collection} and MAY be filtered on privileges of
     * an authenticated user or as appropriate when no authentication is given.
     */
    async getFollowing(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowing(v, options);
            if (fetched == null)
                return null;
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "following" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["following"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#following_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowers(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#followers_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #followers_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getFollowers},
     * but returns its `@id` URL instead of the object itself.
     */
    get followersId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everyone who has sent a {@link Follow} activity
     * for the actor, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * This is where one would find a list of all the actors that are following
     * the actor.  The `followers` collection MUST be either
     * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
     * privileges of an authenticated user or as appropriate when no authentication
     * is given.
     */
    async getFollowers(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowers(v, options);
            if (fetched == null)
                return null;
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "followers" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["followers"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#followers_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchLiked(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#liked_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #liked_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getLiked},
     * but returns its `@id` URL instead of the object itself.
     */
    get likedId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of every object from all of the actor's {@link Like}
     * activities, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
     * The `liked` collection MUST be either an {@link OrderedCollection} or
     * a {@link Collection} and MAY be filtered on privileges of an authenticated
     * user or as appropriate when no authentication is given.
     */
    async getLiked(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLiked(v, options);
            if (fetched == null)
                return null;
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "liked" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["liked"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#liked_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeatured(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featured_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featured_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getFeatured},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "pinned statuses", or statuses that are always
     * featured at the top of people's profiles, is implemented using an extra
     * property `featured` on the actor object that points to a {@link Collection}
     * of objects.
     */
    async getFeatured(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeatured(v, options);
            if (fetched == null)
                return null;
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featured" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featured"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featured_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeaturedTags(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featuredTags_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featuredTags_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getFeaturedTags},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredTagsId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "featured hashtags", hashtags that are featured
     * at people's profiles, is implemented using an extra property `featuredTags`
     * on the actor object that points to a {@link Collection} of {@link Hashtag}
     * objects specifically.
     */
    async getFeaturedTags(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeaturedTags(v, options);
            if (fetched == null)
                return null;
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featuredTags" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featuredTags"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featuredTags_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchStream(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#stream_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #stream_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getStreams},
     * but returns their `@id`s instead of the objects themselves.
     */
    get streamIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A list of supplementary Collections which may be of interest.
     */
    async *getStreams(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchStream(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "streams" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["streams"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#stream_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** A JSON object which maps additional (typically server/domain-wide) endpoints
     * which may be useful either for this actor or someone referencing this actor.
     * This mapping may be nested inside the actor document as the value or may be
     * a link to a JSON-LD document with these properties.
     */
    get endpoints() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1)
            return null;
        return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
    }
    /** Allows users to opt-in or opt-out of discoverability features like
     * the profile directory.  This flag may also be used as an indicator of
     * the user's preferences toward being included in external discovery services,
     * such as search engines or other indexing tools.
     */
    get discoverable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1)
            return null;
        return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
    }
    /** Reports whether a user was locally suspended, for better handling of
     * these accounts.
     */
    get suspended() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1)
            return null;
        return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
    }
    /** Whether the actor is in-memorial state.
     */
    get memorial() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1)
            return null;
        return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
    }
    /** Whether the actor allows to be indexed.
     */
    get indexable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1)
            return null;
        return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
    }
    async #fetchSuccessor(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#successor_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #successor_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _b.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getSuccessor},
     * but returns its `@id` URL instead of the object itself.
     */
    get successorId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
     */
    async getSuccessor(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchSuccessor(v, options);
            if (fetched == null)
                return null;
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "movedTo" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["movedTo"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#successor_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchAlias(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#alias_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #alias_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _b.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getAlias},
     * but returns its `@id` URL instead of the object itself.
     */
    get aliasId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async getAlias(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAlias(v, options);
            if (fetched == null)
                return null;
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "alsoKnownAs" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["alsoKnownAs"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#alias_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Application.getAliases},
     * but returns their `@id`s instead of the objects themselves.
     */
    get aliasIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async *getAliases(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAlias(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "alsoKnownAs" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["alsoKnownAs"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#alias_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchService(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#service_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #service_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await DidService.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/did#Service"].join(", "));
    }
    /**
     * Similar to
     * {@link Application.getService},
     * but returns its `@id` URL instead of the object itself.
     */
    get serviceId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async getService(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchService(v, options);
            if (fetched == null)
                return null;
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "service" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["service"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#service_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Application.getServices},
     * but returns their `@id`s instead of the objects themselves.
     */
    get serviceIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async *getServices(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchService(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "service" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["service"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#service_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** This value is used for `Actor` type objects to show message on followed.
     */
    get followedMessage() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1)
            return null;
        return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
    }
    /** Used on actors to indicate that they in some way identify as a cat,
     * expressed as a boolean value. If this property is set to `true`,
     * displaying the actor or their notes will have some special effects
     * attached in some clients.
     */
    get cat() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1)
            return null;
        return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["preferredUsername"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["publicKey"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["assertionMethod"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["manuallyApprovesFollowers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["inbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["outbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["following"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["followers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["liked"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featured"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featuredTags"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["streams"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
                const item = await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["endpoints"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["discoverable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["suspended"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["memorial"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["indexable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _b
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["movedTo"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _b
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["alsoKnownAs"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["service"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["_misskey_followedMessage"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["isCat"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Application";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#preferredUsername"] =
                propValue;
        }
        array = [];
        for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#publicKey"] = propValue;
        }
        array = [];
        for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#assertionMethod"] = propValue;
        }
        array = [];
        for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
        }
        array = [];
        for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://www.w3.org/ns/ldp#inbox"] = propValue;
        }
        array = [];
        for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
        }
        array = [];
        for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#following"] = propValue;
        }
        array = [];
        for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
        }
        array = [];
        for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
        }
        array = [];
        for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featured"] = propValue;
        }
        array = [];
        for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featuredTags"] = propValue;
        }
        array = [];
        for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
        }
        array = [];
        for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
            const element = await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
        }
        array = [];
        for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#discoverable"] = propValue;
        }
        array = [];
        for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#suspended"] = propValue;
        }
        array = [];
        for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#memorial"] = propValue;
        }
        array = [];
        for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#indexable"] = propValue;
        }
        array = [];
        for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _b
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
        }
        array = [];
        for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _b
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
        }
        array = [];
        for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/did#service"] = propValue;
        }
        array = [];
        for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
        }
        array = [];
        for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#isCat"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Application"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null &&
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0)
            return false;
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null &&
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0)
            return false;
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Application__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Application__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Application")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof _b)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
        let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
        for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null
            ? []
            : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 &&
                "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]
                ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"]
                : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
        }
        instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
        let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
        for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null
            ? []
            : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 &&
                "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]
                ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"]
                : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, options));
        }
        instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
        let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
        for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null
            ? []
            : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 &&
                "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]
                ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"]
                : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, options));
        }
        instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
        let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
        for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null
            ? []
            : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array
                .length === 1 &&
                "@list" in
                    _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]
                ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"]
                : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
            if (v == null)
                continue;
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
        }
        instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
        let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
        for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null
            ? []
            : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 &&
                "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]
                ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"]
                : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
        }
        instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
        let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
        for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null
            ? []
            : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 &&
                "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]
                ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"]
                : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
        }
        instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            _41QwhqJouoLg3h8dRPKat21brynC_outbox;
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
        let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
        for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null
            ? []
            : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 &&
                "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]
                ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"]
                : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
        let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
        for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null
            ? []
            : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 &&
                "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]
                ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"]
                : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
        let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
        for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null
            ? []
            : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 &&
                "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]
                ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"]
                : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
        let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
        for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null
            ? []
            : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 &&
                "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]
                ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"]
                : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
        let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
        for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null
            ? []
            : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 &&
                "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]
                ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"]
                : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
        let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
        for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null
            ? []
            : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 &&
                "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]
                ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"]
                : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
        let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
        for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null
            ? []
            : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 &&
                "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]
                ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"]
                : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
            if (v == null)
                continue;
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, options));
        }
        instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
        let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
        for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null
            ? []
            : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 &&
                "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]
                ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"]
                : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
            if (v == null)
                continue;
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
        }
        instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
        let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
        for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null
            ? []
            : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 &&
                "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]
                ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"]
                : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
            if (v == null)
                continue;
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
        }
        instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
        let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
        for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null
            ? []
            : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 &&
                "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]
                ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"]
                : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
            if (v == null)
                continue;
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
        }
        instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
        let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
        for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null
            ? []
            : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 &&
                "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]
                ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"]
                : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
            if (v == null)
                continue;
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
        }
        instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
        let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
        for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null
            ? []
            : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 &&
                "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]
                ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"]
                : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await _b.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
        }
        instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
        let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
        for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null
            ? []
            : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 &&
                "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]
                ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"]
                : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await _b.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
        }
        instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
        let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
        for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null
            ? []
            : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 &&
                "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]
                ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"]
                : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, options));
        }
        instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
        let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
        for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null
            ? []
            : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array
                .length === 1 &&
                "@list" in
                    _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]
                ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"]
                : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
            if (v == null)
                continue;
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
        }
        instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
        let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
        for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null
            ? []
            : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 &&
                "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]
                ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"]
                : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
            if (v == null)
                continue;
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
        }
        instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this
            .#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) {
            proxy.preferredUsername =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
        }
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 ||
            !("preferredUsername" in proxy) &&
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) {
            proxy.preferredUsernames =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        }
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this
            .#_axq166E2eZADq34V4MYUc8KMZdC_publicKey
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) {
            proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        }
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 ||
            !("publicKey" in proxy) &&
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) {
            proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        }
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this
            .#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) {
            proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        }
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 ||
            !("assertionMethod" in proxy) &&
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) {
            proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        }
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this
            .#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) {
            proxy.manuallyApprovesFollowers =
                _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
        }
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this
            .#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) {
            proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        }
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this
            .#_41QwhqJouoLg3h8dRPKat21brynC_outbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) {
            proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        }
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this
            .#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) {
            proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        }
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this
            .#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) {
            proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        }
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this
            .#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) {
            proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        }
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this
            .#_4N1vBJzXDf8NbBumeECQMFvKetja_featured
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) {
            proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        }
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this
            .#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) {
            proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        }
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this
            .#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 ||
            !("stream" in proxy) &&
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) {
            proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        }
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this
            .#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) {
            proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
        }
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this
            .#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) {
            proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
        }
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this
            .#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) {
            proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
        }
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this
            .#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) {
            proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
        }
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this
            .#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) {
            proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
        }
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this
            .#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) {
            proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        }
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this
            .#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) {
            proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        }
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 ||
            !("alias" in proxy) &&
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) {
            proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        }
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this
            .#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) {
            proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        }
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 ||
            !("service" in proxy) &&
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) {
            proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        }
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this
            .#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) {
            proxy.followedMessage =
                _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
        }
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this
            .#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) {
            proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Application " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Application " + inspect(proxy, options);
    }
}
_b = Application;
/** Instances of `IntransitiveActivity` are a subtype of {@link Activity}
 * representing intransitive actions.  The `object` property is therefore
 * inappropriate for these activities.
 */
export class IntransitiveActivity extends Activity {
    /**
     * The type URI of {@link IntransitiveActivity}: `https://www.w3.org/ns/activitystreams#IntransitiveActivity`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#IntransitiveActivity");
    }
    /**
     * Constructs a new instance of IntransitiveActivity with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = [
            "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
        ];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__IntransitiveActivity__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__IntransitiveActivity__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) {
                return await Arrive.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) {
                return await Question.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) {
                return await Travel.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#IntransitiveActivity")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof IntransitiveActivity)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "IntransitiveActivity " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "IntransitiveActivity " + inspect(proxy, options);
    }
}
/** An `IntransitiveActivity` that indicates that the `actor` has arrived at the `location`.
 * The `origin` can be used to identify the context from which the `actor` originated.
 * The `target` typically has no defined meaning.
 */
export class Arrive extends IntransitiveActivity {
    /**
     * The type URI of {@link Arrive}: `https://www.w3.org/ns/activitystreams#Arrive`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Arrive");
    }
    /**
     * Constructs a new instance of Arrive with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Arrive"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Arrive__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Arrive__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Arrive)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Arrive " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Arrive " + inspect(proxy, options);
    }
}
/** Represents any kind of multi-paragraph written work.
 */
export class Article extends Object {
    /**
     * The type URI of {@link Article}: `https://www.w3.org/ns/activitystreams#Article`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Article");
    }
    #_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
    /**
     * Constructs a new instance of Article with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
        return clone;
    }
    /** The URI of the ActivityStreams object that this object quotes.
     *
     * This property sets three JSON-LD properties at once under the hood:
     *
     * 1. https://www.w3.org/ns/activitystreams#quoteUrl
     * 2. https://misskey-hub.net/ns#_misskey_quote
     * 3. http://fedibird.com/ns#quoteUri
     *
     * When a JSON-LD object is parsed, this property is filled with one of
     * the values of those three properties in order.
     */
    get quoteUrl() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1)
            return null;
        return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["quoteUrl"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
                result["_misskey_quote"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
                result["quoteUri"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Article";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
            const element = { "@value": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
            values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
            values["http://fedibird.com/ns#quoteUri"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Article"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Article__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Article__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Article")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Article)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
        let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["https://misskey-hub.net/ns#_misskey_quote"];
        }
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["http://fedibird.com/ns#quoteUri"];
        }
        for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null
            ? []
            : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 &&
                "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]
                ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"]
                : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
            if (v == null)
                continue;
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
        }
        instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this
            .#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) {
            proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Article " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Article " + inspect(proxy, options);
    }
}
/** Represents a document of any kind.
 */
export class Document extends Object {
    /**
     * The type URI of {@link Document}: `https://www.w3.org/ns/activitystreams#Document`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Document");
    }
    #_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
    #_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
    /**
     * Constructs a new instance of Document with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("width" in values && values.width != null) {
            if (typeof values.width === "number" && Number.isInteger(values.width) &&
                values.width >= 0) {
                // @ts-ignore: type is checked above.
                this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
            }
            else {
                throw new TypeError("The width must be of type " +
                    "number" + ".");
            }
        }
        if ("height" in values && values.height != null) {
            if (typeof values.height === "number" && Number.isInteger(values.height) &&
                values.height >= 0) {
                // @ts-ignore: type is checked above.
                this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
            }
            else {
                throw new TypeError("The height must be of type " +
                    "number" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width =
            this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
        if ("width" in values && values.width != null) {
            if (typeof values.width === "number" && Number.isInteger(values.width) &&
                values.width >= 0) {
                // @ts-ignore: type is checked above.
                clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
            }
            else {
                throw new TypeError("The width must be of type " +
                    "number" + ".");
            }
        }
        clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height =
            this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
        if ("height" in values && values.height != null) {
            if (typeof values.height === "number" && Number.isInteger(values.height) &&
                values.height >= 0) {
                // @ts-ignore: type is checked above.
                clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
            }
            else {
                throw new TypeError("The height must be of type " +
                    "number" + ".");
            }
        }
        return clone;
    }
    /** Specifies a hint as to the rendering width in
     * device-independent pixels of the linked resource.
     */
    get width() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length < 1)
            return null;
        return this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
    }
    /** Specifies a hint as to the rendering height in
     * device-independent pixels of the linked resource.
     */
    get height() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length < 1)
            return null;
        return this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["width"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["height"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Document";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#width"] = propValue;
        }
        array = [];
        for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#height"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Document"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Document__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Document__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Audio")) {
                return await Audio.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Image")) {
                return await Image.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Page")) {
                return await Page.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Video")) {
                return await Video.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Document")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Document)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
        let _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array = values["https://www.w3.org/ns/activitystreams#width"];
        for (const v of _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array == null
            ? []
            : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array.length === 1 &&
                "@list" in _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0]
                ? _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0]["@list"]
                : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array) {
            if (v == null)
                continue;
            _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.push(v["@value"]);
        }
        instance.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width =
            _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
        const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
        let _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array = values["https://www.w3.org/ns/activitystreams#height"];
        for (const v of _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array == null
            ? []
            : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array.length === 1 &&
                "@list" in _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0]
                ? _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0]["@list"]
                : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array) {
            if (v == null)
                continue;
            _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.push(v["@value"]);
        }
        instance.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height =
            _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = this
            .#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length == 1) {
            proxy.width = _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
        }
        const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = this
            .#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length == 1) {
            proxy.height = _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Document " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Document " + inspect(proxy, options);
    }
}
/** Represents an audio document of any kind.
 */
export class Audio extends Document {
    /**
     * The type URI of {@link Audio}: `https://www.w3.org/ns/activitystreams#Audio`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Audio");
    }
    /**
     * Constructs a new instance of Audio with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Audio";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Audio"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Audio__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Audio__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Audio")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Audio)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Audio " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Audio " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is ignoring the `object`.  The `target` and
 * `origin` typically have no defined meaning.
 */
export class Ignore extends Activity {
    /**
     * The type URI of {@link Ignore}: `https://www.w3.org/ns/activitystreams#Ignore`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Ignore");
    }
    /**
     * Constructs a new instance of Ignore with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Ignore"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Ignore__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Ignore__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) {
                return await Block.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Ignore")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Ignore)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Ignore " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Ignore " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is blocking the `object`.  Blocking is a stronger
 * form of {@link Ignore}.  The typical use is to support social systems that
 * allow one user to block activities or content of other users.  The `target`
 * and `origin` typically have no defined meaning.
 */
export class Block extends Ignore {
    /**
     * The type URI of {@link Block}: `https://www.w3.org/ns/activitystreams#Block`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Block");
    }
    /**
     * Constructs a new instance of Block with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Block"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Block__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Block__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Block)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Block " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Block " + inspect(proxy, options);
    }
}
/** A `Collection` is a subtype of {@link Object} that represents ordered or
 * unordered sets of {@link Object} or {@link Link} instances.
 *
 * Refer to the Activity Streams 2.0 Core specification for a complete
 * description of the Collection type.
 */
export class Collection extends Object {
    /**
     * The type URI of {@link Collection}: `https://www.w3.org/ns/activitystreams#Collection`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Collection");
    }
    #_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [];
    #_3UyUdxnyn6cDn53QKrh4MBiearma_current = [];
    #_J52RqweMe6hhv7RnLJMC8BExTE5_first = [];
    #_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [];
    #_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
    /**
     * Constructs a new instance of Collection with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("totalItems" in values && values.totalItems != null) {
            if (typeof values.totalItems === "number" &&
                Number.isInteger(values.totalItems) && values.totalItems >= 0) {
                // @ts-ignore: type is checked above.
                this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [values.totalItems];
            }
            else {
                throw new TypeError("The totalItems must be of type " +
                    "number" + ".");
            }
        }
        if ("current" in values && values.current != null) {
            if (values.current instanceof CollectionPage ||
                values.current instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current = [values.current];
            }
            else {
                throw new TypeError("The current must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        if ("first" in values && values.first != null) {
            if (values.first instanceof CollectionPage || values.first instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first = [values.first];
            }
            else {
                throw new TypeError("The first must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        if ("last" in values && values.last != null) {
            if (values.last instanceof CollectionPage || values.last instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [values.last];
            }
            else {
                throw new TypeError("The last must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        if ("items" in values && values.items != null) {
            if (Array.isArray(values.items) &&
                values.items.every((v) => v instanceof Object || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
            }
            else {
                throw new TypeError("The items must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems =
            this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems;
        if ("totalItems" in values && values.totalItems != null) {
            if (typeof values.totalItems === "number" &&
                Number.isInteger(values.totalItems) && values.totalItems >= 0) {
                // @ts-ignore: type is checked above.
                clone.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [values.totalItems];
            }
            else {
                throw new TypeError("The totalItems must be of type " +
                    "number" + ".");
            }
        }
        clone.#_3UyUdxnyn6cDn53QKrh4MBiearma_current =
            this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current;
        if ("current" in values && values.current != null) {
            if (values.current instanceof CollectionPage ||
                values.current instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3UyUdxnyn6cDn53QKrh4MBiearma_current = [values.current];
            }
            else {
                throw new TypeError("The current must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        clone.#_J52RqweMe6hhv7RnLJMC8BExTE5_first =
            this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first;
        if ("first" in values && values.first != null) {
            if (values.first instanceof CollectionPage || values.first instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_J52RqweMe6hhv7RnLJMC8BExTE5_first = [values.first];
            }
            else {
                throw new TypeError("The first must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        clone.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last =
            this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last;
        if ("last" in values && values.last != null) {
            if (values.last instanceof CollectionPage || values.last instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [values.last];
            }
            else {
                throw new TypeError("The last must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items =
            this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        if ("items" in values && values.items != null) {
            if (Array.isArray(values.items) &&
                values.items.every((v) => v instanceof Object || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
            }
            else {
                throw new TypeError("The items must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        return clone;
    }
    /** A non-negative integer specifying the total number of objects contained by
     * the logical view of the collection. This number might not reflect the actual
     * number of items serialized within the {@link Collection} object instance.
     */
    get totalItems() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems.length < 1)
            return null;
        return this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems[0];
    }
    async #fetchCurrent(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#current_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #current_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
    }
    /**
     * Similar to
     * {@link Collection.getCurrent},
     * but returns its `@id` URL instead of the object itself.
     */
    get currentId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current.length < 1)
            return null;
        const v = this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** In a paged {@link Collection}, indicates the page that contains
     * the most recently updated member items.
     */
    async getCurrent(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current.length < 1)
            return null;
        const v = this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchCurrent(v, options);
            if (fetched == null)
                return null;
            this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "current" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["current"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#current_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFirst(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#first_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #first_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
    }
    /**
     * Similar to
     * {@link Collection.getFirst},
     * but returns its `@id` URL instead of the object itself.
     */
    get firstId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first.length < 1)
            return null;
        const v = this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** In a paged {@link Collection}, indicates the furthest preceding page of
     * items in the collection.
     */
    async getFirst(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first.length < 1)
            return null;
        const v = this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFirst(v, options);
            if (fetched == null)
                return null;
            this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "first" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["first"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#first_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchLast(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#last_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #last_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
    }
    /**
     * Similar to
     * {@link Collection.getLast},
     * but returns its `@id` URL instead of the object itself.
     */
    get lastId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.length < 1)
            return null;
        const v = this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** In a paged {@link Collection}, indicates the furthest proceeding page of
     * the collection.
     */
    async getLast(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.length < 1)
            return null;
        const v = this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLast(v, options);
            if (fetched == null)
                return null;
            this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "last" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["last"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#last_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchItem(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#item_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #item_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Collection.getItems},
     * but returns their `@id`s instead of the objects themselves.
     */
    get itemIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies the items contained in a collection.  The items might be ordered
     * or unordered.
     */
    async *getItems(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchItem(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "items" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["items"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#item_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["totalItems"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["current"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["first"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["last"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Object
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["items"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Collection";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#totalItems"] = propValue;
        }
        array = [];
        for (const v of this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#current"] = propValue;
        }
        array = [];
        for (const v of this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#first"] = propValue;
        }
        array = [];
        for (const v of this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#last"] = propValue;
        }
        array = [];
        for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Object
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#items"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Collection"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Collection__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Collection__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#CollectionPage")) {
                return await CollectionPage.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) {
                return await OrderedCollectionPage.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")) {
                return await OrderedCollection.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Collection")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Collection)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [];
        let _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array = values["https://www.w3.org/ns/activitystreams#totalItems"];
        for (const v of _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array == null
            ? []
            : _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array.length === 1 &&
                "@list" in _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array[0]
                ? _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array[0]["@list"]
                : _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array) {
            if (v == null)
                continue;
            _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems.push(v["@value"]);
        }
        instance.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems =
            _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems;
        const _3UyUdxnyn6cDn53QKrh4MBiearma_current = [];
        let _3UyUdxnyn6cDn53QKrh4MBiearma_current__array = values["https://www.w3.org/ns/activitystreams#current"];
        for (const v of _3UyUdxnyn6cDn53QKrh4MBiearma_current__array == null
            ? []
            : _3UyUdxnyn6cDn53QKrh4MBiearma_current__array.length === 1 &&
                "@list" in _3UyUdxnyn6cDn53QKrh4MBiearma_current__array[0]
                ? _3UyUdxnyn6cDn53QKrh4MBiearma_current__array[0]["@list"]
                : _3UyUdxnyn6cDn53QKrh4MBiearma_current__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3UyUdxnyn6cDn53QKrh4MBiearma_current.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3UyUdxnyn6cDn53QKrh4MBiearma_current.push(await CollectionPage.fromJsonLd(v, options));
        }
        instance.#_3UyUdxnyn6cDn53QKrh4MBiearma_current =
            _3UyUdxnyn6cDn53QKrh4MBiearma_current;
        const _J52RqweMe6hhv7RnLJMC8BExTE5_first = [];
        let _J52RqweMe6hhv7RnLJMC8BExTE5_first__array = values["https://www.w3.org/ns/activitystreams#first"];
        for (const v of _J52RqweMe6hhv7RnLJMC8BExTE5_first__array == null
            ? []
            : _J52RqweMe6hhv7RnLJMC8BExTE5_first__array.length === 1 &&
                "@list" in _J52RqweMe6hhv7RnLJMC8BExTE5_first__array[0]
                ? _J52RqweMe6hhv7RnLJMC8BExTE5_first__array[0]["@list"]
                : _J52RqweMe6hhv7RnLJMC8BExTE5_first__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _J52RqweMe6hhv7RnLJMC8BExTE5_first.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _J52RqweMe6hhv7RnLJMC8BExTE5_first.push(await CollectionPage.fromJsonLd(v, options));
        }
        instance.#_J52RqweMe6hhv7RnLJMC8BExTE5_first =
            _J52RqweMe6hhv7RnLJMC8BExTE5_first;
        const _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [];
        let _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array = values["https://www.w3.org/ns/activitystreams#last"];
        for (const v of _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array == null
            ? []
            : _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array.length === 1 &&
                "@list" in _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array[0]
                ? _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array[0]["@list"]
                : _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.push(await CollectionPage.fromJsonLd(v, options));
        }
        instance.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last =
            _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last;
        const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
        let _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array = values["https://www.w3.org/ns/activitystreams#items"];
        for (const v of _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array == null
            ? []
            : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array.length === 1 &&
                "@list" in _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]
                ? _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]["@list"]
                : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await Object.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(decoded);
        }
        instance.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items =
            _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = this
            .#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems.length == 1) {
            proxy.totalItems = _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems[0];
        }
        const _3UyUdxnyn6cDn53QKrh4MBiearma_current = this
            .#_3UyUdxnyn6cDn53QKrh4MBiearma_current
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3UyUdxnyn6cDn53QKrh4MBiearma_current.length == 1) {
            proxy.current = _3UyUdxnyn6cDn53QKrh4MBiearma_current[0];
        }
        const _J52RqweMe6hhv7RnLJMC8BExTE5_first = this
            .#_J52RqweMe6hhv7RnLJMC8BExTE5_first
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_J52RqweMe6hhv7RnLJMC8BExTE5_first.length == 1) {
            proxy.first = _J52RqweMe6hhv7RnLJMC8BExTE5_first[0];
        }
        const _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = this
            .#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.length == 1) {
            proxy.last = _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0];
        }
        const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this
            .#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 1 ||
            !("item" in proxy) &&
                _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 0) {
            proxy.items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Collection " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Collection " + inspect(proxy, options);
    }
}
/** Used to represent distinct subsets of items from a `Collection`.
 * Refer to the Activity Streams 2.0 Core for a complete description of
 * the `CollectionPage` object.
 */
export class CollectionPage extends Collection {
    /**
     * The type URI of {@link CollectionPage}: `https://www.w3.org/ns/activitystreams#CollectionPage`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#CollectionPage");
    }
    #_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [];
    #_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [];
    #_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [];
    /**
     * Constructs a new instance of CollectionPage with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("partOf" in values && values.partOf != null) {
            if (values.partOf instanceof Collection || values.partOf instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [values.partOf];
            }
            else {
                throw new TypeError("The partOf must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("next" in values && values.next != null) {
            if (values.next instanceof _c || values.next instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [values.next];
            }
            else {
                throw new TypeError("The next must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        if ("prev" in values && values.prev != null) {
            if (values.prev instanceof _c || values.prev instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [values.prev];
            }
            else {
                throw new TypeError("The prev must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf =
            this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf;
        if ("partOf" in values && values.partOf != null) {
            if (values.partOf instanceof Collection || values.partOf instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [values.partOf];
            }
            else {
                throw new TypeError("The partOf must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next =
            this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next;
        if ("next" in values && values.next != null) {
            if (values.next instanceof _c || values.next instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [values.next];
            }
            else {
                throw new TypeError("The next must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        clone.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev =
            this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev;
        if ("prev" in values && values.prev != null) {
            if (values.prev instanceof _c || values.prev instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [values.prev];
            }
            else {
                throw new TypeError("The prev must be of type " +
                    "CollectionPage | URL" + ".");
            }
        }
        return clone;
    }
    async #fetchPartOf(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#partOf_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #partOf_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link CollectionPage.getPartOf},
     * but returns its `@id` URL instead of the object itself.
     */
    get partOfId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.length < 1)
            return null;
        const v = this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Identifies the {@link Collection} to which a {@link CollectionPage} objects
     * items belong.
     */
    async getPartOf(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.length < 1)
            return null;
        const v = this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPartOf(v, options);
            if (fetched == null)
                return null;
            this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "partOf" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["partOf"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#partOf_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchNext(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#next_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #next_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _c.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
    }
    /**
     * Similar to
     * {@link CollectionPage.getNext},
     * but returns its `@id` URL instead of the object itself.
     */
    get nextId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.length < 1)
            return null;
        const v = this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** In a paged {@link Collection}, indicates the next page of items.
     */
    async getNext(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.length < 1)
            return null;
        const v = this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchNext(v, options);
            if (fetched == null)
                return null;
            this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "next" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["next"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#next_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchPrev(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#prev_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #prev_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _c.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
    }
    /**
     * Similar to
     * {@link CollectionPage.getPrev},
     * but returns its `@id` URL instead of the object itself.
     */
    get prevId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.length < 1)
            return null;
        const v = this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** In a paged {@link Collection}, identifies the previous page of items.
     */
    async getPrev(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.length < 1)
            return null;
        const v = this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPrev(v, options);
            if (fetched == null)
                return null;
            this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "prev" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["prev"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#prev_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["partOf"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["next"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["prev"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "CollectionPage";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#partOf"] = propValue;
        }
        array = [];
        for (const v of this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#next"] = propValue;
        }
        array = [];
        for (const v of this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#prev"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#CollectionPage"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__CollectionPage__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__CollectionPage__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) {
                return await OrderedCollectionPage.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#CollectionPage")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof _c)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [];
        let _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array = values["https://www.w3.org/ns/activitystreams#partOf"];
        for (const v of _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array == null
            ? []
            : _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array.length === 1 &&
                "@list" in _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array[0]
                ? _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array[0]["@list"]
                : _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf =
            _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf;
        const _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [];
        let _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array = values["https://www.w3.org/ns/activitystreams#next"];
        for (const v of _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array == null
            ? []
            : _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array.length === 1 &&
                "@list" in _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array[0]
                ? _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array[0]["@list"]
                : _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.push(await _c.fromJsonLd(v, options));
        }
        instance.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next =
            _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next;
        const _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [];
        let _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array = values["https://www.w3.org/ns/activitystreams#prev"];
        for (const v of _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array == null
            ? []
            : _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array.length === 1 &&
                "@list" in _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array[0]
                ? _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array[0]["@list"]
                : _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.push(await _c.fromJsonLd(v, options));
        }
        instance.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev =
            _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = this
            .#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.length == 1) {
            proxy.partOf = _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0];
        }
        const _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = this
            .#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.length == 1) {
            proxy.next = _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0];
        }
        const _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = this
            .#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.length == 1) {
            proxy.prev = _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "CollectionPage " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "CollectionPage " + inspect(proxy, options);
    }
}
_c = CollectionPage;
/** Indicates that the `actor` has created the `object`.
 */
export class Create extends Activity {
    /**
     * The type URI of {@link Create}: `https://www.w3.org/ns/activitystreams#Create`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Create");
    }
    /**
     * Constructs a new instance of Create with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Create"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Create__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Create__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Create")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Create)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Create " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Create " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has deleted the `object`.  If specified,
 * the `origin` indicates the context from which the `object` was deleted.
 */
export class Delete extends Activity {
    /**
     * The type URI of {@link Delete}: `https://www.w3.org/ns/activitystreams#Delete`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Delete");
    }
    /**
     * Constructs a new instance of Delete with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Delete"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Delete__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Delete__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Delete")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Delete)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Delete " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Delete " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` dislikes the `object`.
 */
export class Dislike extends Activity {
    /**
     * The type URI of {@link Dislike}: `https://www.w3.org/ns/activitystreams#Dislike`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Dislike");
    }
    /**
     * Constructs a new instance of Dislike with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Dislike"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                { "toot": "http://joinmastodon.org/ns#", "Emoji": "toot:Emoji" },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Dislike__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Dislike__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Dislike")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Dislike)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Dislike " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Dislike " + inspect(proxy, options);
    }
}
/** Contents of {@link Actor}'s `endpoints`.
 */
export class Endpoints {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link Endpoints}: `https://www.w3.org/ns/activitystreams#Endpoints`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Endpoints");
    }
    #_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [];
    #_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [];
    #_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [];
    #_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [];
    #_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [];
    #_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [];
    /**
     * Constructs a new instance of Endpoints with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("proxyUrl" in values && values.proxyUrl != null) {
            if (values.proxyUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [values.proxyUrl];
            }
            else {
                throw new TypeError("The proxyUrl must be of type " +
                    "URL" + ".");
            }
        }
        if ("oauthAuthorizationEndpoint" in values &&
            values.oauthAuthorizationEndpoint != null) {
            if (values.oauthAuthorizationEndpoint instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [
                    values.oauthAuthorizationEndpoint,
                ];
            }
            else {
                throw new TypeError("The oauthAuthorizationEndpoint must be of type " +
                    "URL" + ".");
            }
        }
        if ("oauthTokenEndpoint" in values && values.oauthTokenEndpoint != null) {
            if (values.oauthTokenEndpoint instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [
                    values.oauthTokenEndpoint,
                ];
            }
            else {
                throw new TypeError("The oauthTokenEndpoint must be of type " +
                    "URL" + ".");
            }
        }
        if ("provideClientKey" in values && values.provideClientKey != null) {
            if (values.provideClientKey instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [
                    values.provideClientKey,
                ];
            }
            else {
                throw new TypeError("The provideClientKey must be of type " +
                    "URL" + ".");
            }
        }
        if ("signClientKey" in values && values.signClientKey != null) {
            if (values.signClientKey instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [
                    values.signClientKey,
                ];
            }
            else {
                throw new TypeError("The signClientKey must be of type " +
                    "URL" + ".");
            }
        }
        if ("sharedInbox" in values && values.sharedInbox != null) {
            if (values.sharedInbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [values.sharedInbox];
            }
            else {
                throw new TypeError("The sharedInbox must be of type " +
                    "URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl =
            this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl;
        if ("proxyUrl" in values && values.proxyUrl != null) {
            if (values.proxyUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [values.proxyUrl];
            }
            else {
                throw new TypeError("The proxyUrl must be of type " +
                    "URL" + ".");
            }
        }
        clone.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint =
            this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint;
        if ("oauthAuthorizationEndpoint" in values &&
            values.oauthAuthorizationEndpoint != null) {
            if (values.oauthAuthorizationEndpoint instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [
                    values.oauthAuthorizationEndpoint,
                ];
            }
            else {
                throw new TypeError("The oauthAuthorizationEndpoint must be of type " +
                    "URL" + ".");
            }
        }
        clone.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint =
            this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint;
        if ("oauthTokenEndpoint" in values && values.oauthTokenEndpoint != null) {
            if (values.oauthTokenEndpoint instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [
                    values.oauthTokenEndpoint,
                ];
            }
            else {
                throw new TypeError("The oauthTokenEndpoint must be of type " +
                    "URL" + ".");
            }
        }
        clone.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey =
            this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey;
        if ("provideClientKey" in values && values.provideClientKey != null) {
            if (values.provideClientKey instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [
                    values.provideClientKey,
                ];
            }
            else {
                throw new TypeError("The provideClientKey must be of type " +
                    "URL" + ".");
            }
        }
        clone.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey =
            this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey;
        if ("signClientKey" in values && values.signClientKey != null) {
            if (values.signClientKey instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [
                    values.signClientKey,
                ];
            }
            else {
                throw new TypeError("The signClientKey must be of type " +
                    "URL" + ".");
            }
        }
        clone.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox =
            this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox;
        if ("sharedInbox" in values && values.sharedInbox != null) {
            if (values.sharedInbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [values.sharedInbox];
            }
            else {
                throw new TypeError("The sharedInbox must be of type " +
                    "URL" + ".");
            }
        }
        return clone;
    }
    /** Endpoint URI so this actor's clients may access remote ActivityStreams
     * objects which require authentication to access.  To use this endpoint,
     * the client posts an `x-www-form-urlencoded` `id` parameter with the value
     * being the `id` of the requested ActivityStreams object.
     */
    get proxyUrl() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl.length < 1)
            return null;
        return this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl[0];
    }
    /** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
     * authenticating [client to server
     * interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
     * this endpoint specifies a URI at which a browser-authenticated user may
     * obtain a new authorization grant.
     */
    get oauthAuthorizationEndpoint() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint.length < 1)
            return null;
        return this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint[0];
    }
    /** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
     * authenticating [client to server
     * interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
     * this endpoint specifies a URI at which a client may acquire an access token.
     */
    get oauthTokenEndpoint() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint.length < 1) {
            return null;
        }
        return this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint[0];
    }
    /** If Linked Data Signatures and HTTP Signatures are being used for
     * authentication and authorization, this endpoint specifies a URI at which
     * browser-authenticated users may authorize a client's public key for [client
     * to server interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions).
     */
    get provideClientKey() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey.length < 1) {
            return null;
        }
        return this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey[0];
    }
    /** If Linked Data Signatures and HTTP Signatures are being used for
     * authentication and authorization, this endpoint specifies a URI at which
     * a client key may be signed by the actor's key for a time window to act on
     * behalf of the actor in interacting with foreign servers.
     */
    get signClientKey() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey.length < 1) {
            return null;
        }
        return this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey[0];
    }
    /** An optional endpoint [used for wide delivery of publicly addressed
     * activities and activities sent to
     * followers](https://www.w3.org/TR/activitypub/#shared-inbox-delivery).
     * `sharedInbox` endpoints SHOULD also be publicly readable
     * {@link OrderedCollection} objects containing objects addressed to the
     * [Public](https://www.w3.org/TR/activitypub/#public-addressing) special
     * collection.  Reading from the `sharedInbox` endpoint MUST NOT present
     * objects which are not addressed to the `Public`` endpoint.
     */
    get sharedInbox() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox.length < 1)
            return null;
        return this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = {};
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["proxyUrl"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this
                .#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["oauthAuthorizationEndpoint"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["oauthTokenEndpoint"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["provideClientKey"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["signClientKey"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["sharedInbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "as:Endpoints";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = "https://www.w3.org/ns/activitystreams";
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#proxyUrl"] = propValue;
        }
        array = [];
        for (const v of this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#oauthAuthorizationEndpoint"] = propValue;
        }
        array = [];
        for (const v of this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#oauthTokenEndpoint"] =
                propValue;
        }
        array = [];
        for (const v of this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#provideClientKey"] =
                propValue;
        }
        array = [];
        for (const v of this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#signClientKey"] = propValue;
        }
        array = [];
        for (const v of this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#sharedInbox"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Endpoints"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://www.w3.org/ns/activitystreams";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Endpoints__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Endpoints__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Endpoints")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [];
        let _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array = values["https://www.w3.org/ns/activitystreams#proxyUrl"];
        for (const v of _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array == null
            ? []
            : _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array.length === 1 &&
                "@list" in _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array[0]
                ? _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array[0]["@list"]
                : _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array) {
            if (v == null)
                continue;
            _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl.push(new URL(v["@id"]));
        }
        instance.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl =
            _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl;
        const _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [];
        let _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array = values["https://www.w3.org/ns/activitystreams#oauthAuthorizationEndpoint"];
        for (const v of _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array ==
            null
            ? []
            : _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array
                .length === 1 &&
                "@list" in
                    _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array[0]
                ? _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array[0]["@list"]
                : _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array) {
            if (v == null)
                continue;
            _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint.push(new URL(v["@id"]));
        }
        instance.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint =
            _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint;
        const _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [];
        let _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array = values["https://www.w3.org/ns/activitystreams#oauthTokenEndpoint"];
        for (const v of _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array == null
            ? []
            : _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array.length === 1 &&
                "@list" in _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array[0]
                ? _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array[0]["@list"]
                : _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array) {
            if (v == null)
                continue;
            _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint.push(new URL(v["@id"]));
        }
        instance.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint =
            _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint;
        const _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [];
        let _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array = values["https://www.w3.org/ns/activitystreams#provideClientKey"];
        for (const v of _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array == null
            ? []
            : _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array.length === 1 &&
                "@list" in _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array[0]
                ? _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array[0]["@list"]
                : _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array) {
            if (v == null)
                continue;
            _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey.push(new URL(v["@id"]));
        }
        instance.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey =
            _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey;
        const _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [];
        let _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array = values["https://www.w3.org/ns/activitystreams#signClientKey"];
        for (const v of _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array == null
            ? []
            : _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array.length === 1 &&
                "@list" in _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array[0]
                ? _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array[0]["@list"]
                : _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array) {
            if (v == null)
                continue;
            _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey.push(new URL(v["@id"]));
        }
        instance.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey =
            _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey;
        const _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [];
        let _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array = values["https://www.w3.org/ns/activitystreams#sharedInbox"];
        for (const v of _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array == null
            ? []
            : _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array.length === 1 &&
                "@list" in _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array[0]
                ? _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array[0]["@list"]
                : _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array) {
            if (v == null)
                continue;
            _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox.push(new URL(v["@id"]));
        }
        instance.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox =
            _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = this
            .#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl.length == 1) {
            proxy.proxyUrl = _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl[0];
        }
        const _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = this
            .#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint.length == 1) {
            proxy.oauthAuthorizationEndpoint =
                _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint[0];
        }
        const _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = this
            .#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint.length == 1) {
            proxy.oauthTokenEndpoint =
                _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint[0];
        }
        const _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = this
            .#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey.length == 1) {
            proxy.provideClientKey = _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey[0];
        }
        const _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = this
            .#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey.length == 1) {
            proxy.signClientKey = _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey[0];
        }
        const _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = this
            .#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox.length == 1) {
            proxy.sharedInbox = _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Endpoints " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Endpoints " + inspect(proxy, options);
    }
}
/** Represents any kind of event.
 */
export class Event extends Object {
    /**
     * The type URI of {@link Event}: `https://www.w3.org/ns/activitystreams#Event`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Event");
    }
    /**
     * Constructs a new instance of Event with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Event";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Event"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Event__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Event__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Event")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Event)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Event " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Event " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is "flagging" the `object`.  Flagging is defined
 * in the sense common to many social platforms as reporting content as being
 * inappropriate for any number of reasons.
 */
export class Flag extends Activity {
    /**
     * The type URI of {@link Flag}: `https://www.w3.org/ns/activitystreams#Flag`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Flag");
    }
    /**
     * Constructs a new instance of Flag with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Flag"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Flag__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Flag__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Flag")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Flag)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Flag " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Flag " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is "following" the `object`.  Following is defined
 * in the sense typically used within Social systems in which the actor is
 * interested in any activity performed by or on the object.  The `target` and
 * `origin` typically have no defined meaning.
 */
export class Follow extends Activity {
    /**
     * The type URI of {@link Follow}: `https://www.w3.org/ns/activitystreams#Follow`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Follow");
    }
    /**
     * Constructs a new instance of Follow with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Follow"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Follow__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Follow__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Follow")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Follow)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Follow " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Follow " + inspect(proxy, options);
    }
}
/** Represents a formal or informal collective of Actors.
 */
export class Group extends Object {
    /**
     * The type URI of {@link Group}: `https://www.w3.org/ns/activitystreams#Group`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Group");
    }
    #_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
    #_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
    #_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
    #_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
    #_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
    #_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
    #_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
    #_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
    #_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
    #_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
    #_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
    #_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
    #_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
    #_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
    #_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
    #_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
    #_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
    #_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
    #_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
    #_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
    #_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
    #_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
    /**
     * Constructs a new instance of Group with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot initialize both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot initialize both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot initialize both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof _d ||
                values.successor instanceof Organization ||
                values.successor instanceof Person ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof _d ||
                values.alias instanceof Organization ||
                values.alias instanceof Person || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot initialize both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof _d ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot initialize both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot update both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot update both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot update both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [
                    values.discoverable,
                ];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof _d ||
                values.successor instanceof Organization ||
                values.successor instanceof Person ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof _d ||
                values.alias instanceof Organization ||
                values.alias instanceof Person || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot update both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof _d ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot update both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
        return clone;
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsername() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) {
            return null;
        }
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsernames() {
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
    }
    async #fetchPublicKey(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#publicKey_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #publicKey_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CryptographicKey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Key"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getPublicKey},
     * but returns its `@id` URL instead of the object itself.
     */
    get publicKeyId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** A public part of the key pair owned by this actor.
     */
    async getPublicKey(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPublicKey(v, options);
            if (fetched == null)
                return null;
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "publicKey" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["publicKey"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#publicKey_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Group.getPublicKeys},
     * but returns their `@id`s instead of the objects themselves.
     */
    get publicKeyIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A public part of the key pair owned by this actor.
     */
    async *getPublicKeys(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchPublicKey(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "publicKey" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["publicKey"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#publicKey_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchAssertionMethod(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#assertionMethod_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #assertionMethod_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Multikey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Multikey"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getAssertionMethod},
     * but returns its `@id` URL instead of the object itself.
     */
    get assertionMethodId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async getAssertionMethod(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAssertionMethod(v, options);
            if (fetched == null)
                return null;
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "assertionMethod" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["assertionMethod"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#assertionMethod_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Group.getAssertionMethods},
     * but returns their `@id`s instead of the objects themselves.
     */
    get assertionMethodIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async *getAssertionMethods(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAssertionMethod(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "assertionMethod" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["assertionMethod"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#assertionMethod_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** When `true`, conveys that for this actor, follow requests are not usually
     * automatically approved, but instead are examined by a person who may accept
     * or reject the request, at some time in the future.  Setting of `false`
     * conveys no information and may be ignored.  This information is typically
     * used to affect display of accounts, such as showing an account as private or
     * locked.
     */
    get manuallyApprovesFollowers() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1)
            return null;
        return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
    }
    async #fetchInbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#inbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #inbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getInbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get inboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The inbox stream contains all activities received by the actor.  The server
     * SHOULD filter content according to the requester's permission.  In general,
     * the owner of an inbox is likely to be able to access all of their inbox
     * contents.  Depending on access control, some other content may be public,
     * whereas other content may require authentication for non-owner users,
     * if they can access the inbox at all.
     *
     * The server MUST perform de-duplication of activities returned by the inbox.
     * Duplication can occur if an activity is addressed both to an actor's
     * followers, and a specific actor who also follows the recipient actor,
     * and the server has failed to de-duplicate the recipients list.
     * Such deduplication MUST be performed by comparing the `id` of the activities
     * and dropping any activities already seen.
     */
    async getInbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchInbox(v, options);
            if (fetched == null)
                return null;
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "inbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["inbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#inbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchOutbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#outbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #outbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getOutbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get outboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The outbox stream contains activities the user has published,
     * subject to the ability of the requestor to retrieve the activity
     * (that is, the contents of the outbox are filtered by the permissions of
     * the person reading it).  If a user submits a request without
     * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
     * the server should respond with all of the
     * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
     * This could potentially be all relevant objects published by the user,
     * though the number of available items is left to the discretion of those
     * implementing and deploying the server.
     */
    async getOutbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchOutbox(v, options);
            if (fetched == null)
                return null;
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "outbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["outbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#outbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowing(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#following_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #following_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getFollowing},
     * but returns its `@id` URL instead of the object itself.
     */
    get followingId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everybody that the actor has followed, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * The `following` collection MUST be either an {@link OrderedCollection}
     * or a {@link Collection} and MAY be filtered on privileges of
     * an authenticated user or as appropriate when no authentication is given.
     */
    async getFollowing(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowing(v, options);
            if (fetched == null)
                return null;
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "following" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["following"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#following_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowers(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#followers_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #followers_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getFollowers},
     * but returns its `@id` URL instead of the object itself.
     */
    get followersId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everyone who has sent a {@link Follow} activity
     * for the actor, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * This is where one would find a list of all the actors that are following
     * the actor.  The `followers` collection MUST be either
     * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
     * privileges of an authenticated user or as appropriate when no authentication
     * is given.
     */
    async getFollowers(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowers(v, options);
            if (fetched == null)
                return null;
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "followers" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["followers"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#followers_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchLiked(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#liked_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #liked_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getLiked},
     * but returns its `@id` URL instead of the object itself.
     */
    get likedId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of every object from all of the actor's {@link Like}
     * activities, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
     * The `liked` collection MUST be either an {@link OrderedCollection} or
     * a {@link Collection} and MAY be filtered on privileges of an authenticated
     * user or as appropriate when no authentication is given.
     */
    async getLiked(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLiked(v, options);
            if (fetched == null)
                return null;
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "liked" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["liked"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#liked_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeatured(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featured_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featured_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getFeatured},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "pinned statuses", or statuses that are always
     * featured at the top of people's profiles, is implemented using an extra
     * property `featured` on the actor object that points to a {@link Collection}
     * of objects.
     */
    async getFeatured(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeatured(v, options);
            if (fetched == null)
                return null;
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featured" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featured"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featured_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeaturedTags(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featuredTags_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featuredTags_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getFeaturedTags},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredTagsId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "featured hashtags", hashtags that are featured
     * at people's profiles, is implemented using an extra property `featuredTags`
     * on the actor object that points to a {@link Collection} of {@link Hashtag}
     * objects specifically.
     */
    async getFeaturedTags(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeaturedTags(v, options);
            if (fetched == null)
                return null;
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featuredTags" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featuredTags"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featuredTags_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchStream(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#stream_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #stream_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getStreams},
     * but returns their `@id`s instead of the objects themselves.
     */
    get streamIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A list of supplementary Collections which may be of interest.
     */
    async *getStreams(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchStream(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "streams" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["streams"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#stream_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** A JSON object which maps additional (typically server/domain-wide) endpoints
     * which may be useful either for this actor or someone referencing this actor.
     * This mapping may be nested inside the actor document as the value or may be
     * a link to a JSON-LD document with these properties.
     */
    get endpoints() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1)
            return null;
        return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
    }
    /** Allows users to opt-in or opt-out of discoverability features like
     * the profile directory.  This flag may also be used as an indicator of
     * the user's preferences toward being included in external discovery services,
     * such as search engines or other indexing tools.
     */
    get discoverable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1)
            return null;
        return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
    }
    /** Reports whether a user was locally suspended, for better handling of
     * these accounts.
     */
    get suspended() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1)
            return null;
        return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
    }
    /** Whether the actor is in-memorial state.
     */
    get memorial() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1)
            return null;
        return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
    }
    /** Whether the actor allows to be indexed.
     */
    get indexable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1)
            return null;
        return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
    }
    async #fetchSuccessor(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#successor_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #successor_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _d.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getSuccessor},
     * but returns its `@id` URL instead of the object itself.
     */
    get successorId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
     */
    async getSuccessor(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchSuccessor(v, options);
            if (fetched == null)
                return null;
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "movedTo" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["movedTo"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#successor_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchAlias(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#alias_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #alias_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _d.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getAlias},
     * but returns its `@id` URL instead of the object itself.
     */
    get aliasId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async getAlias(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAlias(v, options);
            if (fetched == null)
                return null;
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "alsoKnownAs" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["alsoKnownAs"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#alias_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Group.getAliases},
     * but returns their `@id`s instead of the objects themselves.
     */
    get aliasIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async *getAliases(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAlias(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "alsoKnownAs" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["alsoKnownAs"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#alias_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchService(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#service_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #service_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await DidService.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/did#Service"].join(", "));
    }
    /**
     * Similar to
     * {@link Group.getService},
     * but returns its `@id` URL instead of the object itself.
     */
    get serviceId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async getService(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchService(v, options);
            if (fetched == null)
                return null;
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "service" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["service"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#service_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Group.getServices},
     * but returns their `@id`s instead of the objects themselves.
     */
    get serviceIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async *getServices(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchService(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "service" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["service"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#service_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** This value is used for `Actor` type objects to show message on followed.
     */
    get followedMessage() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1)
            return null;
        return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
    }
    /** Used on actors to indicate that they in some way identify as a cat,
     * expressed as a boolean value. If this property is set to `true`,
     * displaying the actor or their notes will have some special effects
     * attached in some clients.
     */
    get cat() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1)
            return null;
        return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["preferredUsername"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["publicKey"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["assertionMethod"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["manuallyApprovesFollowers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["inbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["outbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["following"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["followers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["liked"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featured"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featuredTags"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["streams"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
                const item = await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["endpoints"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["discoverable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["suspended"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["memorial"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["indexable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof _d
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["movedTo"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof _d
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["alsoKnownAs"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["service"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["_misskey_followedMessage"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["isCat"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Group";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#preferredUsername"] =
                propValue;
        }
        array = [];
        for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#publicKey"] = propValue;
        }
        array = [];
        for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#assertionMethod"] = propValue;
        }
        array = [];
        for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
        }
        array = [];
        for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://www.w3.org/ns/ldp#inbox"] = propValue;
        }
        array = [];
        for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
        }
        array = [];
        for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#following"] = propValue;
        }
        array = [];
        for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
        }
        array = [];
        for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
        }
        array = [];
        for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featured"] = propValue;
        }
        array = [];
        for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featuredTags"] = propValue;
        }
        array = [];
        for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
        }
        array = [];
        for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
            const element = await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
        }
        array = [];
        for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#discoverable"] = propValue;
        }
        array = [];
        for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#suspended"] = propValue;
        }
        array = [];
        for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#memorial"] = propValue;
        }
        array = [];
        for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#indexable"] = propValue;
        }
        array = [];
        for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof _d
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
        }
        array = [];
        for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof _d
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
        }
        array = [];
        for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/did#service"] = propValue;
        }
        array = [];
        for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
        }
        array = [];
        for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#isCat"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Group"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null &&
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0)
            return false;
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null &&
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0)
            return false;
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Group__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Group__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Group")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof _d)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
        let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
        for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null
            ? []
            : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 &&
                "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]
                ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"]
                : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
        }
        instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
        let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
        for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null
            ? []
            : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 &&
                "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]
                ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"]
                : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, options));
        }
        instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
        let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
        for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null
            ? []
            : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 &&
                "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]
                ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"]
                : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, options));
        }
        instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
        let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
        for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null
            ? []
            : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array
                .length === 1 &&
                "@list" in
                    _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]
                ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"]
                : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
            if (v == null)
                continue;
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
        }
        instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
        let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
        for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null
            ? []
            : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 &&
                "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]
                ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"]
                : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
        }
        instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
        let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
        for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null
            ? []
            : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 &&
                "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]
                ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"]
                : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
        }
        instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            _41QwhqJouoLg3h8dRPKat21brynC_outbox;
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
        let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
        for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null
            ? []
            : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 &&
                "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]
                ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"]
                : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
        let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
        for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null
            ? []
            : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 &&
                "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]
                ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"]
                : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
        let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
        for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null
            ? []
            : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 &&
                "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]
                ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"]
                : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
        let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
        for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null
            ? []
            : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 &&
                "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]
                ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"]
                : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
        let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
        for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null
            ? []
            : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 &&
                "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]
                ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"]
                : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
        let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
        for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null
            ? []
            : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 &&
                "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]
                ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"]
                : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
        let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
        for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null
            ? []
            : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 &&
                "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]
                ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"]
                : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
            if (v == null)
                continue;
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, options));
        }
        instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
        let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
        for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null
            ? []
            : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 &&
                "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]
                ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"]
                : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
            if (v == null)
                continue;
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
        }
        instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
        let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
        for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null
            ? []
            : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 &&
                "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]
                ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"]
                : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
            if (v == null)
                continue;
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
        }
        instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
        let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
        for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null
            ? []
            : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 &&
                "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]
                ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"]
                : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
            if (v == null)
                continue;
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
        }
        instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
        let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
        for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null
            ? []
            : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 &&
                "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]
                ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"]
                : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
            if (v == null)
                continue;
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
        }
        instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
        let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
        for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null
            ? []
            : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 &&
                "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]
                ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"]
                : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await _d.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
        }
        instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
        let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
        for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null
            ? []
            : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 &&
                "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]
                ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"]
                : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await _d.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
        }
        instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
        let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
        for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null
            ? []
            : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 &&
                "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]
                ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"]
                : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, options));
        }
        instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
        let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
        for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null
            ? []
            : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array
                .length === 1 &&
                "@list" in
                    _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]
                ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"]
                : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
            if (v == null)
                continue;
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
        }
        instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
        let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
        for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null
            ? []
            : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 &&
                "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]
                ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"]
                : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
            if (v == null)
                continue;
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
        }
        instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this
            .#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) {
            proxy.preferredUsername =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
        }
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 ||
            !("preferredUsername" in proxy) &&
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) {
            proxy.preferredUsernames =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        }
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this
            .#_axq166E2eZADq34V4MYUc8KMZdC_publicKey
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) {
            proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        }
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 ||
            !("publicKey" in proxy) &&
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) {
            proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        }
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this
            .#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) {
            proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        }
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 ||
            !("assertionMethod" in proxy) &&
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) {
            proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        }
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this
            .#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) {
            proxy.manuallyApprovesFollowers =
                _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
        }
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this
            .#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) {
            proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        }
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this
            .#_41QwhqJouoLg3h8dRPKat21brynC_outbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) {
            proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        }
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this
            .#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) {
            proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        }
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this
            .#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) {
            proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        }
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this
            .#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) {
            proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        }
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this
            .#_4N1vBJzXDf8NbBumeECQMFvKetja_featured
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) {
            proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        }
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this
            .#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) {
            proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        }
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this
            .#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 ||
            !("stream" in proxy) &&
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) {
            proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        }
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this
            .#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) {
            proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
        }
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this
            .#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) {
            proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
        }
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this
            .#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) {
            proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
        }
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this
            .#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) {
            proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
        }
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this
            .#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) {
            proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
        }
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this
            .#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) {
            proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        }
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this
            .#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) {
            proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        }
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 ||
            !("alias" in proxy) &&
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) {
            proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        }
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this
            .#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) {
            proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        }
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 ||
            !("service" in proxy) &&
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) {
            proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        }
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this
            .#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) {
            proxy.followedMessage =
                _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
        }
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this
            .#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) {
            proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Group " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Group " + inspect(proxy, options);
    }
}
_d = Group;
/** A Link is an indirect, qualified reference to a resource identified by a URL.
 * The fundamental model for links is established by RFC 5988. Many of the
 * properties defined by the Activity Vocabulary allow values that are either
 * instances of {@link Object} or {@link Link}. When a {@link Link} is used,
 * it establishes a qualified relation connecting the subject (the containing
 * object) to the resource identified by the `href`. Properties of
 * the {@link Link} are properties of the reference as opposed to properties of
 * the resource.
 */
export class Link {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link Link}: `https://www.w3.org/ns/activitystreams#Link`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Link");
    }
    #_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [];
    #_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [];
    #_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
    #_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
    #_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [];
    #_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
    #_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
    #_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
    /**
     * Constructs a new instance of Link with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("href" in values && values.href != null) {
            if (values.href instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [values.href];
            }
            else {
                throw new TypeError("The href must be of type " +
                    "URL" + ".");
            }
        }
        if ("rel" in values && values.rel != null) {
            if (typeof values.rel === "string") {
                // @ts-ignore: type is checked above.
                this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [values.rel];
            }
            else {
                throw new TypeError("The rel must be of type " +
                    "string" + ".");
            }
        }
        if ("rels" in values && values.rels != null) {
            if ("rel" in values &&
                values.rel != null) {
                throw new TypeError("Cannot initialize both rel and " +
                    "rels at the same time.");
            }
            if (Array.isArray(values.rels) &&
                values.rels.every((v) => typeof v === "string")) {
                // @ts-ignore: type is checked above.
                this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = values.rels;
            }
            else {
                throw new TypeError("The rels must be an array of type " +
                    "string" + ".");
            }
        }
        if ("mediaType" in values && values.mediaType != null) {
            if (typeof values.mediaType === "string") {
                // @ts-ignore: type is checked above.
                this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
            }
            else {
                throw new TypeError("The mediaType must be of type " +
                    "string" + ".");
            }
        }
        if ("name" in values && values.name != null) {
            if (typeof values.name === "string" || values.name instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
            }
            else {
                throw new TypeError("The name must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("names" in values && values.names != null) {
            if ("name" in values &&
                values.name != null) {
                throw new TypeError("Cannot initialize both name and " +
                    "names at the same time.");
            }
            if (Array.isArray(values.names) &&
                values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
            }
            else {
                throw new TypeError("The names must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("language" in values && values.language != null) {
            if (values.language instanceof LanguageTag) {
                // @ts-ignore: type is checked above.
                this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [values.language];
            }
            else {
                throw new TypeError("The language must be of type " +
                    "LanguageTag" + ".");
            }
        }
        if ("height" in values && values.height != null) {
            if (typeof values.height === "number" && Number.isInteger(values.height) &&
                values.height >= 0) {
                // @ts-ignore: type is checked above.
                this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
            }
            else {
                throw new TypeError("The height must be of type " +
                    "number" + ".");
            }
        }
        if ("width" in values && values.width != null) {
            if (typeof values.width === "number" && Number.isInteger(values.width) &&
                values.width >= 0) {
                // @ts-ignore: type is checked above.
                this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
            }
            else {
                throw new TypeError("The width must be of type " +
                    "number" + ".");
            }
        }
        if ("previews" in values && values.previews != null) {
            if (Array.isArray(values.previews) &&
                values.previews.every((v) => v instanceof _e || v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
            }
            else {
                throw new TypeError("The previews must be an array of type " +
                    "Link | Object | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href =
            this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href;
        if ("href" in values && values.href != null) {
            if (values.href instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [values.href];
            }
            else {
                throw new TypeError("The href must be of type " +
                    "URL" + ".");
            }
        }
        clone.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel =
            this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
        if ("rel" in values && values.rel != null) {
            if (typeof values.rel === "string") {
                // @ts-ignore: type is checked above.
                clone.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [values.rel];
            }
            else {
                throw new TypeError("The rel must be of type " +
                    "string" + ".");
            }
        }
        if ("rels" in values && values.rels != null) {
            if ("rel" in values &&
                values.rel != null) {
                throw new TypeError("Cannot update both rel and " +
                    "rels at the same time.");
            }
            if (Array.isArray(values.rels) &&
                values.rels.every((v) => typeof v === "string")) {
                // @ts-ignore: type is checked above.
                clone.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = values.rels;
            }
            else {
                throw new TypeError("The rels must be an array of type " +
                    "string" + ".");
            }
        }
        clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType =
            this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
        if ("mediaType" in values && values.mediaType != null) {
            if (typeof values.mediaType === "string") {
                // @ts-ignore: type is checked above.
                clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
            }
            else {
                throw new TypeError("The mediaType must be of type " +
                    "string" + ".");
            }
        }
        clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name =
            this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        if ("name" in values && values.name != null) {
            if (typeof values.name === "string" || values.name instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
            }
            else {
                throw new TypeError("The name must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("names" in values && values.names != null) {
            if ("name" in values &&
                values.name != null) {
                throw new TypeError("Cannot update both name and " +
                    "names at the same time.");
            }
            if (Array.isArray(values.names) &&
                values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
            }
            else {
                throw new TypeError("The names must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang =
            this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang;
        if ("language" in values && values.language != null) {
            if (values.language instanceof LanguageTag) {
                // @ts-ignore: type is checked above.
                clone.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [values.language];
            }
            else {
                throw new TypeError("The language must be of type " +
                    "LanguageTag" + ".");
            }
        }
        clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height =
            this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
        if ("height" in values && values.height != null) {
            if (typeof values.height === "number" && Number.isInteger(values.height) &&
                values.height >= 0) {
                // @ts-ignore: type is checked above.
                clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
            }
            else {
                throw new TypeError("The height must be of type " +
                    "number" + ".");
            }
        }
        clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width =
            this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
        if ("width" in values && values.width != null) {
            if (typeof values.width === "number" && Number.isInteger(values.width) &&
                values.width >= 0) {
                // @ts-ignore: type is checked above.
                clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
            }
            else {
                throw new TypeError("The width must be of type " +
                    "number" + ".");
            }
        }
        clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview =
            this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        if ("previews" in values && values.previews != null) {
            if (Array.isArray(values.previews) &&
                values.previews.every((v) => v instanceof _e || v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
            }
            else {
                throw new TypeError("The previews must be an array of type " +
                    "Link | Object | URL" + ".");
            }
        }
        return clone;
    }
    /** The target resource pointed to by a {@link Link}.
     */
    get href() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href.length < 1)
            return null;
        return this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href[0];
    }
    /** A link relation associated with a {@link Link}. The value MUST conform to
     * both the HTML5 and RFC 5988 "link relation" definitions.
     *
     * In the HTML5, any string not containing the space (U+0020), tab (U+0009),
     * LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
     * be used as a valid link relation.
     */
    get rel() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length < 1)
            return null;
        return this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel[0];
    }
    /** A link relation associated with a {@link Link}. The value MUST conform to
     * both the HTML5 and RFC 5988 "link relation" definitions.
     *
     * In the HTML5, any string not containing the space (U+0020), tab (U+0009),
     * LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
     * be used as a valid link relation.
     */
    get rels() {
        return this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
    }
    /** When used on a {@link Link}, identifies the MIME media type of the
     * referenced resource.
     */
    get mediaType() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length < 1)
            return null;
        return this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
    }
    /** A simple, human-readable, plain-text name for the object. HTML markup MUST
     * NOT be included. The name MAY be expressed using multiple language-tagged
     * values.
     */
    get name() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length < 1)
            return null;
        return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
    }
    /** A simple, human-readable, plain-text name for the object. HTML markup MUST
     * NOT be included. The name MAY be expressed using multiple language-tagged
     * values.
     */
    get names() {
        return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
    }
    /** Hints as to the language used by the target resource.
     * Value MUST be a BCP 47 Language-Tag.
     */
    get language() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang.length < 1)
            return null;
        return this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang[0];
    }
    /** On a {@link Link}, specifies a hint as to the rendering height in
     * device-independent pixels of the linked resource.
     */
    get height() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length < 1)
            return null;
        return this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
    }
    /** On a {@link Link}, specifies a hint as to the rendering width in
     * device-independent pixels of the linked resource.
     */
    get width() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length < 1)
            return null;
        return this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
    }
    async #fetchPreview(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#preview_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #preview_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await _e.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Link",
                "https://www.w3.org/ns/activitystreams#Object",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Link.getPreviews},
     * but returns their `@id`s instead of the objects themselves.
     */
    get previewIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies an entity that provides a preview of this object.
     */
    async *getPreviews(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchPreview(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "preview" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["preview"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#preview_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = {};
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["href"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["rel"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["mediaType"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["name"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang) {
                const item = v.compact();
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["hreflang"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["height"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["width"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof _e
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["preview"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Link";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = "https://www.w3.org/ns/activitystreams";
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href) {
            const element = { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#href"] = propValue;
        }
        array = [];
        for (const v of this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#rel"] = propValue;
        }
        array = [];
        for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#mediaType"] = propValue;
        }
        array = [];
        for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#name"] = propValue;
        }
        array = [];
        for (const v of this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang) {
            const element = { "@value": v.compact() };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#hreflang"] = propValue;
        }
        array = [];
        for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#height"] = propValue;
        }
        array = [];
        for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#width"] = propValue;
        }
        array = [];
        for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof _e
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#preview"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Link"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://www.w3.org/ns/activitystreams";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name != null &&
            this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0)
            return false;
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Link__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Link__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Hashtag")) {
                return await Hashtag.fromJsonLd(json, options);
            }
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Mention")) {
                return await Mention.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Link")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [];
        let _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array = values["https://www.w3.org/ns/activitystreams#href"];
        for (const v of _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array == null
            ? []
            : _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array.length === 1 &&
                "@list" in _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array[0]
                ? _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array[0]["@list"]
                : _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array) {
            if (v == null)
                continue;
            _pVjLsybKQdmkjuU7MHjiVmNnuj7_href.push(new URL(v["@id"]));
        }
        instance.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href =
            _pVjLsybKQdmkjuU7MHjiVmNnuj7_href;
        const _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [];
        let _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array = values["https://www.w3.org/ns/activitystreams#rel"];
        for (const v of _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array == null
            ? []
            : _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array.length === 1 &&
                "@list" in _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array[0]
                ? _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array[0]["@list"]
                : _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array) {
            if (v == null)
                continue;
            _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.push(v["@value"]);
        }
        instance.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel =
            _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
        const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
        let _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array = values["https://www.w3.org/ns/activitystreams#mediaType"];
        for (const v of _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array == null
            ? []
            : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array.length === 1 &&
                "@list" in _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]
                ? _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]["@list"]
                : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array) {
            if (v == null)
                continue;
            _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.push(v["@value"]);
        }
        instance.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType =
            _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
        const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
        let _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array = values["https://www.w3.org/ns/activitystreams#name"];
        for (const v of _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array == null
            ? []
            : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array.length === 1 &&
                "@list" in _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]
                ? _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]["@list"]
                : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.push(decoded);
        }
        instance.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name =
            _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        const _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [];
        let _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array = values["https://www.w3.org/ns/activitystreams#hreflang"];
        for (const v of _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array == null
            ? []
            : _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array.length === 1 &&
                "@list" in _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array[0]
                ? _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array[0]["@list"]
                : _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array) {
            if (v == null)
                continue;
            _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang.push(parseLanguageTag(v["@value"]));
        }
        instance.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang =
            _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang;
        const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
        let _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array = values["https://www.w3.org/ns/activitystreams#height"];
        for (const v of _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array == null
            ? []
            : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array.length === 1 &&
                "@list" in _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0]
                ? _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0]["@list"]
                : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array) {
            if (v == null)
                continue;
            _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.push(v["@value"]);
        }
        instance.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height =
            _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
        const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
        let _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array = values["https://www.w3.org/ns/activitystreams#width"];
        for (const v of _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array == null
            ? []
            : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array.length === 1 &&
                "@list" in _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0]
                ? _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0]["@list"]
                : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array) {
            if (v == null)
                continue;
            _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.push(v["@value"]);
        }
        instance.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width =
            _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
        const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
        let _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array = values["https://www.w3.org/ns/activitystreams#preview"];
        for (const v of _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array == null
            ? []
            : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array.length === 1 &&
                "@list" in _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0]
                ? _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0]["@list"]
                : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Link",
                    "https://www.w3.org/ns/activitystreams#Hashtag",
                    "https://www.w3.org/ns/activitystreams#Mention",
                ].some((t) => v["@type"].includes(t))
                ? await _e.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Object",
                        "http://joinmastodon.org/ns#Emoji",
                        "http://litepub.social/ns#ChatMessage",
                        "https://www.w3.org/ns/activitystreams#Activity",
                        "http://litepub.social/ns#EmojiReact",
                        "https://www.w3.org/ns/activitystreams#Accept",
                        "https://www.w3.org/ns/activitystreams#TentativeAccept",
                        "https://www.w3.org/ns/activitystreams#Add",
                        "https://www.w3.org/ns/activitystreams#Announce",
                        "https://www.w3.org/ns/activitystreams#Create",
                        "https://www.w3.org/ns/activitystreams#Delete",
                        "https://www.w3.org/ns/activitystreams#Dislike",
                        "https://www.w3.org/ns/activitystreams#Flag",
                        "https://www.w3.org/ns/activitystreams#Follow",
                        "https://www.w3.org/ns/activitystreams#Ignore",
                        "https://www.w3.org/ns/activitystreams#Block",
                        "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                        "https://www.w3.org/ns/activitystreams#Arrive",
                        "https://www.w3.org/ns/activitystreams#Question",
                        "https://www.w3.org/ns/activitystreams#Travel",
                        "https://www.w3.org/ns/activitystreams#Join",
                        "https://www.w3.org/ns/activitystreams#Leave",
                        "https://www.w3.org/ns/activitystreams#Like",
                        "https://www.w3.org/ns/activitystreams#Listen",
                        "https://www.w3.org/ns/activitystreams#Move",
                        "https://www.w3.org/ns/activitystreams#Offer",
                        "https://www.w3.org/ns/activitystreams#Invite",
                        "https://www.w3.org/ns/activitystreams#Read",
                        "https://www.w3.org/ns/activitystreams#Reject",
                        "https://www.w3.org/ns/activitystreams#TentativeReject",
                        "https://www.w3.org/ns/activitystreams#Remove",
                        "https://www.w3.org/ns/activitystreams#Undo",
                        "https://www.w3.org/ns/activitystreams#Update",
                        "https://www.w3.org/ns/activitystreams#View",
                        "https://www.w3.org/ns/activitystreams#Application",
                        "https://www.w3.org/ns/activitystreams#Article",
                        "https://www.w3.org/ns/activitystreams#Collection",
                        "https://www.w3.org/ns/activitystreams#CollectionPage",
                        "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                        "https://www.w3.org/ns/activitystreams#OrderedCollection",
                        "https://www.w3.org/ns/activitystreams#Document",
                        "https://www.w3.org/ns/activitystreams#Audio",
                        "https://www.w3.org/ns/activitystreams#Image",
                        "https://www.w3.org/ns/activitystreams#Page",
                        "https://www.w3.org/ns/activitystreams#Video",
                        "https://www.w3.org/ns/activitystreams#Event",
                        "https://www.w3.org/ns/activitystreams#Group",
                        "https://www.w3.org/ns/activitystreams#Note",
                        "https://www.w3.org/ns/activitystreams#Organization",
                        "https://www.w3.org/ns/activitystreams#Person",
                        "https://www.w3.org/ns/activitystreams#Place",
                        "https://www.w3.org/ns/activitystreams#Profile",
                        "https://www.w3.org/ns/activitystreams#Relationship",
                        "https://www.w3.org/ns/activitystreams#Service",
                        "https://www.w3.org/ns/activitystreams#Tombstone",
                    ].some((t) => v["@type"].includes(t))
                    ? await Object.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(decoded);
        }
        instance.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview =
            _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _pVjLsybKQdmkjuU7MHjiVmNnuj7_href = this
            .#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_pVjLsybKQdmkjuU7MHjiVmNnuj7_href.length == 1) {
            proxy.href = _pVjLsybKQdmkjuU7MHjiVmNnuj7_href[0];
        }
        const _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = this
            .#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length == 1) {
            proxy.rel = _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel[0];
        }
        if (_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length > 1 ||
            !("rel" in proxy) &&
                _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length > 0) {
            proxy.rels = _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
        }
        const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this
            .#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length == 1) {
            proxy.mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
        }
        const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this
            .#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length == 1) {
            proxy.name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
        }
        if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 1 ||
            !("name" in proxy) &&
                _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0) {
            proxy.names = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
        }
        const _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = this
            .#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang.length == 1) {
            proxy.language = _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang[0];
        }
        const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = this
            .#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length == 1) {
            proxy.height = _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
        }
        const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = this
            .#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length == 1) {
            proxy.width = _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
        }
        const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = this
            .#_gCVTegXxWWCw6wWRxa1QF65zusg_preview
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 1 ||
            !("preview" in proxy) &&
                _gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 0) {
            proxy.previews = _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Link " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Link " + inspect(proxy, options);
    }
}
_e = Link;
/** A specialized {@link Link} that represents an #hashtag.
 *
 * See also <https://swicg.github.io/miscellany/#Hashtag>.
 */
export class Hashtag extends Link {
    /**
     * The type URI of {@link Hashtag}: `https://www.w3.org/ns/activitystreams#Hashtag`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Hashtag");
    }
    /**
     * Constructs a new instance of Hashtag with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Hashtag";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = ["https://www.w3.org/ns/activitystreams", {
                    "Hashtag": "as:Hashtag",
                }];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Hashtag"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            ["https://www.w3.org/ns/activitystreams", { "Hashtag": "as:Hashtag" }];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Hashtag__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Hashtag__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Hashtag")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Hashtag)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Hashtag " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Hashtag " + inspect(proxy, options);
    }
}
/** An image document of any kind.
 */
export class Image extends Document {
    /**
     * The type URI of {@link Image}: `https://www.w3.org/ns/activitystreams#Image`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Image");
    }
    /**
     * Constructs a new instance of Image with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Image";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = "https://www.w3.org/ns/activitystreams";
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Image"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://www.w3.org/ns/activitystreams";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Image__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Image__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Image")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Image)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Image " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Image " + inspect(proxy, options);
    }
}
/** Indicates that the actor is offering the object.
 * If specified, the target indicates the entity to which
 * the object is being offered.
 */
export class Offer extends Activity {
    /**
     * The type URI of {@link Offer}: `https://www.w3.org/ns/activitystreams#Offer`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Offer");
    }
    /**
     * Constructs a new instance of Offer with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Offer"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Offer__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Offer__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) {
                return await Invite.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Offer")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Offer)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Offer " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Offer " + inspect(proxy, options);
    }
}
/** A specialization of `Offer` in which the `actor` is extending an invitation
 * for the `object` to the `target`.
 */
export class Invite extends Offer {
    /**
     * The type URI of {@link Invite}: `https://www.w3.org/ns/activitystreams#Invite`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Invite");
    }
    /**
     * Constructs a new instance of Invite with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Invite"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Invite__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Invite__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Invite)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Invite " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Invite " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has joined the `object`.
 * The `target` and `origin` typically have no defined meaning.
 */
export class Join extends Activity {
    /**
     * The type URI of {@link Join}: `https://www.w3.org/ns/activitystreams#Join`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Join");
    }
    /**
     * Constructs a new instance of Join with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Join"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Join__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Join__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Join")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Join)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Join " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Join " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has left the `object`.
 * The `target` and `origin` typically have no meaning.
 */
export class Leave extends Activity {
    /**
     * The type URI of {@link Leave}: `https://www.w3.org/ns/activitystreams#Leave`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Leave");
    }
    /**
     * Constructs a new instance of Leave with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Leave"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Leave__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Leave__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Leave")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Leave)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Leave " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Leave " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` likes, recommends or endorses the `object`.
 * The `target` and `origin` typically have no defined meaning.
 */
export class Like extends Activity {
    /**
     * The type URI of {@link Like}: `https://www.w3.org/ns/activitystreams#Like`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Like");
    }
    /**
     * Constructs a new instance of Like with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Like"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                { "toot": "http://joinmastodon.org/ns#", "Emoji": "toot:Emoji" },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Like__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Like__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Like")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Like)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Like " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Like " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has listened to the `object`.
 */
export class Listen extends Activity {
    /**
     * The type URI of {@link Listen}: `https://www.w3.org/ns/activitystreams#Listen`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Listen");
    }
    /**
     * Constructs a new instance of Listen with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Listen"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Listen__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Listen__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Listen")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Listen)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Listen " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Listen " + inspect(proxy, options);
    }
}
/** A specialized {@link Link} that represents an @mention.
 */
export class Mention extends Link {
    /**
     * The type URI of {@link Mention}: `https://www.w3.org/ns/activitystreams#Mention`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Mention");
    }
    /**
     * Constructs a new instance of Mention with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Mention";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = "https://www.w3.org/ns/activitystreams";
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Mention"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://www.w3.org/ns/activitystreams";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Mention__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Mention__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Mention")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Mention)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Mention " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Mention " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has moved `object` from `origin` to `target`.
 * If the `origin` or `target` are not specified,
 * either can be determined by context.
 */
export class Move extends Activity {
    /**
     * The type URI of {@link Move}: `https://www.w3.org/ns/activitystreams#Move`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Move");
    }
    /**
     * Constructs a new instance of Move with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Move"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Move__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Move__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Move")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Move)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Move " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Move " + inspect(proxy, options);
    }
}
/** Represents a short written work typically less than a single paragraph in
 * length.
 */
export class Note extends Object {
    /**
     * The type URI of {@link Note}: `https://www.w3.org/ns/activitystreams#Note`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Note");
    }
    #_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
    /**
     * Constructs a new instance of Note with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
        return clone;
    }
    /** The URI of the ActivityStreams object that this object quotes.
     *
     * This property sets three JSON-LD properties at once under the hood:
     *
     * 1. https://www.w3.org/ns/activitystreams#quoteUrl
     * 2. https://misskey-hub.net/ns#_misskey_quote
     * 3. http://fedibird.com/ns#quoteUri
     *
     * When a JSON-LD object is parsed, this property is filled with one of
     * the values of those three properties in order.
     */
    get quoteUrl() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1)
            return null;
        return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
                const item = v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["quoteUrl"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
                result["_misskey_quote"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
                result["quoteUri"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Note";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
            const element = { "@value": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
            values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
            values["http://fedibird.com/ns#quoteUri"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Note"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Note__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Note__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Note")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Note)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
        let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["https://misskey-hub.net/ns#_misskey_quote"];
        }
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["http://fedibird.com/ns#quoteUri"];
        }
        for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null
            ? []
            : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 &&
                "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]
                ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"]
                : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
            if (v == null)
                continue;
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
        }
        instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this
            .#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) {
            proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Note " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Note " + inspect(proxy, options);
    }
}
/** A subtype of {@link Collection} in which members of the logical collection
 * are assumed to always be strictly ordered.
 */
export class OrderedCollection extends Collection {
    /**
     * The type URI of {@link OrderedCollection}: `https://www.w3.org/ns/activitystreams#OrderedCollection`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#OrderedCollection");
    }
    #_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
    /**
     * Constructs a new instance of OrderedCollection with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("items" in values && values.items != null) {
            if (Array.isArray(values.items) &&
                values.items.every((v) => v instanceof Object || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
            }
            else {
                throw new TypeError("The items must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items =
            this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        if ("items" in values && values.items != null) {
            if (Array.isArray(values.items) &&
                values.items.every((v) => v instanceof Object || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
            }
            else {
                throw new TypeError("The items must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        return clone;
    }
    async #fetchItem(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#item_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #item_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link OrderedCollection.getItems},
     * but returns their `@id`s instead of the objects themselves.
     */
    get itemIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies the items contained in a collection.  The items might be ordered
     * or unordered.
     */
    async *getItems(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchItem(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "orderedItems" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["orderedItems"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#item_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            delete result["items"];
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Object
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["orderedItems"] = compactItems;
            }
            result["type"] = "OrderedCollection";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Object
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = { "@list": array };
            values["https://www.w3.org/ns/activitystreams#items"] = propValue;
        }
        values["@type"] = [
            "https://www.w3.org/ns/activitystreams#OrderedCollection",
        ];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__OrderedCollection__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__OrderedCollection__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof OrderedCollection)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
        let _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array = values["https://www.w3.org/ns/activitystreams#items"];
        for (const v of _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array == null
            ? []
            : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array.length === 1 &&
                "@list" in _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]
                ? _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]["@list"]
                : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await Object.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(decoded);
        }
        instance.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items =
            _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this
            .#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 1 ||
            !("item" in proxy) &&
                _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 0) {
            proxy.items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "OrderedCollection " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "OrderedCollection " + inspect(proxy, options);
    }
}
/** Used to represent ordered subsets of items from an `OrderedCollection`.
 * Refer to the Activity Streams 2.0 Core for a complete description of
 * the `OrderedCollectionPage` object.
 */
export class OrderedCollectionPage extends CollectionPage {
    /**
     * The type URI of {@link OrderedCollectionPage}: `https://www.w3.org/ns/activitystreams#OrderedCollectionPage`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#OrderedCollectionPage");
    }
    #_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
    #_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [];
    /**
     * Constructs a new instance of OrderedCollectionPage with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("items" in values && values.items != null) {
            if (Array.isArray(values.items) &&
                values.items.every((v) => v instanceof Object || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
            }
            else {
                throw new TypeError("The items must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        if ("startIndex" in values && values.startIndex != null) {
            if (typeof values.startIndex === "number" &&
                Number.isInteger(values.startIndex) && values.startIndex >= 0) {
                // @ts-ignore: type is checked above.
                this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [values.startIndex];
            }
            else {
                throw new TypeError("The startIndex must be of type " +
                    "number" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items =
            this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        if ("items" in values && values.items != null) {
            if (Array.isArray(values.items) &&
                values.items.every((v) => v instanceof Object || v instanceof Link || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
            }
            else {
                throw new TypeError("The items must be an array of type " +
                    "Object | Link | URL" + ".");
            }
        }
        clone.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex =
            this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex;
        if ("startIndex" in values && values.startIndex != null) {
            if (typeof values.startIndex === "number" &&
                Number.isInteger(values.startIndex) && values.startIndex >= 0) {
                // @ts-ignore: type is checked above.
                clone.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [values.startIndex];
            }
            else {
                throw new TypeError("The startIndex must be of type " +
                    "number" + ".");
            }
        }
        return clone;
    }
    async #fetchItem(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#item_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #item_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Link.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Object",
                "https://www.w3.org/ns/activitystreams#Link",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link OrderedCollectionPage.getItems},
     * but returns their `@id`s instead of the objects themselves.
     */
    get itemIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies the items contained in a collection.  The items might be ordered
     * or unordered.
     */
    async *getItems(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchItem(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "orderedItems" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["orderedItems"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#item_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** A non-negative integer value identifying the relative position within
     * the logical view of a strictly ordered collection.
     */
    get startIndex() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex.length < 1)
            return null;
        return this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            delete result["items"];
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Object
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["orderedItems"] = compactItems;
            }
            compactItems = [];
            for (const v of this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["startIndex"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "OrderedCollectionPage";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Object
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = { "@list": array };
            values["https://www.w3.org/ns/activitystreams#items"] = propValue;
        }
        array = [];
        for (const v of this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#startIndex"] = propValue;
        }
        values["@type"] = [
            "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
        ];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__OrderedCollectionPage__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__OrderedCollectionPage__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof OrderedCollectionPage)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
        let _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array = values["https://www.w3.org/ns/activitystreams#items"];
        for (const v of _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array == null
            ? []
            : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array.length === 1 &&
                "@list" in _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]
                ? _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]["@list"]
                : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                [
                    "https://www.w3.org/ns/activitystreams#Object",
                    "http://joinmastodon.org/ns#Emoji",
                    "http://litepub.social/ns#ChatMessage",
                    "https://www.w3.org/ns/activitystreams#Activity",
                    "http://litepub.social/ns#EmojiReact",
                    "https://www.w3.org/ns/activitystreams#Accept",
                    "https://www.w3.org/ns/activitystreams#TentativeAccept",
                    "https://www.w3.org/ns/activitystreams#Add",
                    "https://www.w3.org/ns/activitystreams#Announce",
                    "https://www.w3.org/ns/activitystreams#Create",
                    "https://www.w3.org/ns/activitystreams#Delete",
                    "https://www.w3.org/ns/activitystreams#Dislike",
                    "https://www.w3.org/ns/activitystreams#Flag",
                    "https://www.w3.org/ns/activitystreams#Follow",
                    "https://www.w3.org/ns/activitystreams#Ignore",
                    "https://www.w3.org/ns/activitystreams#Block",
                    "https://www.w3.org/ns/activitystreams#IntransitiveActivity",
                    "https://www.w3.org/ns/activitystreams#Arrive",
                    "https://www.w3.org/ns/activitystreams#Question",
                    "https://www.w3.org/ns/activitystreams#Travel",
                    "https://www.w3.org/ns/activitystreams#Join",
                    "https://www.w3.org/ns/activitystreams#Leave",
                    "https://www.w3.org/ns/activitystreams#Like",
                    "https://www.w3.org/ns/activitystreams#Listen",
                    "https://www.w3.org/ns/activitystreams#Move",
                    "https://www.w3.org/ns/activitystreams#Offer",
                    "https://www.w3.org/ns/activitystreams#Invite",
                    "https://www.w3.org/ns/activitystreams#Read",
                    "https://www.w3.org/ns/activitystreams#Reject",
                    "https://www.w3.org/ns/activitystreams#TentativeReject",
                    "https://www.w3.org/ns/activitystreams#Remove",
                    "https://www.w3.org/ns/activitystreams#Undo",
                    "https://www.w3.org/ns/activitystreams#Update",
                    "https://www.w3.org/ns/activitystreams#View",
                    "https://www.w3.org/ns/activitystreams#Application",
                    "https://www.w3.org/ns/activitystreams#Article",
                    "https://www.w3.org/ns/activitystreams#Collection",
                    "https://www.w3.org/ns/activitystreams#CollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
                    "https://www.w3.org/ns/activitystreams#OrderedCollection",
                    "https://www.w3.org/ns/activitystreams#Document",
                    "https://www.w3.org/ns/activitystreams#Audio",
                    "https://www.w3.org/ns/activitystreams#Image",
                    "https://www.w3.org/ns/activitystreams#Page",
                    "https://www.w3.org/ns/activitystreams#Video",
                    "https://www.w3.org/ns/activitystreams#Event",
                    "https://www.w3.org/ns/activitystreams#Group",
                    "https://www.w3.org/ns/activitystreams#Note",
                    "https://www.w3.org/ns/activitystreams#Organization",
                    "https://www.w3.org/ns/activitystreams#Person",
                    "https://www.w3.org/ns/activitystreams#Place",
                    "https://www.w3.org/ns/activitystreams#Profile",
                    "https://www.w3.org/ns/activitystreams#Relationship",
                    "https://www.w3.org/ns/activitystreams#Service",
                    "https://www.w3.org/ns/activitystreams#Tombstone",
                ].some((t) => v["@type"].includes(t))
                ? await Object.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    [
                        "https://www.w3.org/ns/activitystreams#Link",
                        "https://www.w3.org/ns/activitystreams#Hashtag",
                        "https://www.w3.org/ns/activitystreams#Mention",
                    ].some((t) => v["@type"].includes(t))
                    ? await Link.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(decoded);
        }
        instance.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items =
            _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        const _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [];
        let _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array = values["https://www.w3.org/ns/activitystreams#startIndex"];
        for (const v of _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array == null
            ? []
            : _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array.length === 1 &&
                "@list" in _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array[0]
                ? _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array[0]["@list"]
                : _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array) {
            if (v == null)
                continue;
            _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex.push(v["@value"]);
        }
        instance.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex =
            _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this
            .#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 1 ||
            !("item" in proxy) &&
                _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 0) {
            proxy.items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
        }
        const _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = this
            .#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex.length == 1) {
            proxy.startIndex = _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "OrderedCollectionPage " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "OrderedCollectionPage " + inspect(proxy, options);
    }
}
/** Represents an organization.
 */
export class Organization extends Object {
    /**
     * The type URI of {@link Organization}: `https://www.w3.org/ns/activitystreams#Organization`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Organization");
    }
    #_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
    #_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
    #_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
    #_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
    #_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
    #_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
    #_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
    #_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
    #_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
    #_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
    #_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
    #_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
    #_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
    #_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
    #_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
    #_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
    #_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
    #_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
    #_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
    #_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
    #_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
    #_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
    /**
     * Constructs a new instance of Organization with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot initialize both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot initialize both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot initialize both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof Group ||
                values.successor instanceof _f ||
                values.successor instanceof Person ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof Group ||
                values.alias instanceof _f ||
                values.alias instanceof Person || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot initialize both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof _f || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot initialize both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot update both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot update both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot update both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [
                    values.discoverable,
                ];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof Group ||
                values.successor instanceof _f ||
                values.successor instanceof Person ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof Group ||
                values.alias instanceof _f ||
                values.alias instanceof Person || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot update both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof _f || v instanceof Person ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot update both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
        return clone;
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsername() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) {
            return null;
        }
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsernames() {
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
    }
    async #fetchPublicKey(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#publicKey_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #publicKey_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CryptographicKey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Key"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getPublicKey},
     * but returns its `@id` URL instead of the object itself.
     */
    get publicKeyId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** A public part of the key pair owned by this actor.
     */
    async getPublicKey(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPublicKey(v, options);
            if (fetched == null)
                return null;
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "publicKey" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["publicKey"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#publicKey_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Organization.getPublicKeys},
     * but returns their `@id`s instead of the objects themselves.
     */
    get publicKeyIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A public part of the key pair owned by this actor.
     */
    async *getPublicKeys(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchPublicKey(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "publicKey" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["publicKey"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#publicKey_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchAssertionMethod(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#assertionMethod_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #assertionMethod_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Multikey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Multikey"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getAssertionMethod},
     * but returns its `@id` URL instead of the object itself.
     */
    get assertionMethodId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async getAssertionMethod(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAssertionMethod(v, options);
            if (fetched == null)
                return null;
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "assertionMethod" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["assertionMethod"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#assertionMethod_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Organization.getAssertionMethods},
     * but returns their `@id`s instead of the objects themselves.
     */
    get assertionMethodIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async *getAssertionMethods(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAssertionMethod(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "assertionMethod" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["assertionMethod"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#assertionMethod_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** When `true`, conveys that for this actor, follow requests are not usually
     * automatically approved, but instead are examined by a person who may accept
     * or reject the request, at some time in the future.  Setting of `false`
     * conveys no information and may be ignored.  This information is typically
     * used to affect display of accounts, such as showing an account as private or
     * locked.
     */
    get manuallyApprovesFollowers() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1)
            return null;
        return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
    }
    async #fetchInbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#inbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #inbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getInbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get inboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The inbox stream contains all activities received by the actor.  The server
     * SHOULD filter content according to the requester's permission.  In general,
     * the owner of an inbox is likely to be able to access all of their inbox
     * contents.  Depending on access control, some other content may be public,
     * whereas other content may require authentication for non-owner users,
     * if they can access the inbox at all.
     *
     * The server MUST perform de-duplication of activities returned by the inbox.
     * Duplication can occur if an activity is addressed both to an actor's
     * followers, and a specific actor who also follows the recipient actor,
     * and the server has failed to de-duplicate the recipients list.
     * Such deduplication MUST be performed by comparing the `id` of the activities
     * and dropping any activities already seen.
     */
    async getInbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchInbox(v, options);
            if (fetched == null)
                return null;
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "inbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["inbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#inbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchOutbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#outbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #outbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getOutbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get outboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The outbox stream contains activities the user has published,
     * subject to the ability of the requestor to retrieve the activity
     * (that is, the contents of the outbox are filtered by the permissions of
     * the person reading it).  If a user submits a request without
     * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
     * the server should respond with all of the
     * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
     * This could potentially be all relevant objects published by the user,
     * though the number of available items is left to the discretion of those
     * implementing and deploying the server.
     */
    async getOutbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchOutbox(v, options);
            if (fetched == null)
                return null;
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "outbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["outbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#outbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowing(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#following_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #following_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getFollowing},
     * but returns its `@id` URL instead of the object itself.
     */
    get followingId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everybody that the actor has followed, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * The `following` collection MUST be either an {@link OrderedCollection}
     * or a {@link Collection} and MAY be filtered on privileges of
     * an authenticated user or as appropriate when no authentication is given.
     */
    async getFollowing(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowing(v, options);
            if (fetched == null)
                return null;
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "following" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["following"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#following_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowers(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#followers_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #followers_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getFollowers},
     * but returns its `@id` URL instead of the object itself.
     */
    get followersId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everyone who has sent a {@link Follow} activity
     * for the actor, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * This is where one would find a list of all the actors that are following
     * the actor.  The `followers` collection MUST be either
     * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
     * privileges of an authenticated user or as appropriate when no authentication
     * is given.
     */
    async getFollowers(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowers(v, options);
            if (fetched == null)
                return null;
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "followers" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["followers"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#followers_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchLiked(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#liked_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #liked_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getLiked},
     * but returns its `@id` URL instead of the object itself.
     */
    get likedId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of every object from all of the actor's {@link Like}
     * activities, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
     * The `liked` collection MUST be either an {@link OrderedCollection} or
     * a {@link Collection} and MAY be filtered on privileges of an authenticated
     * user or as appropriate when no authentication is given.
     */
    async getLiked(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLiked(v, options);
            if (fetched == null)
                return null;
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "liked" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["liked"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#liked_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeatured(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featured_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featured_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getFeatured},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "pinned statuses", or statuses that are always
     * featured at the top of people's profiles, is implemented using an extra
     * property `featured` on the actor object that points to a {@link Collection}
     * of objects.
     */
    async getFeatured(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeatured(v, options);
            if (fetched == null)
                return null;
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featured" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featured"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featured_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeaturedTags(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featuredTags_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featuredTags_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getFeaturedTags},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredTagsId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "featured hashtags", hashtags that are featured
     * at people's profiles, is implemented using an extra property `featuredTags`
     * on the actor object that points to a {@link Collection} of {@link Hashtag}
     * objects specifically.
     */
    async getFeaturedTags(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeaturedTags(v, options);
            if (fetched == null)
                return null;
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featuredTags" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featuredTags"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featuredTags_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchStream(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#stream_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #stream_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getStreams},
     * but returns their `@id`s instead of the objects themselves.
     */
    get streamIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A list of supplementary Collections which may be of interest.
     */
    async *getStreams(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchStream(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "streams" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["streams"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#stream_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** A JSON object which maps additional (typically server/domain-wide) endpoints
     * which may be useful either for this actor or someone referencing this actor.
     * This mapping may be nested inside the actor document as the value or may be
     * a link to a JSON-LD document with these properties.
     */
    get endpoints() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1)
            return null;
        return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
    }
    /** Allows users to opt-in or opt-out of discoverability features like
     * the profile directory.  This flag may also be used as an indicator of
     * the user's preferences toward being included in external discovery services,
     * such as search engines or other indexing tools.
     */
    get discoverable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1)
            return null;
        return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
    }
    /** Reports whether a user was locally suspended, for better handling of
     * these accounts.
     */
    get suspended() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1)
            return null;
        return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
    }
    /** Whether the actor is in-memorial state.
     */
    get memorial() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1)
            return null;
        return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
    }
    /** Whether the actor allows to be indexed.
     */
    get indexable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1)
            return null;
        return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
    }
    async #fetchSuccessor(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#successor_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #successor_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _f.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getSuccessor},
     * but returns its `@id` URL instead of the object itself.
     */
    get successorId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
     */
    async getSuccessor(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchSuccessor(v, options);
            if (fetched == null)
                return null;
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "movedTo" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["movedTo"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#successor_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchAlias(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#alias_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #alias_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _f.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getAlias},
     * but returns its `@id` URL instead of the object itself.
     */
    get aliasId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async getAlias(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAlias(v, options);
            if (fetched == null)
                return null;
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "alsoKnownAs" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["alsoKnownAs"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#alias_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Organization.getAliases},
     * but returns their `@id`s instead of the objects themselves.
     */
    get aliasIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async *getAliases(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAlias(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "alsoKnownAs" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["alsoKnownAs"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#alias_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchService(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#service_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #service_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await DidService.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/did#Service"].join(", "));
    }
    /**
     * Similar to
     * {@link Organization.getService},
     * but returns its `@id` URL instead of the object itself.
     */
    get serviceId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async getService(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchService(v, options);
            if (fetched == null)
                return null;
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "service" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["service"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#service_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Organization.getServices},
     * but returns their `@id`s instead of the objects themselves.
     */
    get serviceIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async *getServices(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchService(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "service" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["service"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#service_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** This value is used for `Actor` type objects to show message on followed.
     */
    get followedMessage() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1)
            return null;
        return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
    }
    /** Used on actors to indicate that they in some way identify as a cat,
     * expressed as a boolean value. If this property is set to `true`,
     * displaying the actor or their notes will have some special effects
     * attached in some clients.
     */
    get cat() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1)
            return null;
        return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["preferredUsername"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["publicKey"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["assertionMethod"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["manuallyApprovesFollowers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["inbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["outbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["following"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["followers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["liked"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featured"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featuredTags"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["streams"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
                const item = await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["endpoints"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["discoverable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["suspended"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["memorial"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["indexable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof _f
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["movedTo"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof _f
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["alsoKnownAs"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["service"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["_misskey_followedMessage"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["isCat"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Organization";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#preferredUsername"] =
                propValue;
        }
        array = [];
        for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#publicKey"] = propValue;
        }
        array = [];
        for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#assertionMethod"] = propValue;
        }
        array = [];
        for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
        }
        array = [];
        for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://www.w3.org/ns/ldp#inbox"] = propValue;
        }
        array = [];
        for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
        }
        array = [];
        for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#following"] = propValue;
        }
        array = [];
        for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
        }
        array = [];
        for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
        }
        array = [];
        for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featured"] = propValue;
        }
        array = [];
        for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featuredTags"] = propValue;
        }
        array = [];
        for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
        }
        array = [];
        for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
            const element = await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
        }
        array = [];
        for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#discoverable"] = propValue;
        }
        array = [];
        for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#suspended"] = propValue;
        }
        array = [];
        for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#memorial"] = propValue;
        }
        array = [];
        for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#indexable"] = propValue;
        }
        array = [];
        for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof _f
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
        }
        array = [];
        for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof _f
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
        }
        array = [];
        for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/did#service"] = propValue;
        }
        array = [];
        for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
        }
        array = [];
        for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#isCat"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Organization"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null &&
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0)
            return false;
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null &&
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0)
            return false;
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Organization__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Organization__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof _f)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
        let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
        for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null
            ? []
            : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 &&
                "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]
                ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"]
                : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
        }
        instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
        let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
        for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null
            ? []
            : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 &&
                "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]
                ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"]
                : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, options));
        }
        instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
        let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
        for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null
            ? []
            : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 &&
                "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]
                ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"]
                : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, options));
        }
        instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
        let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
        for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null
            ? []
            : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array
                .length === 1 &&
                "@list" in
                    _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]
                ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"]
                : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
            if (v == null)
                continue;
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
        }
        instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
        let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
        for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null
            ? []
            : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 &&
                "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]
                ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"]
                : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
        }
        instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
        let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
        for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null
            ? []
            : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 &&
                "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]
                ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"]
                : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
        }
        instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            _41QwhqJouoLg3h8dRPKat21brynC_outbox;
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
        let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
        for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null
            ? []
            : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 &&
                "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]
                ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"]
                : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
        let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
        for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null
            ? []
            : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 &&
                "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]
                ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"]
                : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
        let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
        for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null
            ? []
            : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 &&
                "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]
                ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"]
                : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
        let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
        for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null
            ? []
            : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 &&
                "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]
                ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"]
                : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
        let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
        for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null
            ? []
            : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 &&
                "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]
                ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"]
                : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
        let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
        for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null
            ? []
            : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 &&
                "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]
                ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"]
                : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
        let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
        for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null
            ? []
            : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 &&
                "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]
                ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"]
                : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
            if (v == null)
                continue;
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, options));
        }
        instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
        let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
        for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null
            ? []
            : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 &&
                "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]
                ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"]
                : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
            if (v == null)
                continue;
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
        }
        instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
        let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
        for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null
            ? []
            : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 &&
                "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]
                ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"]
                : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
            if (v == null)
                continue;
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
        }
        instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
        let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
        for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null
            ? []
            : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 &&
                "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]
                ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"]
                : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
            if (v == null)
                continue;
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
        }
        instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
        let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
        for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null
            ? []
            : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 &&
                "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]
                ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"]
                : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
            if (v == null)
                continue;
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
        }
        instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
        let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
        for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null
            ? []
            : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 &&
                "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]
                ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"]
                : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await _f.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
        }
        instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
        let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
        for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null
            ? []
            : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 &&
                "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]
                ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"]
                : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await _f.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
        }
        instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
        let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
        for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null
            ? []
            : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 &&
                "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]
                ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"]
                : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, options));
        }
        instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
        let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
        for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null
            ? []
            : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array
                .length === 1 &&
                "@list" in
                    _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]
                ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"]
                : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
            if (v == null)
                continue;
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
        }
        instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
        let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
        for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null
            ? []
            : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 &&
                "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]
                ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"]
                : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
            if (v == null)
                continue;
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
        }
        instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this
            .#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) {
            proxy.preferredUsername =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
        }
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 ||
            !("preferredUsername" in proxy) &&
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) {
            proxy.preferredUsernames =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        }
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this
            .#_axq166E2eZADq34V4MYUc8KMZdC_publicKey
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) {
            proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        }
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 ||
            !("publicKey" in proxy) &&
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) {
            proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        }
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this
            .#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) {
            proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        }
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 ||
            !("assertionMethod" in proxy) &&
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) {
            proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        }
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this
            .#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) {
            proxy.manuallyApprovesFollowers =
                _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
        }
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this
            .#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) {
            proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        }
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this
            .#_41QwhqJouoLg3h8dRPKat21brynC_outbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) {
            proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        }
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this
            .#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) {
            proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        }
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this
            .#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) {
            proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        }
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this
            .#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) {
            proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        }
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this
            .#_4N1vBJzXDf8NbBumeECQMFvKetja_featured
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) {
            proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        }
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this
            .#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) {
            proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        }
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this
            .#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 ||
            !("stream" in proxy) &&
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) {
            proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        }
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this
            .#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) {
            proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
        }
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this
            .#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) {
            proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
        }
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this
            .#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) {
            proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
        }
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this
            .#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) {
            proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
        }
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this
            .#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) {
            proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
        }
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this
            .#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) {
            proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        }
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this
            .#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) {
            proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        }
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 ||
            !("alias" in proxy) &&
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) {
            proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        }
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this
            .#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) {
            proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        }
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 ||
            !("service" in proxy) &&
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) {
            proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        }
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this
            .#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) {
            proxy.followedMessage =
                _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
        }
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this
            .#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) {
            proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Organization " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Organization " + inspect(proxy, options);
    }
}
_f = Organization;
/** Represents a Web Page.
 */
export class Page extends Document {
    /**
     * The type URI of {@link Page}: `https://www.w3.org/ns/activitystreams#Page`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Page");
    }
    /**
     * Constructs a new instance of Page with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Page";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Page"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Page__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Page__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Page")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Page)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Page " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Page " + inspect(proxy, options);
    }
}
/** Represents an individual person.
 */
export class Person extends Object {
    /**
     * The type URI of {@link Person}: `https://www.w3.org/ns/activitystreams#Person`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Person");
    }
    #_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
    #_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
    #_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
    #_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
    #_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
    #_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
    #_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
    #_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
    #_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
    #_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
    #_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
    #_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
    #_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
    #_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
    #_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
    #_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
    #_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
    #_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
    #_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
    #_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
    #_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
    #_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
    /**
     * Constructs a new instance of Person with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot initialize both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot initialize both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot initialize both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof Group ||
                values.successor instanceof Organization ||
                values.successor instanceof _g ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof Group ||
                values.alias instanceof Organization ||
                values.alias instanceof _g || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot initialize both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof _g ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot initialize both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot update both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot update both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot update both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [
                    values.discoverable,
                ];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof Group ||
                values.successor instanceof Organization ||
                values.successor instanceof _g ||
                values.successor instanceof Service || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof Group ||
                values.alias instanceof Organization ||
                values.alias instanceof _g || values.alias instanceof Service ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot update both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof _g ||
                    v instanceof Service || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot update both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
        return clone;
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsername() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) {
            return null;
        }
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsernames() {
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
    }
    async #fetchPublicKey(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#publicKey_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #publicKey_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CryptographicKey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Key"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getPublicKey},
     * but returns its `@id` URL instead of the object itself.
     */
    get publicKeyId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** A public part of the key pair owned by this actor.
     */
    async getPublicKey(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPublicKey(v, options);
            if (fetched == null)
                return null;
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "publicKey" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["publicKey"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#publicKey_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Person.getPublicKeys},
     * but returns their `@id`s instead of the objects themselves.
     */
    get publicKeyIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A public part of the key pair owned by this actor.
     */
    async *getPublicKeys(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchPublicKey(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "publicKey" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["publicKey"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#publicKey_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchAssertionMethod(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#assertionMethod_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #assertionMethod_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Multikey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Multikey"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getAssertionMethod},
     * but returns its `@id` URL instead of the object itself.
     */
    get assertionMethodId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async getAssertionMethod(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAssertionMethod(v, options);
            if (fetched == null)
                return null;
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "assertionMethod" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["assertionMethod"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#assertionMethod_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Person.getAssertionMethods},
     * but returns their `@id`s instead of the objects themselves.
     */
    get assertionMethodIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async *getAssertionMethods(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAssertionMethod(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "assertionMethod" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["assertionMethod"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#assertionMethod_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** When `true`, conveys that for this actor, follow requests are not usually
     * automatically approved, but instead are examined by a person who may accept
     * or reject the request, at some time in the future.  Setting of `false`
     * conveys no information and may be ignored.  This information is typically
     * used to affect display of accounts, such as showing an account as private or
     * locked.
     */
    get manuallyApprovesFollowers() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1)
            return null;
        return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
    }
    async #fetchInbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#inbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #inbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getInbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get inboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The inbox stream contains all activities received by the actor.  The server
     * SHOULD filter content according to the requester's permission.  In general,
     * the owner of an inbox is likely to be able to access all of their inbox
     * contents.  Depending on access control, some other content may be public,
     * whereas other content may require authentication for non-owner users,
     * if they can access the inbox at all.
     *
     * The server MUST perform de-duplication of activities returned by the inbox.
     * Duplication can occur if an activity is addressed both to an actor's
     * followers, and a specific actor who also follows the recipient actor,
     * and the server has failed to de-duplicate the recipients list.
     * Such deduplication MUST be performed by comparing the `id` of the activities
     * and dropping any activities already seen.
     */
    async getInbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchInbox(v, options);
            if (fetched == null)
                return null;
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "inbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["inbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#inbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchOutbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#outbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #outbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getOutbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get outboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The outbox stream contains activities the user has published,
     * subject to the ability of the requestor to retrieve the activity
     * (that is, the contents of the outbox are filtered by the permissions of
     * the person reading it).  If a user submits a request without
     * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
     * the server should respond with all of the
     * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
     * This could potentially be all relevant objects published by the user,
     * though the number of available items is left to the discretion of those
     * implementing and deploying the server.
     */
    async getOutbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchOutbox(v, options);
            if (fetched == null)
                return null;
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "outbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["outbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#outbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowing(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#following_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #following_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getFollowing},
     * but returns its `@id` URL instead of the object itself.
     */
    get followingId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everybody that the actor has followed, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * The `following` collection MUST be either an {@link OrderedCollection}
     * or a {@link Collection} and MAY be filtered on privileges of
     * an authenticated user or as appropriate when no authentication is given.
     */
    async getFollowing(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowing(v, options);
            if (fetched == null)
                return null;
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "following" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["following"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#following_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowers(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#followers_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #followers_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getFollowers},
     * but returns its `@id` URL instead of the object itself.
     */
    get followersId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everyone who has sent a {@link Follow} activity
     * for the actor, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * This is where one would find a list of all the actors that are following
     * the actor.  The `followers` collection MUST be either
     * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
     * privileges of an authenticated user or as appropriate when no authentication
     * is given.
     */
    async getFollowers(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowers(v, options);
            if (fetched == null)
                return null;
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "followers" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["followers"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#followers_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchLiked(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#liked_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #liked_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getLiked},
     * but returns its `@id` URL instead of the object itself.
     */
    get likedId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of every object from all of the actor's {@link Like}
     * activities, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
     * The `liked` collection MUST be either an {@link OrderedCollection} or
     * a {@link Collection} and MAY be filtered on privileges of an authenticated
     * user or as appropriate when no authentication is given.
     */
    async getLiked(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLiked(v, options);
            if (fetched == null)
                return null;
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "liked" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["liked"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#liked_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeatured(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featured_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featured_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getFeatured},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "pinned statuses", or statuses that are always
     * featured at the top of people's profiles, is implemented using an extra
     * property `featured` on the actor object that points to a {@link Collection}
     * of objects.
     */
    async getFeatured(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeatured(v, options);
            if (fetched == null)
                return null;
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featured" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featured"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featured_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeaturedTags(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featuredTags_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featuredTags_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getFeaturedTags},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredTagsId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "featured hashtags", hashtags that are featured
     * at people's profiles, is implemented using an extra property `featuredTags`
     * on the actor object that points to a {@link Collection} of {@link Hashtag}
     * objects specifically.
     */
    async getFeaturedTags(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeaturedTags(v, options);
            if (fetched == null)
                return null;
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featuredTags" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featuredTags"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featuredTags_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchStream(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#stream_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #stream_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getStreams},
     * but returns their `@id`s instead of the objects themselves.
     */
    get streamIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A list of supplementary Collections which may be of interest.
     */
    async *getStreams(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchStream(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "streams" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["streams"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#stream_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** A JSON object which maps additional (typically server/domain-wide) endpoints
     * which may be useful either for this actor or someone referencing this actor.
     * This mapping may be nested inside the actor document as the value or may be
     * a link to a JSON-LD document with these properties.
     */
    get endpoints() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1)
            return null;
        return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
    }
    /** Allows users to opt-in or opt-out of discoverability features like
     * the profile directory.  This flag may also be used as an indicator of
     * the user's preferences toward being included in external discovery services,
     * such as search engines or other indexing tools.
     */
    get discoverable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1)
            return null;
        return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
    }
    /** Reports whether a user was locally suspended, for better handling of
     * these accounts.
     */
    get suspended() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1)
            return null;
        return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
    }
    /** Whether the actor is in-memorial state.
     */
    get memorial() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1)
            return null;
        return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
    }
    /** Whether the actor allows to be indexed.
     */
    get indexable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1)
            return null;
        return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
    }
    async #fetchSuccessor(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#successor_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #successor_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _g.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getSuccessor},
     * but returns its `@id` URL instead of the object itself.
     */
    get successorId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
     */
    async getSuccessor(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchSuccessor(v, options);
            if (fetched == null)
                return null;
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "movedTo" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["movedTo"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#successor_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchAlias(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#alias_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #alias_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _g.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Service.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getAlias},
     * but returns its `@id` URL instead of the object itself.
     */
    get aliasId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async getAlias(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAlias(v, options);
            if (fetched == null)
                return null;
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "alsoKnownAs" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["alsoKnownAs"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#alias_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Person.getAliases},
     * but returns their `@id`s instead of the objects themselves.
     */
    get aliasIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async *getAliases(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAlias(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "alsoKnownAs" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["alsoKnownAs"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#alias_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchService(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#service_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #service_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await DidService.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/did#Service"].join(", "));
    }
    /**
     * Similar to
     * {@link Person.getService},
     * but returns its `@id` URL instead of the object itself.
     */
    get serviceId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async getService(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchService(v, options);
            if (fetched == null)
                return null;
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "service" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["service"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#service_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Person.getServices},
     * but returns their `@id`s instead of the objects themselves.
     */
    get serviceIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async *getServices(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchService(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "service" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["service"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#service_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** This value is used for `Actor` type objects to show message on followed.
     */
    get followedMessage() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1)
            return null;
        return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
    }
    /** Used on actors to indicate that they in some way identify as a cat,
     * expressed as a boolean value. If this property is set to `true`,
     * displaying the actor or their notes will have some special effects
     * attached in some clients.
     */
    get cat() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1)
            return null;
        return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["preferredUsername"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["publicKey"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["assertionMethod"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["manuallyApprovesFollowers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["inbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["outbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["following"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["followers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["liked"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featured"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featuredTags"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["streams"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
                const item = await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["endpoints"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["discoverable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["suspended"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["memorial"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["indexable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof _g
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["movedTo"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof _g
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["alsoKnownAs"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["service"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["_misskey_followedMessage"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["isCat"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Person";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#preferredUsername"] =
                propValue;
        }
        array = [];
        for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#publicKey"] = propValue;
        }
        array = [];
        for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#assertionMethod"] = propValue;
        }
        array = [];
        for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
        }
        array = [];
        for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://www.w3.org/ns/ldp#inbox"] = propValue;
        }
        array = [];
        for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
        }
        array = [];
        for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#following"] = propValue;
        }
        array = [];
        for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
        }
        array = [];
        for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
        }
        array = [];
        for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featured"] = propValue;
        }
        array = [];
        for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featuredTags"] = propValue;
        }
        array = [];
        for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
        }
        array = [];
        for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
            const element = await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
        }
        array = [];
        for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#discoverable"] = propValue;
        }
        array = [];
        for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#suspended"] = propValue;
        }
        array = [];
        for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#memorial"] = propValue;
        }
        array = [];
        for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#indexable"] = propValue;
        }
        array = [];
        for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof _g
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
        }
        array = [];
        for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof _g
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
        }
        array = [];
        for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/did#service"] = propValue;
        }
        array = [];
        for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
        }
        array = [];
        for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#isCat"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Person"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null &&
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0)
            return false;
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null &&
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0)
            return false;
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Person__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Person__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Person")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof _g)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
        let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
        for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null
            ? []
            : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 &&
                "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]
                ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"]
                : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
        }
        instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
        let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
        for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null
            ? []
            : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 &&
                "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]
                ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"]
                : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, options));
        }
        instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
        let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
        for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null
            ? []
            : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 &&
                "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]
                ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"]
                : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, options));
        }
        instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
        let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
        for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null
            ? []
            : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array
                .length === 1 &&
                "@list" in
                    _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]
                ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"]
                : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
            if (v == null)
                continue;
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
        }
        instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
        let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
        for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null
            ? []
            : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 &&
                "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]
                ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"]
                : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
        }
        instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
        let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
        for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null
            ? []
            : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 &&
                "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]
                ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"]
                : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
        }
        instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            _41QwhqJouoLg3h8dRPKat21brynC_outbox;
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
        let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
        for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null
            ? []
            : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 &&
                "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]
                ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"]
                : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
        let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
        for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null
            ? []
            : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 &&
                "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]
                ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"]
                : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
        let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
        for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null
            ? []
            : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 &&
                "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]
                ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"]
                : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
        let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
        for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null
            ? []
            : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 &&
                "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]
                ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"]
                : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
        let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
        for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null
            ? []
            : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 &&
                "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]
                ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"]
                : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
        let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
        for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null
            ? []
            : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 &&
                "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]
                ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"]
                : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
        let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
        for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null
            ? []
            : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 &&
                "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]
                ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"]
                : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
            if (v == null)
                continue;
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, options));
        }
        instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
        let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
        for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null
            ? []
            : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 &&
                "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]
                ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"]
                : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
            if (v == null)
                continue;
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
        }
        instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
        let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
        for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null
            ? []
            : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 &&
                "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]
                ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"]
                : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
            if (v == null)
                continue;
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
        }
        instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
        let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
        for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null
            ? []
            : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 &&
                "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]
                ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"]
                : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
            if (v == null)
                continue;
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
        }
        instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
        let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
        for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null
            ? []
            : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 &&
                "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]
                ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"]
                : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
            if (v == null)
                continue;
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
        }
        instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
        let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
        for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null
            ? []
            : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 &&
                "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]
                ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"]
                : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await _g.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
        }
        instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
        let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
        for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null
            ? []
            : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 &&
                "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]
                ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"]
                : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await _g.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await Service.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
        }
        instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
        let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
        for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null
            ? []
            : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 &&
                "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]
                ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"]
                : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, options));
        }
        instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
        let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
        for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null
            ? []
            : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array
                .length === 1 &&
                "@list" in
                    _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]
                ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"]
                : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
            if (v == null)
                continue;
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
        }
        instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
        let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
        for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null
            ? []
            : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 &&
                "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]
                ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"]
                : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
            if (v == null)
                continue;
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
        }
        instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this
            .#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) {
            proxy.preferredUsername =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
        }
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 ||
            !("preferredUsername" in proxy) &&
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) {
            proxy.preferredUsernames =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        }
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this
            .#_axq166E2eZADq34V4MYUc8KMZdC_publicKey
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) {
            proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        }
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 ||
            !("publicKey" in proxy) &&
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) {
            proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        }
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this
            .#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) {
            proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        }
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 ||
            !("assertionMethod" in proxy) &&
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) {
            proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        }
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this
            .#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) {
            proxy.manuallyApprovesFollowers =
                _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
        }
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this
            .#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) {
            proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        }
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this
            .#_41QwhqJouoLg3h8dRPKat21brynC_outbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) {
            proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        }
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this
            .#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) {
            proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        }
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this
            .#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) {
            proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        }
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this
            .#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) {
            proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        }
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this
            .#_4N1vBJzXDf8NbBumeECQMFvKetja_featured
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) {
            proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        }
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this
            .#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) {
            proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        }
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this
            .#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 ||
            !("stream" in proxy) &&
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) {
            proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        }
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this
            .#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) {
            proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
        }
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this
            .#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) {
            proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
        }
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this
            .#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) {
            proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
        }
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this
            .#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) {
            proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
        }
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this
            .#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) {
            proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
        }
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this
            .#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) {
            proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        }
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this
            .#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) {
            proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        }
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 ||
            !("alias" in proxy) &&
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) {
            proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        }
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this
            .#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) {
            proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        }
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 ||
            !("service" in proxy) &&
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) {
            proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        }
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this
            .#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) {
            proxy.followedMessage =
                _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
        }
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this
            .#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) {
            proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Person " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Person " + inspect(proxy, options);
    }
}
_g = Person;
/** Represents a logical or physical location.  See [5.3 Representing
 * Places](https://www.w3.org/TR/activitystreams-vocabulary/#places)
 * for additional information.
 */
export class Place extends Object {
    /**
     * The type URI of {@link Place}: `https://www.w3.org/ns/activitystreams#Place`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Place");
    }
    #_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [];
    #_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [];
    #_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [];
    #_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [];
    #_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [];
    #_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [];
    /**
     * Constructs a new instance of Place with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("accuracy" in values && values.accuracy != null) {
            if (typeof values.accuracy === "number" && !Number.isNaN(values.accuracy)) {
                // @ts-ignore: type is checked above.
                this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [values.accuracy];
            }
            else {
                throw new TypeError("The accuracy must be of type " +
                    "number" + ".");
            }
        }
        if ("altitude" in values && values.altitude != null) {
            if (typeof values.altitude === "number" && !Number.isNaN(values.altitude)) {
                // @ts-ignore: type is checked above.
                this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [values.altitude];
            }
            else {
                throw new TypeError("The altitude must be of type " +
                    "number" + ".");
            }
        }
        if ("latitude" in values && values.latitude != null) {
            if (typeof values.latitude === "number" && !Number.isNaN(values.latitude)) {
                // @ts-ignore: type is checked above.
                this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [values.latitude];
            }
            else {
                throw new TypeError("The latitude must be of type " +
                    "number" + ".");
            }
        }
        if ("longitude" in values && values.longitude != null) {
            if (typeof values.longitude === "number" && !Number.isNaN(values.longitude)) {
                // @ts-ignore: type is checked above.
                this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [values.longitude];
            }
            else {
                throw new TypeError("The longitude must be of type " +
                    "number" + ".");
            }
        }
        if ("radius" in values && values.radius != null) {
            if (typeof values.radius === "number" && !Number.isNaN(values.radius)) {
                // @ts-ignore: type is checked above.
                this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [values.radius];
            }
            else {
                throw new TypeError("The radius must be of type " +
                    "number" + ".");
            }
        }
        if ("units" in values && values.units != null) {
            if (values.units == "cm" || values.units == "feet" ||
                values.units == "inches" || values.units == "km" ||
                values.units == "m" || values.units == "miles" ||
                values.units instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [values.units];
            }
            else {
                throw new TypeError("The units must be of type " +
                    '"cm" | "feet" | "inches" | "km" | "m" | "miles" | URL' + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy =
            this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy;
        if ("accuracy" in values && values.accuracy != null) {
            if (typeof values.accuracy === "number" && !Number.isNaN(values.accuracy)) {
                // @ts-ignore: type is checked above.
                clone.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [values.accuracy];
            }
            else {
                throw new TypeError("The accuracy must be of type " +
                    "number" + ".");
            }
        }
        clone.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude =
            this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude;
        if ("altitude" in values && values.altitude != null) {
            if (typeof values.altitude === "number" && !Number.isNaN(values.altitude)) {
                // @ts-ignore: type is checked above.
                clone.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [values.altitude];
            }
            else {
                throw new TypeError("The altitude must be of type " +
                    "number" + ".");
            }
        }
        clone.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude =
            this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude;
        if ("latitude" in values && values.latitude != null) {
            if (typeof values.latitude === "number" && !Number.isNaN(values.latitude)) {
                // @ts-ignore: type is checked above.
                clone.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [values.latitude];
            }
            else {
                throw new TypeError("The latitude must be of type " +
                    "number" + ".");
            }
        }
        clone.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude =
            this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude;
        if ("longitude" in values && values.longitude != null) {
            if (typeof values.longitude === "number" && !Number.isNaN(values.longitude)) {
                // @ts-ignore: type is checked above.
                clone.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [values.longitude];
            }
            else {
                throw new TypeError("The longitude must be of type " +
                    "number" + ".");
            }
        }
        clone.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius =
            this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius;
        if ("radius" in values && values.radius != null) {
            if (typeof values.radius === "number" && !Number.isNaN(values.radius)) {
                // @ts-ignore: type is checked above.
                clone.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [values.radius];
            }
            else {
                throw new TypeError("The radius must be of type " +
                    "number" + ".");
            }
        }
        clone.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units =
            this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units;
        if ("units" in values && values.units != null) {
            if (values.units == "cm" || values.units == "feet" ||
                values.units == "inches" || values.units == "km" ||
                values.units == "m" || values.units == "miles" ||
                values.units instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [values.units];
            }
            else {
                throw new TypeError("The units must be of type " +
                    '"cm" | "feet" | "inches" | "km" | "m" | "miles" | URL' + ".");
            }
        }
        return clone;
    }
    /** Indicates the accuracy of position coordinates on a {@link Place} objects.
     * Expressed in properties of percentage. e.g. "94.0" means "94.0% accurate".
     */
    get accuracy() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy.length < 1)
            return null;
        return this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy[0];
    }
    /** Indicates the altitude of a place.  The measurement units is indicated
     * using the {@link Place.units} property.  If {@link Place.units} is not
     * specified, the default is assumed to be "`m`" indicating meters.
     */
    get altitude() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude.length < 1)
            return null;
        return this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude[0];
    }
    /** The latitude of a place.
     */
    get latitude() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude.length < 1)
            return null;
        return this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude[0];
    }
    /** The longitude of a place.
     */
    get longitude() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude.length < 1)
            return null;
        return this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude[0];
    }
    /** The radius from the given latitude and longitude for a {@link Place}.
     * The units is expressed by the {@link Place.units} property.
     * If {@link Place.units} is not specified, the default is assumed to be
     * "`m`" indicating "meters".
     */
    get radius() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius.length < 1)
            return null;
        return this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius[0];
    }
    /** Specifies the measurement units for the {@link Place.radius} and
     * {@link Place.altitude} properties on a {@link Place} object.
     * If not specified, the default is assumed to be "`m`" for "meters".
     */
    get units() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units.length < 1)
            return null;
        return this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["accuracy"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["altitude"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["latitude"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["longitude"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["radius"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units) {
                const item = v == "cm" || v == "feet" || v == "inches" || v == "km" || v == "m" ||
                    v == "miles"
                    ? v
                    : v.href;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["units"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Place";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#float",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#accuracy"] = propValue;
        }
        array = [];
        for (const v of this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#float",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#altitude"] = propValue;
        }
        array = [];
        for (const v of this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#float",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#latitude"] = propValue;
        }
        array = [];
        for (const v of this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#float",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#longitude"] = propValue;
        }
        array = [];
        for (const v of this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#float",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#radius"] = propValue;
        }
        array = [];
        for (const v of this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units) {
            const element = v == "cm" || v == "feet" || v == "inches" || v == "km" || v == "m" ||
                v == "miles"
                ? { "@value": v }
                : { "@id": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#units"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Place"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Place__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Place__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Place")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Place)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [];
        let _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array = values["https://www.w3.org/ns/activitystreams#accuracy"];
        for (const v of _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array == null
            ? []
            : _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array.length === 1 &&
                "@list" in _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array[0]
                ? _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array[0]["@list"]
                : _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array) {
            if (v == null)
                continue;
            _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy.push(v["@value"]);
        }
        instance.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy =
            _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy;
        const _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [];
        let _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array = values["https://www.w3.org/ns/activitystreams#altitude"];
        for (const v of _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array == null
            ? []
            : _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array.length === 1 &&
                "@list" in _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array[0]
                ? _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array[0]["@list"]
                : _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array) {
            if (v == null)
                continue;
            _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude.push(v["@value"]);
        }
        instance.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude =
            _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude;
        const _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [];
        let _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array = values["https://www.w3.org/ns/activitystreams#latitude"];
        for (const v of _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array == null
            ? []
            : _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array.length === 1 &&
                "@list" in _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array[0]
                ? _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array[0]["@list"]
                : _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array) {
            if (v == null)
                continue;
            _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude.push(v["@value"]);
        }
        instance.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude =
            _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude;
        const _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [];
        let _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array = values["https://www.w3.org/ns/activitystreams#longitude"];
        for (const v of _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array == null
            ? []
            : _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array.length === 1 &&
                "@list" in _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array[0]
                ? _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array[0]["@list"]
                : _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array) {
            if (v == null)
                continue;
            _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude.push(v["@value"]);
        }
        instance.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude =
            _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude;
        const _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [];
        let _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array = values["https://www.w3.org/ns/activitystreams#radius"];
        for (const v of _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array == null
            ? []
            : _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array.length === 1 &&
                "@list" in _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array[0]
                ? _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array[0]["@list"]
                : _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array) {
            if (v == null)
                continue;
            _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius.push(v["@value"]);
        }
        instance.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius =
            _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius;
        const _oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [];
        let _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array = values["https://www.w3.org/ns/activitystreams#units"];
        for (const v of _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array == null
            ? []
            : _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array.length === 1 &&
                "@list" in _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array[0]
                ? _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array[0]["@list"]
                : _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                (v["@value"] == "cm" || v["@value"] == "feet" ||
                    v["@value"] == "inches" || v["@value"] == "km" ||
                    v["@value"] == "m" || v["@value"] == "miles")
                ? v["@value"]
                : typeof v === "object" && "@id" in v &&
                    typeof v["@id"] === "string" &&
                    v["@id"] !== "" && v["@id"] !== "/"
                    ? new URL(v["@id"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _oKrwxU4V8wiKhMW1QEYQibcJh8c_units.push(decoded);
        }
        instance.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units =
            _oKrwxU4V8wiKhMW1QEYQibcJh8c_units;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = this
            .#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy.length == 1) {
            proxy.accuracy = _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy[0];
        }
        const _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = this
            .#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude.length == 1) {
            proxy.altitude = _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude[0];
        }
        const _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = this
            .#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude.length == 1) {
            proxy.latitude = _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude[0];
        }
        const _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = this
            .#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude.length == 1) {
            proxy.longitude = _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude[0];
        }
        const _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = this
            .#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius.length == 1) {
            proxy.radius = _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius[0];
        }
        const _oKrwxU4V8wiKhMW1QEYQibcJh8c_units = this
            .#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_oKrwxU4V8wiKhMW1QEYQibcJh8c_units.length == 1) {
            proxy.units = _oKrwxU4V8wiKhMW1QEYQibcJh8c_units[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Place " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Place " + inspect(proxy, options);
    }
}
/** A {@link Profile} is a content object that describes another {@link Object},
 * typically used to describe [Actor
 * Type](https://www.w3.org/TR/activitystreams-vocabulary/#actor-types) objects.
 * The {@link Profile.describes} property is used to reference the object being
 * described by the profile.
 */
export class Profile extends Object {
    /**
     * The type URI of {@link Profile}: `https://www.w3.org/ns/activitystreams#Profile`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Profile");
    }
    #_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [];
    /**
     * Constructs a new instance of Profile with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("describes" in values && values.describes != null) {
            if (values.describes instanceof Object || values.describes instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [values.describes];
            }
            else {
                throw new TypeError("The describes must be of type " +
                    "Object | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes =
            this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes;
        if ("describes" in values && values.describes != null) {
            if (values.describes instanceof Object || values.describes instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [values.describes];
            }
            else {
                throw new TypeError("The describes must be of type " +
                    "Object | URL" + ".");
            }
        }
        return clone;
    }
    async #fetchDescribes(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#describes_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #describes_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Profile.getDescribes},
     * but returns its `@id` URL instead of the object itself.
     */
    get describesId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.length < 1)
            return null;
        const v = this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** On a {@link Profile} object, the {@link Profile.describes} property
     * identifies the object described by the {@link Profile}.
     */
    async getDescribes(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.length < 1)
            return null;
        const v = this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchDescribes(v, options);
            if (fetched == null)
                return null;
            this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "describes" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["describes"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#describes_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["describes"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Profile";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#describes"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Profile"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Profile__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Profile__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Profile")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Profile)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [];
        let _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array = values["https://www.w3.org/ns/activitystreams#describes"];
        for (const v of _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array == null
            ? []
            : _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array.length === 1 &&
                "@list" in _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array[0]
                ? _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array[0]["@list"]
                : _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.push(await Object.fromJsonLd(v, options));
        }
        instance.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes =
            _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = this
            .#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.length == 1) {
            proxy.describes = _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Profile " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Profile " + inspect(proxy, options);
    }
}
/** Represents a question being asked.  Question objects are an extension of
 * {@link IntransitiveActivity}.  That is, the Question object is an Activity,
 * but the direct object is the question itself and therefore it would not
 * contain an `object` property.
 *
 * Either of the `inclusiveOptions` and `exclusiveOptions` properties *may* be
 * used to express possible answers, but a Question object *must not* have both
 * properties.
 */
export class Question extends IntransitiveActivity {
    /**
     * The type URI of {@link Question}: `https://www.w3.org/ns/activitystreams#Question`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Question");
    }
    #_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = [];
    #_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = [];
    #_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [];
    #_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [];
    #_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
    /**
     * Constructs a new instance of Question with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("exclusiveOptions" in values && values.exclusiveOptions != null) {
            if (Array.isArray(values.exclusiveOptions) &&
                values.exclusiveOptions.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = values.exclusiveOptions;
            }
            else {
                throw new TypeError("The exclusiveOptions must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("inclusiveOptions" in values && values.inclusiveOptions != null) {
            if (Array.isArray(values.inclusiveOptions) &&
                values.inclusiveOptions.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = values.inclusiveOptions;
            }
            else {
                throw new TypeError("The inclusiveOptions must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("closed" in values && values.closed != null) {
            if (values.closed instanceof dntShim.Temporal.Instant ||
                typeof values.closed === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [values.closed];
            }
            else {
                throw new TypeError("The closed must be of type " +
                    "Temporal.Instant | boolean" + ".");
            }
        }
        if ("voters" in values && values.voters != null) {
            if (typeof values.voters === "number" && Number.isInteger(values.voters) &&
                values.voters >= 0) {
                // @ts-ignore: type is checked above.
                this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [values.voters];
            }
            else {
                throw new TypeError("The voters must be of type " +
                    "number" + ".");
            }
        }
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf =
            this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
        if ("exclusiveOptions" in values && values.exclusiveOptions != null) {
            if (Array.isArray(values.exclusiveOptions) &&
                values.exclusiveOptions.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = values.exclusiveOptions;
            }
            else {
                throw new TypeError("The exclusiveOptions must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf =
            this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
        if ("inclusiveOptions" in values && values.inclusiveOptions != null) {
            if (Array.isArray(values.inclusiveOptions) &&
                values.inclusiveOptions.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = values.inclusiveOptions;
            }
            else {
                throw new TypeError("The inclusiveOptions must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed =
            this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed;
        if ("closed" in values && values.closed != null) {
            if (values.closed instanceof dntShim.Temporal.Instant ||
                typeof values.closed === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [values.closed];
            }
            else {
                throw new TypeError("The closed must be of type " +
                    "Temporal.Instant | boolean" + ".");
            }
        }
        clone.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount =
            this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount;
        if ("voters" in values && values.voters != null) {
            if (typeof values.voters === "number" && Number.isInteger(values.voters) &&
                values.voters >= 0) {
                // @ts-ignore: type is checked above.
                clone.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [values.voters];
            }
            else {
                throw new TypeError("The voters must be of type " +
                    "number" + ".");
            }
        }
        clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if ("quoteUrl" in values && values.quoteUrl != null) {
            if (values.quoteUrl instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
            }
            else {
                throw new TypeError("The quoteUrl must be of type " +
                    "URL" + ".");
            }
        }
        return clone;
    }
    async #fetchExclusiveOption(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#exclusiveOption_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #exclusiveOption_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Question.getExclusiveOptions},
     * but returns their `@id`s instead of the objects themselves.
     */
    get exclusiveOptionIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies an exclusive option for a Question.  Use of `exclusiveOptions`
     * implies that the Question can have only a single answer.  To indicate that
     * a Question can have multiple answers, use `inclusiveOptions`.
     */
    async *getExclusiveOptions(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchExclusiveOption(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "oneOf" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["oneOf"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#exclusiveOption_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchInclusiveOption(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#inclusiveOption_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #inclusiveOption_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Question.getInclusiveOptions},
     * but returns their `@id`s instead of the objects themselves.
     */
    get inclusiveOptionIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Identifies an inclusive option for a Question.  Use of `inclusiveOptions`
     * implies that the Question can have multiple answers.  To indicate that
     * a Question can have only one answer, use `exclusiveOptions`.
     */
    async *getInclusiveOptions(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchInclusiveOption(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "anyOf" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["anyOf"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#inclusiveOption_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** Indicates that a question has been closed, and answers are no longer
     * accepted.
     */
    get closed() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed.length < 1)
            return null;
        return this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed[0];
    }
    /** How many people have voted in the poll.  Distinct from how many votes have
     * been cast (in the case of multiple-choice polls).
     */
    get voters() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount.length < 1)
            return null;
        return this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount[0];
    }
    /** The URI of the ActivityStreams object that this object quotes.
     *
     * This property sets three JSON-LD properties at once under the hood:
     *
     * 1. https://www.w3.org/ns/activitystreams#quoteUrl
     * 2. https://misskey-hub.net/ns#_misskey_quote
     * 3. http://fedibird.com/ns#quoteUri
     *
     * When a JSON-LD object is parsed, this property is filled with one of
     * the values of those three properties in order.
     */
    get quoteUrl() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1)
            return null;
        return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#oneOf"] = propValue;
        }
        array = [];
        for (const v of this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#anyOf"] = propValue;
        }
        array = [];
        for (const v of this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed) {
            const element = v instanceof dntShim.Temporal.Instant
                ? {
                    "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                    "@value": v.toString(),
                }
                : { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#closed"] = propValue;
        }
        array = [];
        for (const v of this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
                "@value": v,
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#votersCount"] = propValue;
        }
        array = [];
        for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
            const element = { "@value": v.href };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
            values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
            values["http://fedibird.com/ns#quoteUri"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Question"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
                {
                    "toot": "http://joinmastodon.org/ns#",
                    "misskey": "https://misskey-hub.net/ns#",
                    "fedibird": "http://fedibird.com/ns#",
                    "sensitive": "as:sensitive",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "quoteUrl": "as:quoteUrl",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "quoteUri": "fedibird:quoteUri",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Question__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Question__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Question)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = [];
        let _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array = values["https://www.w3.org/ns/activitystreams#oneOf"];
        for (const v of _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array == null
            ? []
            : _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array.length === 1 &&
                "@list" in _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array[0]
                ? _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array[0]["@list"]
                : _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.push(await Object.fromJsonLd(v, options));
        }
        instance.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf =
            _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
        const _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = [];
        let _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array = values["https://www.w3.org/ns/activitystreams#anyOf"];
        for (const v of _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array == null
            ? []
            : _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array.length === 1 &&
                "@list" in _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array[0]
                ? _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array[0]["@list"]
                : _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.push(await Object.fromJsonLd(v, options));
        }
        instance.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf =
            _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
        const _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [];
        let _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array = values["https://www.w3.org/ns/activitystreams#closed"];
        for (const v of _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array == null
            ? []
            : _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array.length === 1 &&
                "@list" in _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array[0]
                ? _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array[0]["@list"]
                : _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@type" in v &&
                "@value" in v && typeof v["@value"] === "string" &&
                v["@type"] === "http://www.w3.org/2001/XMLSchema#dateTime" &&
                // Check if the value is a valid RFC 3339 date-time string
                new Date(v["@value"]).toString() !== "Invalid Date"
                ? dntShim.Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/)
                    ? v["@value"]
                    : v["@value"] + "Z")
                : typeof v === "object" && "@value" in v &&
                    typeof v["@value"] === "boolean"
                    ? v["@value"]
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed.push(decoded);
        }
        instance.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed =
            _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed;
        const _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [];
        let _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array = values["http://joinmastodon.org/ns#votersCount"];
        for (const v of _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array == null
            ? []
            : _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array.length === 1 &&
                "@list" in _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array[0]
                ? _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array[0]["@list"]
                : _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array) {
            if (v == null)
                continue;
            _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount.push(v["@value"]);
        }
        instance.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount =
            _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount;
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
        let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["https://misskey-hub.net/ns#_misskey_quote"];
        }
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ||
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) {
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array =
                values["http://fedibird.com/ns#quoteUri"];
        }
        for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null
            ? []
            : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 &&
                "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]
                ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"]
                : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
            if (v == null)
                continue;
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
        }
        instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl =
            _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = this
            .#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.length > 1 ||
            !("exclusiveOption" in proxy) &&
                _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.length > 0) {
            proxy.exclusiveOptions = _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
        }
        const _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = this
            .#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.length > 1 ||
            !("inclusiveOption" in proxy) &&
                _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.length > 0) {
            proxy.inclusiveOptions = _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
        }
        const _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = this
            .#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed.length == 1) {
            proxy.closed = _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed[0];
        }
        const _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = this
            .#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount.length == 1) {
            proxy.voters = _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount[0];
        }
        const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this
            .#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) {
            proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Question " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Question " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has read the `object`.
 */
export class Read extends Activity {
    /**
     * The type URI of {@link Read}: `https://www.w3.org/ns/activitystreams#Read`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Read");
    }
    /**
     * Constructs a new instance of Read with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Read"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Read__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Read__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Read")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Read)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Read " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Read " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is rejecting the `object`.  The `target` and
 * `origin` typically have no defined meaning.
 */
export class Reject extends Activity {
    /**
     * The type URI of {@link Reject}: `https://www.w3.org/ns/activitystreams#Reject`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Reject");
    }
    /**
     * Constructs a new instance of Reject with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Reject"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Reject__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Reject__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) {
                return await TentativeReject.fromJsonLd(json, options);
            }
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Reject")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Reject)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Reject " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Reject " + inspect(proxy, options);
    }
}
/** Describes a relationship between two individuals.
 * The {@link Relationship.subject} and {@link Relationship.object} properties
 * are used to identify the connected individuals.
 *
 * See [5.2 Representing Relationships Between
 * Entities](https://www.w3.org/TR/activitystreams-vocabulary/#connections)
 * for additional information.
 */
export class Relationship extends Object {
    /**
     * The type URI of {@link Relationship}: `https://www.w3.org/ns/activitystreams#Relationship`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Relationship");
    }
    #_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [];
    #_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
    #_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [];
    /**
     * Constructs a new instance of Relationship with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("subject" in values && values.subject != null) {
            if (values.subject instanceof Object || values.subject instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [values.subject];
            }
            else {
                throw new TypeError("The subject must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("object" in values && values.object != null) {
            if (values.object instanceof Object || values.object instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
            }
            else {
                throw new TypeError("The object must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("objects" in values && values.objects != null) {
            if ("object" in values &&
                values.object != null) {
                throw new TypeError("Cannot initialize both object and " +
                    "objects at the same time.");
            }
            if (Array.isArray(values.objects) &&
                values.objects.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
            }
            else {
                throw new TypeError("The objects must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        if ("relationship" in values && values.relationship != null) {
            if (values.relationship instanceof Object ||
                values.relationship instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [
                    values.relationship,
                ];
            }
            else {
                throw new TypeError("The relationship must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("relationships" in values && values.relationships != null) {
            if ("relationship" in values &&
                values.relationship != null) {
                throw new TypeError("Cannot initialize both relationship and " +
                    "relationships at the same time.");
            }
            if (Array.isArray(values.relationships) &&
                values.relationships.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = values.relationships;
            }
            else {
                throw new TypeError("The relationships must be an array of type " +
                    "Object | URL" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject =
            this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject;
        if ("subject" in values && values.subject != null) {
            if (values.subject instanceof Object || values.subject instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [values.subject];
            }
            else {
                throw new TypeError("The subject must be of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object =
            this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        if ("object" in values && values.object != null) {
            if (values.object instanceof Object || values.object instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
            }
            else {
                throw new TypeError("The object must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("objects" in values && values.objects != null) {
            if ("object" in values &&
                values.object != null) {
                throw new TypeError("Cannot update both object and " +
                    "objects at the same time.");
            }
            if (Array.isArray(values.objects) &&
                values.objects.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
            }
            else {
                throw new TypeError("The objects must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        clone.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship =
            this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
        if ("relationship" in values && values.relationship != null) {
            if (values.relationship instanceof Object ||
                values.relationship instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [
                    values.relationship,
                ];
            }
            else {
                throw new TypeError("The relationship must be of type " +
                    "Object | URL" + ".");
            }
        }
        if ("relationships" in values && values.relationships != null) {
            if ("relationship" in values &&
                values.relationship != null) {
                throw new TypeError("Cannot update both relationship and " +
                    "relationships at the same time.");
            }
            if (Array.isArray(values.relationships) &&
                values.relationships.every((v) => v instanceof Object || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship =
                    values.relationships;
            }
            else {
                throw new TypeError("The relationships must be an array of type " +
                    "Object | URL" + ".");
            }
        }
        return clone;
    }
    async #fetchSubject(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#subject_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #subject_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Relationship.getSubject},
     * but returns its `@id` URL instead of the object itself.
     */
    get subjectId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.length < 1)
            return null;
        const v = this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** On a {@link Relationship} object, the {@link Relationship.subject} property
     * identifies one of the connected individuals.  For instance,
     * for a {@link Relationship} object describing "John is related to Sally",
     * the {@link Relationship.subject} property would refer to John.
     */
    async getSubject(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.length < 1)
            return null;
        const v = this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchSubject(v, options);
            if (fetched == null)
                return null;
            this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "subject" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["subject"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#subject_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchObject(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#object_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #object_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Relationship.getObject},
     * but returns its `@id` URL instead of the object itself.
     */
    get objectId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1)
            return null;
        const v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Describes the entity to which the {@link Relationship.subject} is related.
     */
    async getObject(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1)
            return null;
        const v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchObject(v, options);
            if (fetched == null)
                return null;
            this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "object" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["object"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#object_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Relationship.getObjects},
     * but returns their `@id`s instead of the objects themselves.
     */
    get objectIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Describes the entity to which the {@link Relationship.subject} is related.
     */
    async *getObjects(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchObject(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "object" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["object"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#object_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchRelationship(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#relationship_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #relationship_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Object.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
    }
    /**
     * Similar to
     * {@link Relationship.getRelationship},
     * but returns its `@id` URL instead of the object itself.
     */
    get relationshipId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length < 1) {
            return null;
        }
        const v = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** On a {@link Relationship} object, the {@link Relationship.relationship}
     * property identifies the kind of relationship that exists between
     * {@link Relationship.subject} and {@link Relationship.object}.
     */
    async getRelationship(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length < 1) {
            return null;
        }
        const v = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchRelationship(v, options);
            if (fetched == null)
                return null;
            this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "relationship" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["relationship"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#relationship_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Relationship.getRelationships},
     * but returns their `@id`s instead of the objects themselves.
     */
    get relationshipIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** On a {@link Relationship} object, the {@link Relationship.relationship}
     * property identifies the kind of relationship that exists between
     * {@link Relationship.subject} and {@link Relationship.object}.
     */
    async *getRelationships(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchRelationship(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "relationship" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["relationship"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#relationship_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["subject"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["object"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["relationship"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Relationship";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#subject"] = propValue;
        }
        array = [];
        for (const v of this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#object"] = propValue;
        }
        array = [];
        for (const v of this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#relationship"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Relationship"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Relationship__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Relationship__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Relationship")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Relationship)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [];
        let _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array = values["https://www.w3.org/ns/activitystreams#subject"];
        for (const v of _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array == null
            ? []
            : _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array.length === 1 &&
                "@list" in _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array[0]
                ? _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array[0]["@list"]
                : _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.push(await Object.fromJsonLd(v, options));
        }
        instance.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject =
            _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject;
        const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
        let _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array = values["https://www.w3.org/ns/activitystreams#object"];
        for (const v of _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array == null
            ? []
            : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array.length === 1 &&
                "@list" in _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0]
                ? _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0]["@list"]
                : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(await Object.fromJsonLd(v, options));
        }
        instance.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object =
            _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        const _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [];
        let _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array = values["https://www.w3.org/ns/activitystreams#relationship"];
        for (const v of _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array == null
            ? []
            : _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array.length === 1 &&
                "@list" in _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array[0]
                ? _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array[0]["@list"]
                : _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.push(await Object.fromJsonLd(v, options));
        }
        instance.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship =
            _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = this
            .#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.length == 1) {
            proxy.subject = _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0];
        }
        const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = this
            .#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length == 1) {
            proxy.object = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
        }
        if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 1 ||
            !("object" in proxy) &&
                _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 0) {
            proxy.objects = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
        }
        const _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = this
            .#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length == 1) {
            proxy.relationship = _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0];
        }
        if (_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length > 1 ||
            !("relationship" in proxy) &&
                _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length > 0) {
            proxy.relationships = _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Relationship " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Relationship " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is removing the `object`.  If specified,
 * the `origin` indicates the context from which the `object` is being removed.
 */
export class Remove extends Activity {
    /**
     * The type URI of {@link Remove}: `https://www.w3.org/ns/activitystreams#Remove`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Remove");
    }
    /**
     * Constructs a new instance of Remove with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Remove"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Remove__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Remove__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Remove")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Remove)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Remove " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Remove " + inspect(proxy, options);
    }
}
/** Represents a service of any kind.
 */
export class Service extends Object {
    /**
     * The type URI of {@link Service}: `https://www.w3.org/ns/activitystreams#Service`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Service");
    }
    #_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
    #_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
    #_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
    #_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
    #_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
    #_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
    #_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
    #_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
    #_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
    #_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
    #_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
    #_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
    #_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
    #_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
    #_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
    #_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
    #_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
    #_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
    #_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
    #_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
    #_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
    #_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
    /**
     * Constructs a new instance of Service with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot initialize both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot initialize both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot initialize both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof Group ||
                values.successor instanceof Organization ||
                values.successor instanceof Person ||
                values.successor instanceof _h || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof Group ||
                values.alias instanceof Organization ||
                values.alias instanceof Person || values.alias instanceof _h ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot initialize both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof _h || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot initialize both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        if ("preferredUsername" in values && values.preferredUsername != null) {
            if (typeof values.preferredUsername === "string" ||
                values.preferredUsername instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [
                    values.preferredUsername,
                ];
            }
            else {
                throw new TypeError("The preferredUsername must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("preferredUsernames" in values && values.preferredUsernames != null) {
            if ("preferredUsername" in values &&
                values.preferredUsername != null) {
                throw new TypeError("Cannot update both preferredUsername and " +
                    "preferredUsernames at the same time.");
            }
            if (Array.isArray(values.preferredUsernames) &&
                values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
                    values.preferredUsernames;
            }
            else {
                throw new TypeError("The preferredUsernames must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        if ("publicKey" in values && values.publicKey != null) {
            if (values.publicKey instanceof CryptographicKey ||
                values.publicKey instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
            }
            else {
                throw new TypeError("The publicKey must be of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        if ("publicKeys" in values && values.publicKeys != null) {
            if ("publicKey" in values &&
                values.publicKey != null) {
                throw new TypeError("Cannot update both publicKey and " +
                    "publicKeys at the same time.");
            }
            if (Array.isArray(values.publicKeys) &&
                values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
            }
            else {
                throw new TypeError("The publicKeys must be an array of type " +
                    "CryptographicKey | URL" + ".");
            }
        }
        clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        if ("assertionMethod" in values && values.assertionMethod != null) {
            if (values.assertionMethod instanceof Multikey ||
                values.assertionMethod instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [
                    values.assertionMethod,
                ];
            }
            else {
                throw new TypeError("The assertionMethod must be of type " +
                    "Multikey | URL" + ".");
            }
        }
        if ("assertionMethods" in values && values.assertionMethods != null) {
            if ("assertionMethod" in values &&
                values.assertionMethod != null) {
                throw new TypeError("Cannot update both assertionMethod and " +
                    "assertionMethods at the same time.");
            }
            if (Array.isArray(values.assertionMethods) &&
                values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
                    values.assertionMethods;
            }
            else {
                throw new TypeError("The assertionMethods must be an array of type " +
                    "Multikey | URL" + ".");
            }
        }
        clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        if ("manuallyApprovesFollowers" in values &&
            values.manuallyApprovesFollowers != null) {
            if (typeof values.manuallyApprovesFollowers === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [
                    values.manuallyApprovesFollowers,
                ];
            }
            else {
                throw new TypeError("The manuallyApprovesFollowers must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        if ("inbox" in values && values.inbox != null) {
            if (values.inbox instanceof OrderedCollection ||
                values.inbox instanceof OrderedCollectionPage ||
                values.inbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
            }
            else {
                throw new TypeError("The inbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
        if ("outbox" in values && values.outbox != null) {
            if (values.outbox instanceof OrderedCollection ||
                values.outbox instanceof OrderedCollectionPage ||
                values.outbox instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
            }
            else {
                throw new TypeError("The outbox must be of type " +
                    "OrderedCollection | OrderedCollectionPage | URL" + ".");
            }
        }
        clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        if ("following" in values && values.following != null) {
            if (values.following instanceof Collection ||
                values.following instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
            }
            else {
                throw new TypeError("The following must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        if ("followers" in values && values.followers != null) {
            if (values.followers instanceof Collection ||
                values.followers instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
            }
            else {
                throw new TypeError("The followers must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        if ("liked" in values && values.liked != null) {
            if (values.liked instanceof Collection || values.liked instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
            }
            else {
                throw new TypeError("The liked must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        if ("featured" in values && values.featured != null) {
            if (values.featured instanceof Collection || values.featured instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
            }
            else {
                throw new TypeError("The featured must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        if ("featuredTags" in values && values.featuredTags != null) {
            if (values.featuredTags instanceof Collection ||
                values.featuredTags instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [
                    values.featuredTags,
                ];
            }
            else {
                throw new TypeError("The featuredTags must be of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        if ("streams" in values && values.streams != null) {
            if (Array.isArray(values.streams) &&
                values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
            }
            else {
                throw new TypeError("The streams must be an array of type " +
                    "Collection | URL" + ".");
            }
        }
        clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        if ("endpoints" in values && values.endpoints != null) {
            if (values.endpoints instanceof Endpoints) {
                // @ts-ignore: type is checked above.
                clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
            }
            else {
                throw new TypeError("The endpoints must be of type " +
                    "Endpoints" + ".");
            }
        }
        clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        if ("discoverable" in values && values.discoverable != null) {
            if (typeof values.discoverable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [
                    values.discoverable,
                ];
            }
            else {
                throw new TypeError("The discoverable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        if ("suspended" in values && values.suspended != null) {
            if (typeof values.suspended === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
            }
            else {
                throw new TypeError("The suspended must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        if ("memorial" in values && values.memorial != null) {
            if (typeof values.memorial === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
            }
            else {
                throw new TypeError("The memorial must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        if ("indexable" in values && values.indexable != null) {
            if (typeof values.indexable === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
            }
            else {
                throw new TypeError("The indexable must be of type " +
                    "boolean" + ".");
            }
        }
        clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        if ("successor" in values && values.successor != null) {
            if (values.successor instanceof Application ||
                values.successor instanceof Group ||
                values.successor instanceof Organization ||
                values.successor instanceof Person ||
                values.successor instanceof _h || values.successor instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
            }
            else {
                throw new TypeError("The successor must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        if ("alias" in values && values.alias != null) {
            if (values.alias instanceof Application || values.alias instanceof Group ||
                values.alias instanceof Organization ||
                values.alias instanceof Person || values.alias instanceof _h ||
                values.alias instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
            }
            else {
                throw new TypeError("The alias must be of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        if ("aliases" in values && values.aliases != null) {
            if ("alias" in values &&
                values.alias != null) {
                throw new TypeError("Cannot update both alias and " +
                    "aliases at the same time.");
            }
            if (Array.isArray(values.aliases) &&
                values.aliases.every((v) => v instanceof Application || v instanceof Group ||
                    v instanceof Organization || v instanceof Person ||
                    v instanceof _h || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
            }
            else {
                throw new TypeError("The aliases must be an array of type " +
                    "Application | Group | Organization | Person | Service | URL" + ".");
            }
        }
        clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        if ("service" in values && values.service != null) {
            if (values.service instanceof DidService || values.service instanceof URL) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
            }
            else {
                throw new TypeError("The service must be of type " +
                    "DidService | URL" + ".");
            }
        }
        if ("services" in values && values.services != null) {
            if ("service" in values &&
                values.service != null) {
                throw new TypeError("Cannot update both service and " +
                    "services at the same time.");
            }
            if (Array.isArray(values.services) &&
                values.services.every((v) => v instanceof DidService || v instanceof URL)) {
                // @ts-ignore: type is checked above.
                clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
            }
            else {
                throw new TypeError("The services must be an array of type " +
                    "DidService | URL" + ".");
            }
        }
        clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        if ("followedMessage" in values && values.followedMessage != null) {
            if (typeof values.followedMessage === "string") {
                // @ts-ignore: type is checked above.
                clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [
                    values.followedMessage,
                ];
            }
            else {
                throw new TypeError("The followedMessage must be of type " +
                    "string" + ".");
            }
        }
        clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if ("cat" in values && values.cat != null) {
            if (typeof values.cat === "boolean") {
                // @ts-ignore: type is checked above.
                clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
            }
            else {
                throw new TypeError("The cat must be of type " +
                    "boolean" + ".");
            }
        }
        return clone;
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsername() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) {
            return null;
        }
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
    }
    /** A short username which may be used to refer to the actor,
     * with no uniqueness guarantees.
     */
    get preferredUsernames() {
        return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
    }
    async #fetchPublicKey(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#publicKey_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #publicKey_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await CryptographicKey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Key"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getPublicKey},
     * but returns its `@id` URL instead of the object itself.
     */
    get publicKeyId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** A public part of the key pair owned by this actor.
     */
    async getPublicKey(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1)
            return null;
        const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchPublicKey(v, options);
            if (fetched == null)
                return null;
            this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "publicKey" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["publicKey"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#publicKey_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Service.getPublicKeys},
     * but returns their `@id`s instead of the objects themselves.
     */
    get publicKeyIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A public part of the key pair owned by this actor.
     */
    async *getPublicKeys(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchPublicKey(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "publicKey" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["publicKey"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#publicKey_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchAssertionMethod(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#assertionMethod_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #assertionMethod_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Multikey.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://w3id.org/security#Multikey"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getAssertionMethod},
     * but returns its `@id` URL instead of the object itself.
     */
    get assertionMethodId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async getAssertionMethod(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) {
            return null;
        }
        const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAssertionMethod(v, options);
            if (fetched == null)
                return null;
            this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "assertionMethod" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["assertionMethod"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#assertionMethod_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Service.getAssertionMethods},
     * but returns their `@id`s instead of the objects themselves.
     */
    get assertionMethodIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Represents this actor's public keys.  It serves as equivalent to
     * the `publicKeys` property, but is used for [FEP-521a] compliance.
     *
     * [FEP-521a]: https://w3id.org/fep/521a
     */
    async *getAssertionMethods(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAssertionMethod(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "assertionMethod" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["assertionMethod"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#assertionMethod_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** When `true`, conveys that for this actor, follow requests are not usually
     * automatically approved, but instead are examined by a person who may accept
     * or reject the request, at some time in the future.  Setting of `false`
     * conveys no information and may be ignored.  This information is typically
     * used to affect display of accounts, such as showing an account as private or
     * locked.
     */
    get manuallyApprovesFollowers() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1)
            return null;
        return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
    }
    async #fetchInbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#inbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #inbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getInbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get inboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The inbox stream contains all activities received by the actor.  The server
     * SHOULD filter content according to the requester's permission.  In general,
     * the owner of an inbox is likely to be able to access all of their inbox
     * contents.  Depending on access control, some other content may be public,
     * whereas other content may require authentication for non-owner users,
     * if they can access the inbox at all.
     *
     * The server MUST perform de-duplication of activities returned by the inbox.
     * Duplication can occur if an activity is addressed both to an actor's
     * followers, and a specific actor who also follows the recipient actor,
     * and the server has failed to de-duplicate the recipients list.
     * Such deduplication MUST be performed by comparing the `id` of the activities
     * and dropping any activities already seen.
     */
    async getInbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1)
            return null;
        const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchInbox(v, options);
            if (fetched == null)
                return null;
            this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "inbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["inbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#inbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchOutbox(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#outbox_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #outbox_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await OrderedCollection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await OrderedCollectionPage.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#OrderedCollection",
                "https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getOutbox},
     * but returns its `@id` URL instead of the object itself.
     */
    get outboxId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The outbox stream contains activities the user has published,
     * subject to the ability of the requestor to retrieve the activity
     * (that is, the contents of the outbox are filtered by the permissions of
     * the person reading it).  If a user submits a request without
     * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
     * the server should respond with all of the
     * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
     * This could potentially be all relevant objects published by the user,
     * though the number of available items is left to the discretion of those
     * implementing and deploying the server.
     */
    async getOutbox(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1)
            return null;
        const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchOutbox(v, options);
            if (fetched == null)
                return null;
            this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "outbox" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["outbox"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#outbox_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowing(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#following_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #following_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getFollowing},
     * but returns its `@id` URL instead of the object itself.
     */
    get followingId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everybody that the actor has followed, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * The `following` collection MUST be either an {@link OrderedCollection}
     * or a {@link Collection} and MAY be filtered on privileges of
     * an authenticated user or as appropriate when no authentication is given.
     */
    async getFollowing(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1)
            return null;
        const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowing(v, options);
            if (fetched == null)
                return null;
            this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "following" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["following"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#following_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFollowers(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#followers_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #followers_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getFollowers},
     * but returns its `@id` URL instead of the object itself.
     */
    get followersId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of everyone who has sent a {@link Follow} activity
     * for the actor, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
     * This is where one would find a list of all the actors that are following
     * the actor.  The `followers` collection MUST be either
     * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
     * privileges of an authenticated user or as appropriate when no authentication
     * is given.
     */
    async getFollowers(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1)
            return null;
        const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFollowers(v, options);
            if (fetched == null)
                return null;
            this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "followers" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["followers"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#followers_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchLiked(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#liked_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #liked_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getLiked},
     * but returns its `@id` URL instead of the object itself.
     */
    get likedId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** This is a list of every object from all of the actor's {@link Like}
     * activities, added as a
     * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
     * The `liked` collection MUST be either an {@link OrderedCollection} or
     * a {@link Collection} and MAY be filtered on privileges of an authenticated
     * user or as appropriate when no authentication is given.
     */
    async getLiked(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1)
            return null;
        const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchLiked(v, options);
            if (fetched == null)
                return null;
            this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "liked" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["liked"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#liked_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeatured(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featured_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featured_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getFeatured},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "pinned statuses", or statuses that are always
     * featured at the top of people's profiles, is implemented using an extra
     * property `featured` on the actor object that points to a {@link Collection}
     * of objects.
     */
    async getFeatured(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1)
            return null;
        const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeatured(v, options);
            if (fetched == null)
                return null;
            this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featured" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featured"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featured_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchFeaturedTags(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#featuredTags_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #featuredTags_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getFeaturedTags},
     * but returns its `@id` URL instead of the object itself.
     */
    get featuredTagsId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** What is known in Mastodon as "featured hashtags", hashtags that are featured
     * at people's profiles, is implemented using an extra property `featuredTags`
     * on the actor object that points to a {@link Collection} of {@link Hashtag}
     * objects specifically.
     */
    async getFeaturedTags(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) {
            return null;
        }
        const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchFeaturedTags(v, options);
            if (fetched == null)
                return null;
            this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "featuredTags" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["featuredTags"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#featuredTags_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchStream(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#stream_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #stream_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Collection.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getStreams},
     * but returns their `@id`s instead of the objects themselves.
     */
    get streamIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** A list of supplementary Collections which may be of interest.
     */
    async *getStreams(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchStream(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "streams" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["streams"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#stream_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** A JSON object which maps additional (typically server/domain-wide) endpoints
     * which may be useful either for this actor or someone referencing this actor.
     * This mapping may be nested inside the actor document as the value or may be
     * a link to a JSON-LD document with these properties.
     */
    get endpoints() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1)
            return null;
        return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
    }
    /** Allows users to opt-in or opt-out of discoverability features like
     * the profile directory.  This flag may also be used as an indicator of
     * the user's preferences toward being included in external discovery services,
     * such as search engines or other indexing tools.
     */
    get discoverable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1)
            return null;
        return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
    }
    /** Reports whether a user was locally suspended, for better handling of
     * these accounts.
     */
    get suspended() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1)
            return null;
        return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
    }
    /** Whether the actor is in-memorial state.
     */
    get memorial() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1)
            return null;
        return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
    }
    /** Whether the actor allows to be indexed.
     */
    get indexable() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1)
            return null;
        return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
    }
    async #fetchSuccessor(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#successor_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #successor_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _h.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getSuccessor},
     * but returns its `@id` URL instead of the object itself.
     */
    get successorId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
     */
    async getSuccessor(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1)
            return null;
        const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchSuccessor(v, options);
            if (fetched == null)
                return null;
            this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "movedTo" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["movedTo"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#successor_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    async #fetchAlias(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#alias_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #alias_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await Application.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Group.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Organization.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await Person.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        try {
            return await _h.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            [
                "https://www.w3.org/ns/activitystreams#Application",
                "https://www.w3.org/ns/activitystreams#Group",
                "https://www.w3.org/ns/activitystreams#Organization",
                "https://www.w3.org/ns/activitystreams#Person",
                "https://www.w3.org/ns/activitystreams#Service",
            ].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getAlias},
     * but returns its `@id` URL instead of the object itself.
     */
    get aliasId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async getAlias(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1)
            return null;
        const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchAlias(v, options);
            if (fetched == null)
                return null;
            this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "alsoKnownAs" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["alsoKnownAs"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#alias_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Service.getAliases},
     * but returns their `@id`s instead of the objects themselves.
     */
    get aliasIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
     * or aliases for an entity.  It can be used to provide additional identifiers
     * or labels for an entity, which can be useful in scenarios where an entity
     * may have multiple names or aliases.
     */
    async *getAliases(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchAlias(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "alsoKnownAs" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["alsoKnownAs"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#alias_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    async #fetchService(url, options = {}) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
            let fetchResult;
            try {
                fetchResult = await documentLoader(url.href);
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                span.end();
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", { error, url: url.href });
                    return null;
                }
                throw error;
            }
            const { document } = fetchResult;
            try {
                const obj = await this.#service_fromJsonLd(document, { documentLoader, contextLoader, tracerProvider });
                span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
                span.setAttribute("activitypub.object.type", 
                // @ts-ignore: obj.constructor always has a typeId.
                obj.constructor.typeId.href);
                return obj;
            }
            catch (e) {
                if (options.suppressError) {
                    getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", { error: e, url: url.href });
                    return null;
                }
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(e),
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async #service_fromJsonLd(jsonLd, options) {
        const documentLoader = options.documentLoader ?? this._documentLoader ??
            getDocumentLoader();
        const contextLoader = options.contextLoader ?? this._contextLoader ??
            getDocumentLoader();
        const tracerProvider = options.tracerProvider ??
            this._tracerProvider ?? trace.getTracerProvider();
        try {
            return await DidService.fromJsonLd(jsonLd, { documentLoader, contextLoader, tracerProvider });
        }
        catch (e) {
            if (!(e instanceof TypeError))
                throw e;
        }
        throw new TypeError("Expected an object of any type of: " +
            ["https://www.w3.org/ns/did#Service"].join(", "));
    }
    /**
     * Similar to
     * {@link Service.getService},
     * but returns its `@id` URL instead of the object itself.
     */
    get serviceId() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL)
            return v;
        return v.id;
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async getService(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1)
            return null;
        const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        if (v instanceof URL) {
            const fetched = await this.#fetchService(v, options);
            if (fetched == null)
                return null;
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
            this._cachedJsonLd = undefined;
            return fetched;
        }
        if (this._cachedJsonLd != null &&
            typeof this._cachedJsonLd === "object" &&
            "@context" in this._cachedJsonLd &&
            "service" in this._cachedJsonLd) {
            const prop = this._cachedJsonLd["service"];
            const obj = Array.isArray(prop) ? prop[0] : prop;
            if (obj != null && typeof obj === "object" && "@context" in obj) {
                return await this.#service_fromJsonLd(obj, options);
            }
        }
        return v;
    }
    /**
     * Similar to
     * {@link Service.getServices},
     * but returns their `@id`s instead of the objects themselves.
     */
    get serviceIds() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
    }
    /** Means of communicating or interacting with the DID subject or associated
     * entities via one or more service endpoints. Examples include discovery
     * services, agent services, social networking services, file storage services,
     * and verifiable credential repository services.
     */
    async *getServices(options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        for (let i = 0; i < vs.length; i++) {
            const v = vs[i];
            if (v instanceof URL) {
                const fetched = await this.#fetchService(v, options);
                if (fetched == null)
                    continue;
                vs[i] = fetched;
                this._cachedJsonLd = undefined;
                yield fetched;
                continue;
            }
            if (this._cachedJsonLd != null &&
                typeof this._cachedJsonLd === "object" &&
                "@context" in this._cachedJsonLd &&
                "service" in this._cachedJsonLd) {
                const prop = this._cachedJsonLd["service"];
                const obj = Array.isArray(prop) ? prop[i] : prop;
                if (obj != null && typeof obj === "object" && "@context" in obj) {
                    yield await this.#service_fromJsonLd(obj, options);
                    continue;
                }
            }
            yield v;
        }
    }
    /** This value is used for `Actor` type objects to show message on followed.
     */
    get followedMessage() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1)
            return null;
        return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
    }
    /** Used on actors to indicate that they in some way identify as a cat,
     * expressed as a boolean value. If this property is set to `true`,
     * displaying the actor or their notes will have some special effects
     * attached in some clients.
     */
    get cat() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1)
            return null;
        return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["preferredUsername"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["publicKey"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["assertionMethod"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["manuallyApprovesFollowers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["inbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof OrderedCollection
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["outbox"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["following"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["followers"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["liked"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featured"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["featuredTags"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["streams"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
                const item = await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["endpoints"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["discoverable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["suspended"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["memorial"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["indexable"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["movedTo"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
                const item = v instanceof URL
                    ? v.href
                    : v instanceof Application
                        ? await v.toJsonLd({
                            ...options,
                            format: undefined,
                            context: undefined,
                        })
                        : v instanceof Group
                            ? await v.toJsonLd({
                                ...options,
                                format: undefined,
                                context: undefined,
                            })
                            : v instanceof Organization
                                ? await v.toJsonLd({
                                    ...options,
                                    format: undefined,
                                    context: undefined,
                                })
                                : v instanceof Person
                                    ? await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    })
                                    : await v.toJsonLd({
                                        ...options,
                                        format: undefined,
                                        context: undefined,
                                    });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["alsoKnownAs"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
                const item = v instanceof URL ? v.href : await v.toJsonLd({
                    ...options,
                    format: undefined,
                    context: undefined,
                });
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["service"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["_misskey_followedMessage"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["isCat"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Service";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#preferredUsername"] =
                propValue;
        }
        array = [];
        for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#publicKey"] = propValue;
        }
        array = [];
        for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://w3id.org/security#assertionMethod"] = propValue;
        }
        array = [];
        for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
        }
        array = [];
        for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://www.w3.org/ns/ldp#inbox"] = propValue;
        }
        array = [];
        for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof OrderedCollection
                    ? await v.toJsonLd(options)
                    : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
        }
        array = [];
        for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#following"] = propValue;
        }
        array = [];
        for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
        }
        array = [];
        for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
        }
        array = [];
        for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featured"] = propValue;
        }
        array = [];
        for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#featuredTags"] = propValue;
        }
        array = [];
        for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
        }
        array = [];
        for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
            const element = await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
        }
        array = [];
        for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#discoverable"] = propValue;
        }
        array = [];
        for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#suspended"] = propValue;
        }
        array = [];
        for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#memorial"] = propValue;
        }
        array = [];
        for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["http://joinmastodon.org/ns#indexable"] = propValue;
        }
        array = [];
        for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
        }
        array = [];
        for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : v instanceof Application
                    ? await v.toJsonLd(options)
                    : v instanceof Group
                        ? await v.toJsonLd(options)
                        : v instanceof Organization
                            ? await v.toJsonLd(options)
                            : v instanceof Person
                                ? await v.toJsonLd(options)
                                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
        }
        array = [];
        for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
            const element = v instanceof URL
                ? { "@id": v.href }
                : await v.toJsonLd(options);
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/did#service"] = propValue;
        }
        array = [];
        for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
        }
        array = [];
        for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://misskey-hub.net/ns#isCat"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Service"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "toot": "http://joinmastodon.org/ns#",
                    "Emoji": "toot:Emoji",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null &&
            this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0)
            return false;
        if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null &&
            this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0)
            return false;
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Service__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Service__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Service")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof _h)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
        let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
        for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null
            ? []
            : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 &&
                "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]
                ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"]
                : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
        }
        instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername =
            _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
        let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
        for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null
            ? []
            : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 &&
                "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]
                ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"]
                : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, options));
        }
        instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey =
            _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
        let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
        for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null
            ? []
            : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 &&
                "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]
                ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"]
                : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, options));
        }
        instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod =
            _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
        let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
        for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null
            ? []
            : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array
                .length === 1 &&
                "@list" in
                    _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]
                ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"]
                : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
            if (v == null)
                continue;
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
        }
        instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers =
            _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
        let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
        for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null
            ? []
            : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 &&
                "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]
                ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"]
                : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
        }
        instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox =
            _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
        let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
        for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null
            ? []
            : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 &&
                "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]
                ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"]
                : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")
                ? await OrderedCollection.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")
                    ? await OrderedCollectionPage.fromJsonLd(v, options)
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
        }
        instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox =
            _41QwhqJouoLg3h8dRPKat21brynC_outbox;
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
        let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
        for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null
            ? []
            : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 &&
                "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]
                ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"]
                : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following =
            _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
        let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
        for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null
            ? []
            : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 &&
                "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]
                ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"]
                : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers =
            _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
        let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
        for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null
            ? []
            : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 &&
                "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]
                ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"]
                : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked =
            _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
        let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
        for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null
            ? []
            : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 &&
                "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]
                ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"]
                : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured =
            _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
        let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
        for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null
            ? []
            : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 &&
                "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]
                ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"]
                : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags =
            _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
        let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
        for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null
            ? []
            : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 &&
                "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]
                ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"]
                : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, options));
        }
        instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams =
            _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
        let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
        for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null
            ? []
            : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 &&
                "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]
                ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"]
                : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
            if (v == null)
                continue;
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, options));
        }
        instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints =
            _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
        let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
        for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null
            ? []
            : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 &&
                "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]
                ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"]
                : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
            if (v == null)
                continue;
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
        }
        instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable =
            _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
        let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
        for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null
            ? []
            : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 &&
                "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]
                ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"]
                : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
            if (v == null)
                continue;
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
        }
        instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended =
            _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
        let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
        for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null
            ? []
            : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 &&
                "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]
                ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"]
                : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
            if (v == null)
                continue;
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
        }
        instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial =
            _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
        let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
        for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null
            ? []
            : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 &&
                "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]
                ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"]
                : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
            if (v == null)
                continue;
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
        }
        instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable =
            _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
        let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
        for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null
            ? []
            : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 &&
                "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]
                ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"]
                : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await _h.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
        }
        instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo =
            _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
        let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
        for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null
            ? []
            : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 &&
                "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]
                ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"]
                : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            const decoded = typeof v === "object" && "@type" in v &&
                Array.isArray(v["@type"]) &&
                v["@type"].includes("https://www.w3.org/ns/activitystreams#Application")
                ? await Application.fromJsonLd(v, options)
                : typeof v === "object" && "@type" in v &&
                    Array.isArray(v["@type"]) &&
                    v["@type"].includes("https://www.w3.org/ns/activitystreams#Group")
                    ? await Group.fromJsonLd(v, options)
                    : typeof v === "object" && "@type" in v &&
                        Array.isArray(v["@type"]) &&
                        v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")
                        ? await Organization.fromJsonLd(v, options)
                        : typeof v === "object" && "@type" in v &&
                            Array.isArray(v["@type"]) &&
                            v["@type"].includes("https://www.w3.org/ns/activitystreams#Person")
                            ? await Person.fromJsonLd(v, options)
                            : typeof v === "object" && "@type" in v &&
                                Array.isArray(v["@type"]) &&
                                v["@type"].includes("https://www.w3.org/ns/activitystreams#Service")
                                ? await _h.fromJsonLd(v, options)
                                : undefined;
            if (typeof decoded === "undefined")
                continue;
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
        }
        instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs =
            _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
        let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
        for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null
            ? []
            : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 &&
                "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]
                ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"]
                : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
            if (v == null)
                continue;
            if (typeof v === "object" && "@id" in v && !("@type" in v) &&
                globalThis.Object.keys(v).length === 1) {
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://")
                    ? new URL("at://" + encodeURIComponent(v["@id"].substring(5)))
                    : new URL(v["@id"]));
                continue;
            }
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, options));
        }
        instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service =
            _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
        let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
        for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null
            ? []
            : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array
                .length === 1 &&
                "@list" in
                    _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]
                ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"]
                : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
            if (v == null)
                continue;
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
        }
        instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage =
            _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
        let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
        for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null
            ? []
            : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 &&
                "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]
                ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"]
                : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
            if (v == null)
                continue;
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
        }
        instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat =
            _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this
            .#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) {
            proxy.preferredUsername =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
        }
        if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 ||
            !("preferredUsername" in proxy) &&
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) {
            proxy.preferredUsernames =
                _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
        }
        const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this
            .#_axq166E2eZADq34V4MYUc8KMZdC_publicKey
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) {
            proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
        }
        if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 ||
            !("publicKey" in proxy) &&
                _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) {
            proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
        }
        const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this
            .#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) {
            proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
        }
        if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 ||
            !("assertionMethod" in proxy) &&
                _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) {
            proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
        }
        const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this
            .#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) {
            proxy.manuallyApprovesFollowers =
                _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
        }
        const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this
            .#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) {
            proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
        }
        const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this
            .#_41QwhqJouoLg3h8dRPKat21brynC_outbox
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) {
            proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
        }
        const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this
            .#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) {
            proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
        }
        const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this
            .#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) {
            proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
        }
        const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this
            .#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) {
            proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
        }
        const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this
            .#_4N1vBJzXDf8NbBumeECQMFvKetja_featured
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) {
            proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
        }
        const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this
            .#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) {
            proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
        }
        const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this
            .#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 ||
            !("stream" in proxy) &&
                _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) {
            proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
        }
        const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this
            .#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) {
            proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
        }
        const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this
            .#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) {
            proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
        }
        const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this
            .#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) {
            proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
        }
        const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this
            .#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) {
            proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
        }
        const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this
            .#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) {
            proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
        }
        const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this
            .#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) {
            proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
        }
        const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this
            .#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) {
            proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
        }
        if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 ||
            !("alias" in proxy) &&
                _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) {
            proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
        }
        const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this
            .#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) {
            proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
        }
        if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 ||
            !("service" in proxy) &&
                _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) {
            proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
        }
        const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this
            .#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) {
            proxy.followedMessage =
                _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
        }
        const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this
            .#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) {
            proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Service " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Service " + inspect(proxy, options);
    }
}
_h = Service;
/** Contents of {@link Object}'s `source`.
 */
export class Source {
    #documentLoader;
    #contextLoader;
    #tracerProvider;
    #warning;
    #cachedJsonLd;
    id;
    get _documentLoader() {
        return this.#documentLoader;
    }
    get _contextLoader() {
        return this.#contextLoader;
    }
    get _tracerProvider() {
        return this.#tracerProvider;
    }
    get _warning() {
        return this.#warning;
    }
    get _cachedJsonLd() {
        return this.#cachedJsonLd;
    }
    set _cachedJsonLd(value) {
        this.#cachedJsonLd = value;
    }
    /**
     * The type URI of {@link Source}: `https://www.w3.org/ns/activitystreams#Source`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Source");
    }
    #_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
    #_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
    /**
     * Constructs a new instance of Source with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        this.#documentLoader = options.documentLoader;
        this.#contextLoader = options.contextLoader;
        this.#tracerProvider = options.tracerProvider;
        if ("$warning" in options) {
            this.#warning = options.$warning;
        }
        if (values.id == null || values.id instanceof URL) {
            this.id = values.id ?? null;
        }
        else {
            throw new TypeError("The id must be a URL.");
        }
        if ("content" in values && values.content != null) {
            if (typeof values.content === "string" ||
                values.content instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
            }
            else {
                throw new TypeError("The content must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("contents" in values && values.contents != null) {
            if ("content" in values &&
                values.content != null) {
                throw new TypeError("Cannot initialize both content and " +
                    "contents at the same time.");
            }
            if (Array.isArray(values.contents) &&
                values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
            }
            else {
                throw new TypeError("The contents must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("mediaType" in values && values.mediaType != null) {
            if (typeof values.mediaType === "string") {
                // @ts-ignore: type is checked above.
                this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
            }
            else {
                throw new TypeError("The mediaType must be of type " +
                    "string" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        // @ts-ignore: this.constructor is not recognized as a constructor, but it is.
        const clone = new this.constructor({ id: values.id ?? this.id }, options);
        clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content =
            this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
        if ("content" in values && values.content != null) {
            if (typeof values.content === "string" ||
                values.content instanceof LanguageString) {
                // @ts-ignore: type is checked above.
                clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
            }
            else {
                throw new TypeError("The content must be of type " +
                    "string | LanguageString" + ".");
            }
        }
        if ("contents" in values && values.contents != null) {
            if ("content" in values &&
                values.content != null) {
                throw new TypeError("Cannot update both content and " +
                    "contents at the same time.");
            }
            if (Array.isArray(values.contents) &&
                values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) {
                // @ts-ignore: type is checked above.
                clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
            }
            else {
                throw new TypeError("The contents must be an array of type " +
                    "string | LanguageString" + ".");
            }
        }
        clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType =
            this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
        if ("mediaType" in values && values.mediaType != null) {
            if (typeof values.mediaType === "string") {
                // @ts-ignore: type is checked above.
                clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
            }
            else {
                throw new TypeError("The mediaType must be of type " +
                    "string" + ".");
            }
        }
        return clone;
    }
    /** The source content.
     */
    get content() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length < 1)
            return null;
        return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
    }
    /** The source content.
     */
    get contents() {
        return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
    }
    /** The MIME media type of the source content.
     */
    get mediaType() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length < 1)
            return null;
        return this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = {};
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
                const item = typeof v === "string" ? v : {
                    "@value": v.toString(),
                    "@language": v.language.compact(),
                };
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["content"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            compactItems = [];
            for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
                const item = v;
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["mediaType"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "as:Source";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = "https://www.w3.org/ns/activitystreams";
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const values = {};
        array = [];
        for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
            const element = typeof v === "string" ? { "@value": v } : {
                "@value": v.toString(),
                "@language": v.language.compact(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#content"] = propValue;
        }
        array = [];
        for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
            const element = { "@value": v };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#mediaType"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Source"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            "https://www.w3.org/ns/activitystreams";
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
        }
        return compacted;
    }
    isCompactable() {
        if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content != null &&
            this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0)
            return false;
        return true;
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Source__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Source__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Source")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : undefined }, options);
        const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
        let _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array = values["https://www.w3.org/ns/activitystreams#content"];
        for (const v of _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array == null
            ? []
            : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array.length === 1 &&
                "@list" in _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0]
                ? _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0]["@list"]
                : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array) {
            if (v == null)
                continue;
            const decoded = typeof v === "object" && "@value" in v &&
                typeof v["@value"] === "string" && !("@language" in v)
                ? v["@value"]
                : typeof v === "object" && "@language" in v && "@value" in v &&
                    typeof v["@language"] === "string" &&
                    typeof v["@value"] === "string"
                    ? new LanguageString(v["@value"], v["@language"])
                    : undefined;
            if (typeof decoded === "undefined")
                continue;
            _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.push(decoded);
        }
        instance.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content =
            _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
        const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
        let _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array = values["https://www.w3.org/ns/activitystreams#mediaType"];
        for (const v of _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array == null
            ? []
            : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array.length === 1 &&
                "@list" in _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]
                ? _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]["@list"]
                : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array) {
            if (v == null)
                continue;
            _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.push(v["@value"]);
        }
        instance.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType =
            _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = {};
        if (this.id != null) {
            proxy.id = {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options),
            };
        }
        const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = this
            .#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length == 1) {
            proxy.content = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
        }
        if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 1 ||
            !("content" in proxy) &&
                _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0) {
            proxy.contents = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
        }
        const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this
            .#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length == 1) {
            proxy.mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Source " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Source " + inspect(proxy, options);
    }
}
/** A specialization of {@link Accept} indicating that
 * the acceptance is tentative.
 */
export class TentativeAccept extends Accept {
    /**
     * The type URI of {@link TentativeAccept}: `https://www.w3.org/ns/activitystreams#TentativeAccept`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#TentativeAccept");
    }
    /**
     * Constructs a new instance of TentativeAccept with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#TentativeAccept"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__TentativeAccept__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__TentativeAccept__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof TentativeAccept)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "TentativeAccept " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "TentativeAccept " + inspect(proxy, options);
    }
}
/** A specialization of {@link Reject} in which
 * the rejection is considered tentative.
 */
export class TentativeReject extends Reject {
    /**
     * The type URI of {@link TentativeReject}: `https://www.w3.org/ns/activitystreams#TentativeReject`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#TentativeReject");
    }
    /**
     * Constructs a new instance of TentativeReject with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#TentativeReject"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__TentativeReject__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__TentativeReject__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof TentativeReject)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "TentativeReject " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "TentativeReject " + inspect(proxy, options);
    }
}
/** A `Tombstone` represents a content object that has been deleted.
 * It can be used in {@link Collection}s to signify that there used to be
 * an object at this position, but it has been deleted.
 */
export class Tombstone extends Object {
    /**
     * The type URI of {@link Tombstone}: `https://www.w3.org/ns/activitystreams#Tombstone`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Tombstone");
    }
    #_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [];
    /**
     * Constructs a new instance of Tombstone with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
        if ("deleted" in values && values.deleted != null) {
            if (values.deleted instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [values.deleted];
            }
            else {
                throw new TypeError("The deleted must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        clone.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted =
            this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted;
        if ("deleted" in values && values.deleted != null) {
            if (values.deleted instanceof dntShim.Temporal.Instant) {
                // @ts-ignore: type is checked above.
                clone.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [values.deleted];
            }
            else {
                throw new TypeError("The deleted must be of type " +
                    "Temporal.Instant" + ".");
            }
        }
        return clone;
    }
    /** On a `Tombstone` object, the `deleted` property is a timestamp for when
     * the object was deleted.
     */
    get deleted() {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
        }
        if (this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted.length < 1)
            return null;
        return this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted[0];
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            compactItems = [];
            for (const v of this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted) {
                const item = v.toString();
                compactItems.push(item);
            }
            if (compactItems.length > 0) {
                result["deleted"] = compactItems.length > 1
                    ? compactItems
                    : compactItems[0];
            }
            result["type"] = "Tombstone";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        array = [];
        for (const v of this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted) {
            const element = {
                "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                "@value": v.toString(),
            };
            array.push(element);
        }
        if (array.length > 0) {
            const propValue = array;
            values["https://www.w3.org/ns/activitystreams#deleted"] = propValue;
        }
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Tombstone"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Tombstone__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Tombstone__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Tombstone")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Tombstone)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        const _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [];
        let _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array = values["https://www.w3.org/ns/activitystreams#deleted"];
        for (const v of _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array == null
            ? []
            : _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array.length === 1 &&
                "@list" in _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array[0]
                ? _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array[0]["@list"]
                : _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array) {
            if (v == null)
                continue;
            _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted.push(dntShim.Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/)
                ? v["@value"]
                : v["@value"] + "Z"));
        }
        instance.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted =
            _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted;
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        const _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = this
            .#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted
            // deno-lint-ignore no-explicit-any
            .map((v) => v instanceof URL
            ? {
                [Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
                [Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options),
            }
            : v);
        if (_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted.length == 1) {
            proxy.deleted = _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted[0];
        }
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Tombstone " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Tombstone " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is traveling to `target` from `origin`.
 * `Travel` is an `IntransitiveObject` whose `actor` specifies the direct object.
 * If the `target` or `origin` are not specified,
 * either can be determined by context.
 */
export class Travel extends IntransitiveActivity {
    /**
     * The type URI of {@link Travel}: `https://www.w3.org/ns/activitystreams#Travel`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Travel");
    }
    /**
     * Constructs a new instance of Travel with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Travel"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Travel__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Travel__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Travel)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Travel " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Travel " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` is undoing the `object`.  In most cases,
 * the `object` will be an {@link Activity} describing some previously performed
 * action (for instance, a person may have previously "liked" an article but,
 * for whatever reason, might choose to undo that like at some later point in
 * time).
 *
 * The `target` and `origin` typically have no defined meaning.
 */
export class Undo extends Activity {
    /**
     * The type URI of {@link Undo}: `https://www.w3.org/ns/activitystreams#Undo`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Undo");
    }
    /**
     * Constructs a new instance of Undo with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Undo"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "litepub": "http://litepub.social/ns#",
                    "toot": "http://joinmastodon.org/ns#",
                    "EmojiReact": "litepub:EmojiReact",
                    "Emoji": "toot:Emoji",
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Undo__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Undo__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Undo")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Undo)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Undo " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Undo " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has updated the `object`.  Note, however,
 * that this vocabulary does not define a mechanism for describing the actual
 * set of modifications made to `object`.
 *
 * The `target` and `origin` typically have no defined meaning.
 */
export class Update extends Activity {
    /**
     * The type URI of {@link Update}: `https://www.w3.org/ns/activitystreams#Update`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Update");
    }
    /**
     * Constructs a new instance of Update with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Update"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/v1",
                "https://w3id.org/security/data-integrity/v1",
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1",
                {
                    "alsoKnownAs": { "@id": "as:alsoKnownAs", "@type": "@id" },
                    "manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
                    "sensitive": "as:sensitive",
                    "movedTo": { "@id": "as:movedTo", "@type": "@id" },
                    "quoteUrl": "as:quoteUrl",
                    "toot": "http://joinmastodon.org/ns#",
                    "featured": { "@id": "toot:featured", "@type": "@id" },
                    "featuredTags": { "@id": "toot:featuredTags", "@type": "@id" },
                    "discoverable": "toot:discoverable",
                    "suspended": "toot:suspended",
                    "memorial": "toot:memorial",
                    "indexable": "toot:indexable",
                    "votersCount": "toot:votersCount",
                    "Emoji": "toot:Emoji",
                    "Hashtag": "as:Hashtag",
                    "schema": "http://schema.org#",
                    "PropertyValue": "schema:PropertyValue",
                    "value": "schema:value",
                    "ChatMessage": "http://litepub.social/ns#ChatMessage",
                    "fedibird": "http://fedibird.com/ns#",
                    "quoteUri": "fedibird:quoteUri",
                    "misskey": "https://misskey-hub.net/ns#",
                    "_misskey_quote": "misskey:_misskey_quote",
                    "_misskey_followedMessage": "misskey:_misskey_followedMessage",
                    "isCat": "misskey:isCat",
                    "emojiReactions": {
                        "@id": "fedibird:emojiReactions",
                        "@type": "@id",
                    },
                },
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Update__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Update__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Update")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Update)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Update " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Update " + inspect(proxy, options);
    }
}
/** Represents a video document of any kind.
 */
export class Video extends Document {
    /**
     * The type URI of {@link Video}: `https://www.w3.org/ns/activitystreams#Video`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#Video");
    }
    /**
     * Constructs a new instance of Video with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        if (options.format == null && this.isCompactable()) {
            const result = await super.toJsonLd({
                ...options,
                format: undefined,
                context: undefined,
            });
            // deno-lint-ignore no-unused-vars
            let compactItems;
            result["type"] = "Video";
            if (this.id != null)
                result["id"] = this.id.href;
            result["@context"] = [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
            return result;
        }
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#Video"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__Video__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__Video__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Video")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof Video)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "Video " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "Video " + inspect(proxy, options);
    }
}
/** Indicates that the `actor` has viewed the object.
 */
export class View extends Activity {
    /**
     * The type URI of {@link View}: `https://www.w3.org/ns/activitystreams#View`.
     */
    static get typeId() {
        return new URL("https://www.w3.org/ns/activitystreams#View");
    }
    /**
     * Constructs a new instance of View with the given values.
     * @param values The values to initialize the instance with.
     * @param options The options to use for initialization.
     */
    constructor(values, options = {}) {
        super(values, options);
    }
    /**
     * Clones this instance, optionally updating it with the given values.
     * @param values The values to update the clone with.
     * @options The options to use for cloning.
     * @returns The cloned instance.
     */
    clone(values = {}, options = {}) {
        if (this._warning != null) {
            getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
            // @ts-ignore: $warning is not recognized as a property, but it is.
            options = { ...options, $warning: this._warning };
        }
        const clone = super.clone(values, options);
        return clone;
    }
    /**
     * Converts this object to a JSON-LD structure.
     * @param options The options to use.
     *                - `format`: The format of the output: `compact` or
                        `expand`.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `context`: The JSON-LD context to use.  Not applicable
                        when `format` is set to `'expand'`.
     * @returns The JSON-LD representation of this object.
     */
    async toJsonLd(options = {}) {
        if (options.format == null && this._cachedJsonLd != null) {
            return this._cachedJsonLd;
        }
        if (options.format !== "compact" && options.context != null) {
            throw new TypeError("The context option can only be used when the format option is set " +
                "to 'compact'.");
        }
        options = {
            ...options,
            contextLoader: options.contextLoader ?? getDocumentLoader(),
        };
        // deno-lint-ignore no-unused-vars prefer-const
        let array;
        const baseValues = await super.toJsonLd({
            ...options,
            format: "expand",
            context: undefined,
        });
        const values = baseValues[0];
        values["@type"] = ["https://www.w3.org/ns/activitystreams#View"];
        if (this.id != null)
            values["@id"] = this.id.href;
        if (options.format === "expand") {
            return await jsonld.expand(values, { documentLoader: options.contextLoader });
        }
        const docContext = options.context ??
            [
                "https://w3id.org/identity/v1",
                "https://www.w3.org/ns/activitystreams",
                "https://w3id.org/security/data-integrity/v1",
            ];
        const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
        if (docContext != null) {
            // Embed context
            if ("proof" in compacted &&
                compacted.proof != null) {
                if (Array.isArray(compacted.proof)) {
                    for (const element of compacted.proof) {
                        element["@context"] = docContext;
                    }
                }
                else {
                    compacted.proof["@context"] = docContext;
                }
            }
        }
        return compacted;
    }
    isCompactable() {
        return super.isCompactable();
    }
    /**
     * Converts a JSON-LD structure to an object of this type.
     * @param json The JSON-LD structure to convert.
     * @param options The options to use.
     *                - `documentLoader`: The loader for remote JSON-LD documents.
     *                - `contextLoader`: The loader for remote JSON-LD contexts.
     *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
     *                  If omitted, the global tracer provider is used.
     * @returns The object of this type.
     * @throws {TypeError} If the given `json` is invalid.
     */
    static async fromJsonLd(json, options = {}) {
        const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
        const tracer = tracerProvider.getTracer("@fedify/fedify", "1.5.1");
        return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
            try {
                const object = await this.__fromJsonLd__View__(json, span, options);
                if (object.id != null) {
                    span.setAttribute("activitypub.object.id", object.id.href);
                }
                return object;
            }
            catch (error) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(error),
                });
                throw error;
            }
            finally {
                span.end();
            }
        });
    }
    static async __fromJsonLd__View__(json, span, options = {}) {
        if (typeof json === "undefined") {
            throw new TypeError("Invalid JSON-LD: undefined.");
        }
        else if (json === null)
            throw new TypeError("Invalid JSON-LD: null.");
        options = {
            ...options,
            documentLoader: options.documentLoader ?? getDocumentLoader(),
            contextLoader: options.contextLoader ?? getDocumentLoader(),
            tracerProvider: options.tracerProvider ?? trace.getTracerProvider(),
        };
        // deno-lint-ignore no-explicit-any
        let values;
        if (globalThis.Object.keys(json).length == 0) {
            values = {};
        }
        else {
            const expanded = await jsonld.expand(json, {
                documentLoader: options.contextLoader,
                keepFreeFloatingNodes: true,
            });
            values =
                // deno-lint-ignore no-explicit-any
                (expanded[0] ?? {});
        }
        if ("@type" in values) {
            span.setAttribute("activitypub.object.type", values["@type"]);
        }
        if ("@type" in values &&
            !values["@type"].every((t) => t.startsWith("_:"))) {
            if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#View")) {
                throw new TypeError("Invalid type: " + values["@type"]);
            }
        }
        delete values["@type"];
        const instance = await super.fromJsonLd(values, {
            ...options,
            // @ts-ignore: an internal option
            _fromSubclass: true,
        });
        if (!(instance instanceof View)) {
            throw new TypeError("Unexpected type: " + instance.constructor.name);
        }
        if (!("_fromSubclass" in options) || !options._fromSubclass) {
            try {
                instance._cachedJsonLd = structuredClone(json);
            }
            catch {
                getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
            }
        }
        return instance;
    }
    _getCustomInspectProxy() {
        const proxy = super._getCustomInspectProxy();
        return proxy;
    }
    [Symbol.for("Deno.customInspect")](inspect, options) {
        const proxy = this._getCustomInspectProxy();
        return "View " + inspect(proxy, options);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        const proxy = this._getCustomInspectProxy();
        return "View " + inspect(proxy, options);
    }
}
